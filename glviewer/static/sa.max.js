/*! jQuery UI - v1.8.22 - 2012-07-24
* https://github.com/jquery/jquery-ui
* Includes: jquery.ui.core.js, jquery.ui.widget.js, jquery.ui.mouse.js, jquery.ui.draggable.js, jquery.ui.droppable.js, jquery.ui.resizable.js, jquery.ui.selectable.js, jquery.ui.sortable.js, jquery.effects.core.js, jquery.effects.blind.js, jquery.effects.bounce.js, jquery.effects.clip.js, jquery.effects.drop.js, jquery.effects.explode.js, jquery.effects.fade.js, jquery.effects.fold.js, jquery.effects.highlight.js, jquery.effects.pulsate.js, jquery.effects.scale.js, jquery.effects.shake.js, jquery.effects.slide.js, jquery.effects.transfer.js, jquery.ui.accordion.js, jquery.ui.autocomplete.js, jquery.ui.button.js, jquery.ui.datepicker.js, jquery.ui.dialog.js, jquery.ui.position.js, jquery.ui.progressbar.js, jquery.ui.slider.js, jquery.ui.tabs.js
* Copyright (c) 2012 AUTHORS.txt; Licensed MIT, GPL */
(function(a,b){function c(b,c){var e=b.nodeName.toLowerCase();if("area"===e){var f=b.parentNode,g=f.name,h;return!b.href||!g||f.nodeName.toLowerCase()!=="map"?!1:(h=a("img[usemap=#"+g+"]")[0],!!h&&d(h))}return(/input|select|textarea|button|object/.test(e)?!b.disabled:"a"==e?b.href||c:c)&&d(b)}function d(b){return!a(b).parents().andSelf().filter(function(){return a.curCSS(this,"visibility")==="hidden"||a.expr.filters.hidden(this)}).length}a.ui=a.ui||{};if(a.ui.version)return;a.extend(a.ui,{version:"1.8.22",keyCode:{ALT:18,BACKSPACE:8,CAPS_LOCK:20,COMMA:188,COMMAND:91,COMMAND_LEFT:91,COMMAND_RIGHT:93,CONTROL:17,DELETE:46,DOWN:40,END:35,ENTER:13,ESCAPE:27,HOME:36,INSERT:45,LEFT:37,MENU:93,NUMPAD_ADD:107,NUMPAD_DECIMAL:110,NUMPAD_DIVIDE:111,NUMPAD_ENTER:108,NUMPAD_MULTIPLY:106,NUMPAD_SUBTRACT:109,PAGE_DOWN:34,PAGE_UP:33,PERIOD:190,RIGHT:39,SHIFT:16,SPACE:32,TAB:9,UP:38,WINDOWS:91}}),a.fn.extend({propAttr:a.fn.prop||a.fn.attr,_focus:a.fn.focus,focus:function(b,c){return typeof b=="number"?this.each(function(){var d=this;setTimeout(function(){a(d).focus(),c&&c.call(d)},b)}):this._focus.apply(this,arguments)},scrollParent:function(){var b;return a.browser.msie&&/(static|relative)/.test(this.css("position"))||/absolute/.test(this.css("position"))?b=this.parents().filter(function(){return/(relative|absolute|fixed)/.test(a.curCSS(this,"position",1))&&/(auto|scroll)/.test(a.curCSS(this,"overflow",1)+a.curCSS(this,"overflow-y",1)+a.curCSS(this,"overflow-x",1))}).eq(0):b=this.parents().filter(function(){return/(auto|scroll)/.test(a.curCSS(this,"overflow",1)+a.curCSS(this,"overflow-y",1)+a.curCSS(this,"overflow-x",1))}).eq(0),/fixed/.test(this.css("position"))||!b.length?a(document):b},zIndex:function(c){if(c!==b)return this.css("zIndex",c);if(this.length){var d=a(this[0]),e,f;while(d.length&&d[0]!==document){e=d.css("position");if(e==="absolute"||e==="relative"||e==="fixed"){f=parseInt(d.css("zIndex"),10);if(!isNaN(f)&&f!==0)return f}d=d.parent()}}return 0},disableSelection:function(){return this.bind((a.support.selectstart?"selectstart":"mousedown")+".ui-disableSelection",function(a){a.preventDefault()})},enableSelection:function(){return this.unbind(".ui-disableSelection")}}),a("<a>").outerWidth(1).jquery||a.each(["Width","Height"],function(c,d){function h(b,c,d,f){return a.each(e,function(){c-=parseFloat(a.curCSS(b,"padding"+this,!0))||0,d&&(c-=parseFloat(a.curCSS(b,"border"+this+"Width",!0))||0),f&&(c-=parseFloat(a.curCSS(b,"margin"+this,!0))||0)}),c}var e=d==="Width"?["Left","Right"]:["Top","Bottom"],f=d.toLowerCase(),g={innerWidth:a.fn.innerWidth,innerHeight:a.fn.innerHeight,outerWidth:a.fn.outerWidth,outerHeight:a.fn.outerHeight};a.fn["inner"+d]=function(c){return c===b?g["inner"+d].call(this):this.each(function(){a(this).css(f,h(this,c)+"px")})},a.fn["outer"+d]=function(b,c){return typeof b!="number"?g["outer"+d].call(this,b):this.each(function(){a(this).css(f,h(this,b,!0,c)+"px")})}}),a.extend(a.expr[":"],{data:a.expr.createPseudo?a.expr.createPseudo(function(b){return function(c){return!!a.data(c,b)}}):function(b,c,d){return!!a.data(b,d[3])},focusable:function(b){return c(b,!isNaN(a.attr(b,"tabindex")))},tabbable:function(b){var d=a.attr(b,"tabindex"),e=isNaN(d);return(e||d>=0)&&c(b,!e)}}),a(function(){var b=document.body,c=b.appendChild(c=document.createElement("div"));c.offsetHeight,a.extend(c.style,{minHeight:"100px",height:"auto",padding:0,borderWidth:0}),a.support.minHeight=c.offsetHeight===100,a.support.selectstart="onselectstart"in c,b.removeChild(c).style.display="none"}),a.curCSS||(a.curCSS=a.css),a.extend(a.ui,{plugin:{add:function(b,c,d){var e=a.ui[b].prototype;for(var f in d)e.plugins[f]=e.plugins[f]||[],e.plugins[f].push([c,d[f]])},call:function(a,b,c){var d=a.plugins[b];if(!d||!a.element[0].parentNode)return;for(var e=0;e<d.length;e++)a.options[d[e][0]]&&d[e][1].apply(a.element,c)}},contains:function(a,b){return document.compareDocumentPosition?a.compareDocumentPosition(b)&16:a!==b&&a.contains(b)},hasScroll:function(b,c){if(a(b).css("overflow")==="hidden")return!1;var d=c&&c==="left"?"scrollLeft":"scrollTop",e=!1;return b[d]>0?!0:(b[d]=1,e=b[d]>0,b[d]=0,e)},isOverAxis:function(a,b,c){return a>b&&a<b+c},isOver:function(b,c,d,e,f,g){return a.ui.isOverAxis(b,d,f)&&a.ui.isOverAxis(c,e,g)}})})(jQuery),function(a,b){if(a.cleanData){var c=a.cleanData;a.cleanData=function(b){for(var d=0,e;(e=b[d])!=null;d++)try{a(e).triggerHandler("remove")}catch(f){}c(b)}}else{var d=a.fn.remove;a.fn.remove=function(b,c){return this.each(function(){return c||(!b||a.filter(b,[this]).length)&&a("*",this).add([this]).each(function(){try{a(this).triggerHandler("remove")}catch(b){}}),d.call(a(this),b,c)})}}a.widget=function(b,c,d){var e=b.split(".")[0],f;b=b.split(".")[1],f=e+"-"+b,d||(d=c,c=a.Widget),a.expr[":"][f]=function(c){return!!a.data(c,b)},a[e]=a[e]||{},a[e][b]=function(a,b){arguments.length&&this._createWidget(a,b)};var g=new c;g.options=a.extend(!0,{},g.options),a[e][b].prototype=a.extend(!0,g,{namespace:e,widgetName:b,widgetEventPrefix:a[e][b].prototype.widgetEventPrefix||b,widgetBaseClass:f},d),a.widget.bridge(b,a[e][b])},a.widget.bridge=function(c,d){a.fn[c]=function(e){var f=typeof e=="string",g=Array.prototype.slice.call(arguments,1),h=this;return e=!f&&g.length?a.extend.apply(null,[!0,e].concat(g)):e,f&&e.charAt(0)==="_"?h:(f?this.each(function(){var d=a.data(this,c),f=d&&a.isFunction(d[e])?d[e].apply(d,g):d;if(f!==d&&f!==b)return h=f,!1}):this.each(function(){var b=a.data(this,c);b?b.option(e||{})._init():a.data(this,c,new d(e,this))}),h)}},a.Widget=function(a,b){arguments.length&&this._createWidget(a,b)},a.Widget.prototype={widgetName:"widget",widgetEventPrefix:"",options:{disabled:!1},_createWidget:function(b,c){a.data(c,this.widgetName,this),this.element=a(c),this.options=a.extend(!0,{},this.options,this._getCreateOptions(),b);var d=this;this.element.bind("remove."+this.widgetName,function(){d.destroy()}),this._create(),this._trigger("create"),this._init()},_getCreateOptions:function(){return a.metadata&&a.metadata.get(this.element[0])[this.widgetName]},_create:function(){},_init:function(){},destroy:function(){this.element.unbind("."+this.widgetName).removeData(this.widgetName),this.widget().unbind("."+this.widgetName).removeAttr("aria-disabled").removeClass(this.widgetBaseClass+"-disabled "+"ui-state-disabled")},widget:function(){return this.element},option:function(c,d){var e=c;if(arguments.length===0)return a.extend({},this.options);if(typeof c=="string"){if(d===b)return this.options[c];e={},e[c]=d}return this._setOptions(e),this},_setOptions:function(b){var c=this;return a.each(b,function(a,b){c._setOption(a,b)}),this},_setOption:function(a,b){return this.options[a]=b,a==="disabled"&&this.widget()[b?"addClass":"removeClass"](this.widgetBaseClass+"-disabled"+" "+"ui-state-disabled").attr("aria-disabled",b),this},enable:function(){return this._setOption("disabled",!1)},disable:function(){return this._setOption("disabled",!0)},_trigger:function(b,c,d){var e,f,g=this.options[b];d=d||{},c=a.Event(c),c.type=(b===this.widgetEventPrefix?b:this.widgetEventPrefix+b).toLowerCase(),c.target=this.element[0],f=c.originalEvent;if(f)for(e in f)e in c||(c[e]=f[e]);return this.element.trigger(c,d),!(a.isFunction(g)&&g.call(this.element[0],c,d)===!1||c.isDefaultPrevented())}}}(jQuery),function(a,b){var c=!1;a(document).mouseup(function(a){c=!1}),a.widget("ui.mouse",{options:{cancel:":input,option",distance:1,delay:0},_mouseInit:function(){var b=this;this.element.bind("mousedown."+this.widgetName,function(a){return b._mouseDown(a)}).bind("click."+this.widgetName,function(c){if(!0===a.data(c.target,b.widgetName+".preventClickEvent"))return a.removeData(c.target,b.widgetName+".preventClickEvent"),c.stopImmediatePropagation(),!1}),this.started=!1},_mouseDestroy:function(){this.element.unbind("."+this.widgetName),a(document).unbind("mousemove."+this.widgetName,this._mouseMoveDelegate).unbind("mouseup."+this.widgetName,this._mouseUpDelegate)},_mouseDown:function(b){if(c)return;this._mouseStarted&&this._mouseUp(b),this._mouseDownEvent=b;var d=this,e=b.which==1,f=typeof this.options.cancel=="string"&&b.target.nodeName?a(b.target).closest(this.options.cancel).length:!1;if(!e||f||!this._mouseCapture(b))return!0;this.mouseDelayMet=!this.options.delay,this.mouseDelayMet||(this._mouseDelayTimer=setTimeout(function(){d.mouseDelayMet=!0},this.options.delay));if(this._mouseDistanceMet(b)&&this._mouseDelayMet(b)){this._mouseStarted=this._mouseStart(b)!==!1;if(!this._mouseStarted)return b.preventDefault(),!0}return!0===a.data(b.target,this.widgetName+".preventClickEvent")&&a.removeData(b.target,this.widgetName+".preventClickEvent"),this._mouseMoveDelegate=function(a){return d._mouseMove(a)},this._mouseUpDelegate=function(a){return d._mouseUp(a)},a(document).bind("mousemove."+this.widgetName,this._mouseMoveDelegate).bind("mouseup."+this.widgetName,this._mouseUpDelegate),b.preventDefault(),c=!0,!0},_mouseMove:function(b){return!a.browser.msie||document.documentMode>=9||!!b.button?this._mouseStarted?(this._mouseDrag(b),b.preventDefault()):(this._mouseDistanceMet(b)&&this._mouseDelayMet(b)&&(this._mouseStarted=this._mouseStart(this._mouseDownEvent,b)!==!1,this._mouseStarted?this._mouseDrag(b):this._mouseUp(b)),!this._mouseStarted):this._mouseUp(b)},_mouseUp:function(b){return a(document).unbind("mousemove."+this.widgetName,this._mouseMoveDelegate).unbind("mouseup."+this.widgetName,this._mouseUpDelegate),this._mouseStarted&&(this._mouseStarted=!1,b.target==this._mouseDownEvent.target&&a.data(b.target,this.widgetName+".preventClickEvent",!0),this._mouseStop(b)),!1},_mouseDistanceMet:function(a){return Math.max(Math.abs(this._mouseDownEvent.pageX-a.pageX),Math.abs(this._mouseDownEvent.pageY-a.pageY))>=this.options.distance},_mouseDelayMet:function(a){return this.mouseDelayMet},_mouseStart:function(a){},_mouseDrag:function(a){},_mouseStop:function(a){},_mouseCapture:function(a){return!0}})}(jQuery),function(a,b){a.widget("ui.draggable",a.ui.mouse,{widgetEventPrefix:"drag",options:{addClasses:!0,appendTo:"parent",axis:!1,connectToSortable:!1,containment:!1,cursor:"auto",cursorAt:!1,grid:!1,handle:!1,helper:"original",iframeFix:!1,opacity:!1,refreshPositions:!1,revert:!1,revertDuration:500,scope:"default",scroll:!0,scrollSensitivity:20,scrollSpeed:20,snap:!1,snapMode:"both",snapTolerance:20,stack:!1,zIndex:!1},_create:function(){this.options.helper=="original"&&!/^(?:r|a|f)/.test(this.element.css("position"))&&(this.element[0].style.position="relative"),this.options.addClasses&&this.element.addClass("ui-draggable"),this.options.disabled&&this.element.addClass("ui-draggable-disabled"),this._mouseInit()},destroy:function(){if(!this.element.data("draggable"))return;return this.element.removeData("draggable").unbind(".draggable").removeClass("ui-draggable ui-draggable-dragging ui-draggable-disabled"),this._mouseDestroy(),this},_mouseCapture:function(b){var c=this.options;return this.helper||c.disabled||a(b.target).is(".ui-resizable-handle")?!1:(this.handle=this._getHandle(b),this.handle?(c.iframeFix&&a(c.iframeFix===!0?"iframe":c.iframeFix).each(function(){a('<div class="ui-draggable-iframeFix" style="background: #fff;"></div>').css({width:this.offsetWidth+"px",height:this.offsetHeight+"px",position:"absolute",opacity:"0.001",zIndex:1e3}).css(a(this).offset()).appendTo("body")}),!0):!1)},_mouseStart:function(b){var c=this.options;return this.helper=this._createHelper(b),this.helper.addClass("ui-draggable-dragging"),this._cacheHelperProportions(),a.ui.ddmanager&&(a.ui.ddmanager.current=this),this._cacheMargins(),this.cssPosition=this.helper.css("position"),this.scrollParent=this.helper.scrollParent(),this.offset=this.positionAbs=this.element.offset(),this.offset={top:this.offset.top-this.margins.top,left:this.offset.left-this.margins.left},a.extend(this.offset,{click:{left:b.pageX-this.offset.left,top:b.pageY-this.offset.top},parent:this._getParentOffset(),relative:this._getRelativeOffset()}),this.originalPosition=this.position=this._generatePosition(b),this.originalPageX=b.pageX,this.originalPageY=b.pageY,c.cursorAt&&this._adjustOffsetFromHelper(c.cursorAt),c.containment&&this._setContainment(),this._trigger("start",b)===!1?(this._clear(),!1):(this._cacheHelperProportions(),a.ui.ddmanager&&!c.dropBehaviour&&a.ui.ddmanager.prepareOffsets(this,b),this._mouseDrag(b,!0),a.ui.ddmanager&&a.ui.ddmanager.dragStart(this,b),!0)},_mouseDrag:function(b,c){this.position=this._generatePosition(b),this.positionAbs=this._convertPositionTo("absolute");if(!c){var d=this._uiHash();if(this._trigger("drag",b,d)===!1)return this._mouseUp({}),!1;this.position=d.position}if(!this.options.axis||this.options.axis!="y")this.helper[0].style.left=this.position.left+"px";if(!this.options.axis||this.options.axis!="x")this.helper[0].style.top=this.position.top+"px";return a.ui.ddmanager&&a.ui.ddmanager.drag(this,b),!1},_mouseStop:function(b){var c=!1;a.ui.ddmanager&&!this.options.dropBehaviour&&(c=a.ui.ddmanager.drop(this,b)),this.dropped&&(c=this.dropped,this.dropped=!1);var d=this.element[0],e=!1;while(d&&(d=d.parentNode))d==document&&(e=!0);if(!e&&this.options.helper==="original")return!1;if(this.options.revert=="invalid"&&!c||this.options.revert=="valid"&&c||this.options.revert===!0||a.isFunction(this.options.revert)&&this.options.revert.call(this.element,c)){var f=this;a(this.helper).animate(this.originalPosition,parseInt(this.options.revertDuration,10),function(){f._trigger("stop",b)!==!1&&f._clear()})}else this._trigger("stop",b)!==!1&&this._clear();return!1},_mouseUp:function(b){return this.options.iframeFix===!0&&a("div.ui-draggable-iframeFix").each(function(){this.parentNode.removeChild(this)}),a.ui.ddmanager&&a.ui.ddmanager.dragStop(this,b),a.ui.mouse.prototype._mouseUp.call(this,b)},cancel:function(){return this.helper.is(".ui-draggable-dragging")?this._mouseUp({}):this._clear(),this},_getHandle:function(b){var c=!this.options.handle||!a(this.options.handle,this.element).length?!0:!1;return a(this.options.handle,this.element).find("*").andSelf().each(function(){this==b.target&&(c=!0)}),c},_createHelper:function(b){var c=this.options,d=a.isFunction(c.helper)?a(c.helper.apply(this.element[0],[b])):c.helper=="clone"?this.element.clone().removeAttr("id"):this.element;return d.parents("body").length||d.appendTo(c.appendTo=="parent"?this.element[0].parentNode:c.appendTo),d[0]!=this.element[0]&&!/(fixed|absolute)/.test(d.css("position"))&&d.css("position","absolute"),d},_adjustOffsetFromHelper:function(b){typeof b=="string"&&(b=b.split(" ")),a.isArray(b)&&(b={left:+b[0],top:+b[1]||0}),"left"in b&&(this.offset.click.left=b.left+this.margins.left),"right"in b&&(this.offset.click.left=this.helperProportions.width-b.right+this.margins.left),"top"in b&&(this.offset.click.top=b.top+this.margins.top),"bottom"in b&&(this.offset.click.top=this.helperProportions.height-b.bottom+this.margins.top)},_getParentOffset:function(){this.offsetParent=this.helper.offsetParent();var b=this.offsetParent.offset();this.cssPosition=="absolute"&&this.scrollParent[0]!=document&&a.ui.contains(this.scrollParent[0],this.offsetParent[0])&&(b.left+=this.scrollParent.scrollLeft(),b.top+=this.scrollParent.scrollTop());if(this.offsetParent[0]==document.body||this.offsetParent[0].tagName&&this.offsetParent[0].tagName.toLowerCase()=="html"&&a.browser.msie)b={top:0,left:0};return{top:b.top+(parseInt(this.offsetParent.css("borderTopWidth"),10)||0),left:b.left+(parseInt(this.offsetParent.css("borderLeftWidth"),10)||0)}},_getRelativeOffset:function(){if(this.cssPosition=="relative"){var a=this.element.position();return{top:a.top-(parseInt(this.helper.css("top"),10)||0)+this.scrollParent.scrollTop(),left:a.left-(parseInt(this.helper.css("left"),10)||0)+this.scrollParent.scrollLeft()}}return{top:0,left:0}},_cacheMargins:function(){this.margins={left:parseInt(this.element.css("marginLeft"),10)||0,top:parseInt(this.element.css("marginTop"),10)||0,right:parseInt(this.element.css("marginRight"),10)||0,bottom:parseInt(this.element.css("marginBottom"),10)||0}},_cacheHelperProportions:function(){this.helperProportions={width:this.helper.outerWidth(),height:this.helper.outerHeight()}},_setContainment:function(){var b=this.options;b.containment=="parent"&&(b.containment=this.helper[0].parentNode);if(b.containment=="document"||b.containment=="window")this.containment=[b.containment=="document"?0:a(window).scrollLeft()-this.offset.relative.left-this.offset.parent.left,b.containment=="document"?0:a(window).scrollTop()-this.offset.relative.top-this.offset.parent.top,(b.containment=="document"?0:a(window).scrollLeft())+a(b.containment=="document"?document:window).width()-this.helperProportions.width-this.margins.left,(b.containment=="document"?0:a(window).scrollTop())+(a(b.containment=="document"?document:window).height()||document.body.parentNode.scrollHeight)-this.helperProportions.height-this.margins.top];if(!/^(document|window|parent)$/.test(b.containment)&&b.containment.constructor!=Array){var c=a(b.containment),d=c[0];if(!d)return;var e=c.offset(),f=a(d).css("overflow")!="hidden";this.containment=[(parseInt(a(d).css("borderLeftWidth"),10)||0)+(parseInt(a(d).css("paddingLeft"),10)||0),(parseInt(a(d).css("borderTopWidth"),10)||0)+(parseInt(a(d).css("paddingTop"),10)||0),(f?Math.max(d.scrollWidth,d.offsetWidth):d.offsetWidth)-(parseInt(a(d).css("borderLeftWidth"),10)||0)-(parseInt(a(d).css("paddingRight"),10)||0)-this.helperProportions.width-this.margins.left-this.margins.right,(f?Math.max(d.scrollHeight,d.offsetHeight):d.offsetHeight)-(parseInt(a(d).css("borderTopWidth"),10)||0)-(parseInt(a(d).css("paddingBottom"),10)||0)-this.helperProportions.height-this.margins.top-this.margins.bottom],this.relative_container=c}else b.containment.constructor==Array&&(this.containment=b.containment)},_convertPositionTo:function(b,c){c||(c=this.position);var d=b=="absolute"?1:-1,e=this.options,f=this.cssPosition=="absolute"&&(this.scrollParent[0]==document||!a.ui.contains(this.scrollParent[0],this.offsetParent[0]))?this.offsetParent:this.scrollParent,g=/(html|body)/i.test(f[0].tagName);return{top:c.top+this.offset.relative.top*d+this.offset.parent.top*d-(a.browser.safari&&a.browser.version<526&&this.cssPosition=="fixed"?0:(this.cssPosition=="fixed"?-this.scrollParent.scrollTop():g?0:f.scrollTop())*d),left:c.left+this.offset.relative.left*d+this.offset.parent.left*d-(a.browser.safari&&a.browser.version<526&&this.cssPosition=="fixed"?0:(this.cssPosition=="fixed"?-this.scrollParent.scrollLeft():g?0:f.scrollLeft())*d)}},_generatePosition:function(b){var c=this.options,d=this.cssPosition=="absolute"&&(this.scrollParent[0]==document||!a.ui.contains(this.scrollParent[0],this.offsetParent[0]))?this.offsetParent:this.scrollParent,e=/(html|body)/i.test(d[0].tagName),f=b.pageX,g=b.pageY;if(this.originalPosition){var h;if(this.containment){if(this.relative_container){var i=this.relative_container.offset();h=[this.containment[0]+i.left,this.containment[1]+i.top,this.containment[2]+i.left,this.containment[3]+i.top]}else h=this.containment;b.pageX-this.offset.click.left<h[0]&&(f=h[0]+this.offset.click.left),b.pageY-this.offset.click.top<h[1]&&(g=h[1]+this.offset.click.top),b.pageX-this.offset.click.left>h[2]&&(f=h[2]+this.offset.click.left),b.pageY-this.offset.click.top>h[3]&&(g=h[3]+this.offset.click.top)}if(c.grid){var j=c.grid[1]?this.originalPageY+Math.round((g-this.originalPageY)/c.grid[1])*c.grid[1]:this.originalPageY;g=h?j-this.offset.click.top<h[1]||j-this.offset.click.top>h[3]?j-this.offset.click.top<h[1]?j+c.grid[1]:j-c.grid[1]:j:j;var k=c.grid[0]?this.originalPageX+Math.round((f-this.originalPageX)/c.grid[0])*c.grid[0]:this.originalPageX;f=h?k-this.offset.click.left<h[0]||k-this.offset.click.left>h[2]?k-this.offset.click.left<h[0]?k+c.grid[0]:k-c.grid[0]:k:k}}return{top:g-this.offset.click.top-this.offset.relative.top-this.offset.parent.top+(a.browser.safari&&a.browser.version<526&&this.cssPosition=="fixed"?0:this.cssPosition=="fixed"?-this.scrollParent.scrollTop():e?0:d.scrollTop()),left:f-this.offset.click.left-this.offset.relative.left-this.offset.parent.left+(a.browser.safari&&a.browser.version<526&&this.cssPosition=="fixed"?0:this.cssPosition=="fixed"?-this.scrollParent.scrollLeft():e?0:d.scrollLeft())}},_clear:function(){this.helper.removeClass("ui-draggable-dragging"),this.helper[0]!=this.element[0]&&!this.cancelHelperRemoval&&this.helper.remove(),this.helper=null,this.cancelHelperRemoval=!1},_trigger:function(b,c,d){return d=d||this._uiHash(),a.ui.plugin.call(this,b,[c,d]),b=="drag"&&(this.positionAbs=this._convertPositionTo("absolute")),a.Widget.prototype._trigger.call(this,b,c,d)},plugins:{},_uiHash:function(a){return{helper:this.helper,position:this.position,originalPosition:this.originalPosition,offset:this.positionAbs}}}),a.extend(a.ui.draggable,{version:"1.8.22"}),a.ui.plugin.add("draggable","connectToSortable",{start:function(b,c){var d=a(this).data("draggable"),e=d.options,f=a.extend({},c,{item:d.element});d.sortables=[],a(e.connectToSortable).each(function(){var c=a.data(this,"sortable");c&&!c.options.disabled&&(d.sortables.push({instance:c,shouldRevert:c.options.revert}),c.refreshPositions(),c._trigger("activate",b,f))})},stop:function(b,c){var d=a(this).data("draggable"),e=a.extend({},c,{item:d.element});a.each(d.sortables,function(){this.instance.isOver?(this.instance.isOver=0,d.cancelHelperRemoval=!0,this.instance.cancelHelperRemoval=!1,this.shouldRevert&&(this.instance.options.revert=!0),this.instance._mouseStop(b),this.instance.options.helper=this.instance.options._helper,d.options.helper=="original"&&this.instance.currentItem.css({top:"auto",left:"auto"})):(this.instance.cancelHelperRemoval=!1,this.instance._trigger("deactivate",b,e))})},drag:function(b,c){var d=a(this).data("draggable"),e=this,f=function(b){var c=this.offset.click.top,d=this.offset.click.left,e=this.positionAbs.top,f=this.positionAbs.left,g=b.height,h=b.width,i=b.top,j=b.left;return a.ui.isOver(e+c,f+d,i,j,g,h)};a.each(d.sortables,function(f){this.instance.positionAbs=d.positionAbs,this.instance.helperProportions=d.helperProportions,this.instance.offset.click=d.offset.click,this.instance._intersectsWith(this.instance.containerCache)?(this.instance.isOver||(this.instance.isOver=1,this.instance.currentItem=a(e).clone().removeAttr("id").appendTo(this.instance.element).data("sortable-item",!0),this.instance.options._helper=this.instance.options.helper,this.instance.options.helper=function(){return c.helper[0]},b.target=this.instance.currentItem[0],this.instance._mouseCapture(b,!0),this.instance._mouseStart(b,!0,!0),this.instance.offset.click.top=d.offset.click.top,this.instance.offset.click.left=d.offset.click.left,this.instance.offset.parent.left-=d.offset.parent.left-this.instance.offset.parent.left,this.instance.offset.parent.top-=d.offset.parent.top-this.instance.offset.parent.top,d._trigger("toSortable",b),d.dropped=this.instance.element,d.currentItem=d.element,this.instance.fromOutside=d),this.instance.currentItem&&this.instance._mouseDrag(b)):this.instance.isOver&&(this.instance.isOver=0,this.instance.cancelHelperRemoval=!0,this.instance.options.revert=!1,this.instance._trigger("out",b,this.instance._uiHash(this.instance)),this.instance._mouseStop(b,!0),this.instance.options.helper=this.instance.options._helper,this.instance.currentItem.remove(),this.instance.placeholder&&this.instance.placeholder.remove(),d._trigger("fromSortable",b),d.dropped=!1)})}}),a.ui.plugin.add("draggable","cursor",{start:function(b,c){var d=a("body"),e=a(this).data("draggable").options;d.css("cursor")&&(e._cursor=d.css("cursor")),d.css("cursor",e.cursor)},stop:function(b,c){var d=a(this).data("draggable").options;d._cursor&&a("body").css("cursor",d._cursor)}}),a.ui.plugin.add("draggable","opacity",{start:function(b,c){var d=a(c.helper),e=a(this).data("draggable").options;d.css("opacity")&&(e._opacity=d.css("opacity")),d.css("opacity",e.opacity)},stop:function(b,c){var d=a(this).data("draggable").options;d._opacity&&a(c.helper).css("opacity",d._opacity)}}),a.ui.plugin.add("draggable","scroll",{start:function(b,c){var d=a(this).data("draggable");d.scrollParent[0]!=document&&d.scrollParent[0].tagName!="HTML"&&(d.overflowOffset=d.scrollParent.offset())},drag:function(b,c){var d=a(this).data("draggable"),e=d.options,f=!1;if(d.scrollParent[0]!=document&&d.scrollParent[0].tagName!="HTML"){if(!e.axis||e.axis!="x")d.overflowOffset.top+d.scrollParent[0].offsetHeight-b.pageY<e.scrollSensitivity?d.scrollParent[0].scrollTop=f=d.scrollParent[0].scrollTop+e.scrollSpeed:b.pageY-d.overflowOffset.top<e.scrollSensitivity&&(d.scrollParent[0].scrollTop=f=d.scrollParent[0].scrollTop-e.scrollSpeed);if(!e.axis||e.axis!="y")d.overflowOffset.left+d.scrollParent[0].offsetWidth-b.pageX<e.scrollSensitivity?d.scrollParent[0].scrollLeft=f=d.scrollParent[0].scrollLeft+e.scrollSpeed:b.pageX-d.overflowOffset.left<e.scrollSensitivity&&(d.scrollParent[0].scrollLeft=f=d.scrollParent[0].scrollLeft-e.scrollSpeed)}else{if(!e.axis||e.axis!="x")b.pageY-a(document).scrollTop()<e.scrollSensitivity?f=a(document).scrollTop(a(document).scrollTop()-e.scrollSpeed):a(window).height()-(b.pageY-a(document).scrollTop())<e.scrollSensitivity&&(f=a(document).scrollTop(a(document).scrollTop()+e.scrollSpeed));if(!e.axis||e.axis!="y")b.pageX-a(document).scrollLeft()<e.scrollSensitivity?f=a(document).scrollLeft(a(document).scrollLeft()-e.scrollSpeed):a(window).width()-(b.pageX-a(document).scrollLeft())<e.scrollSensitivity&&(f=a(document).scrollLeft(a(document).scrollLeft()+e.scrollSpeed))}f!==!1&&a.ui.ddmanager&&!e.dropBehaviour&&a.ui.ddmanager.prepareOffsets(d,b)}}),a.ui.plugin.add("draggable","snap",{start:function(b,c){var d=a(this).data("draggable"),e=d.options;d.snapElements=[],a(e.snap.constructor!=String?e.snap.items||":data(draggable)":e.snap).each(function(){var b=a(this),c=b.offset();this!=d.element[0]&&d.snapElements.push({item:this,width:b.outerWidth(),height:b.outerHeight(),top:c.top,left:c.left})})},drag:function(b,c){var d=a(this).data("draggable"),e=d.options,f=e.snapTolerance,g=c.offset.left,h=g+d.helperProportions.width,i=c.offset.top,j=i+d.helperProportions.height;for(var k=d.snapElements.length-1;k>=0;k--){var l=d.snapElements[k].left,m=l+d.snapElements[k].width,n=d.snapElements[k].top,o=n+d.snapElements[k].height;if(!(l-f<g&&g<m+f&&n-f<i&&i<o+f||l-f<g&&g<m+f&&n-f<j&&j<o+f||l-f<h&&h<m+f&&n-f<i&&i<o+f||l-f<h&&h<m+f&&n-f<j&&j<o+f)){d.snapElements[k].snapping&&d.options.snap.release&&d.options.snap.release.call(d.element,b,a.extend(d._uiHash(),{snapItem:d.snapElements[k].item})),d.snapElements[k].snapping=!1;continue}if(e.snapMode!="inner"){var p=Math.abs(n-j)<=f,q=Math.abs(o-i)<=f,r=Math.abs(l-h)<=f,s=Math.abs(m-g)<=f;p&&(c.position.top=d._convertPositionTo("relative",{top:n-d.helperProportions.height,left:0}).top-d.margins.top),q&&(c.position.top=d._convertPositionTo("relative",{top:o,left:0}).top-d.margins.top),r&&(c.position.left=d._convertPositionTo("relative",{top:0,left:l-d.helperProportions.width}).left-d.margins.left),s&&(c.position.left=d._convertPositionTo("relative",{top:0,left:m}).left-d.margins.left)}var t=p||q||r||s;if(e.snapMode!="outer"){var p=Math.abs(n-i)<=f,q=Math.abs(o-j)<=f,r=Math.abs(l-g)<=f,s=Math.abs(m-h)<=f;p&&(c.position.top=d._convertPositionTo("relative",{top:n,left:0}).top-d.margins.top),q&&(c.position.top=d._convertPositionTo("relative",{top:o-d.helperProportions.height,left:0}).top-d.margins.top),r&&(c.position.left=d._convertPositionTo("relative",{top:0,left:l}).left-d.margins.left),s&&(c.position.left=d._convertPositionTo("relative",{top:0,left:m-d.helperProportions.width}).left-d.margins.left)}!d.snapElements[k].snapping&&(p||q||r||s||t)&&d.options.snap.snap&&d.options.snap.snap.call(d.element,b,a.extend(d._uiHash(),{snapItem:d.snapElements[k].item})),d.snapElements[k].snapping=p||q||r||s||t}}}),a.ui.plugin.add("draggable","stack",{start:function(b,c){var d=a(this).data("draggable").options,e=a.makeArray(a(d.stack)).sort(function(b,c){return(parseInt(a(b).css("zIndex"),10)||0)-(parseInt(a(c).css("zIndex"),10)||0)});if(!e.length)return;var f=parseInt(e[0].style.zIndex)||0;a(e).each(function(a){this.style.zIndex=f+a}),this[0].style.zIndex=f+e.length}}),a.ui.plugin.add("draggable","zIndex",{start:function(b,c){var d=a(c.helper),e=a(this).data("draggable").options;d.css("zIndex")&&(e._zIndex=d.css("zIndex")),d.css("zIndex",e.zIndex)},stop:function(b,c){var d=a(this).data("draggable").options;d._zIndex&&a(c.helper).css("zIndex",d._zIndex)}})}(jQuery),function(a,b){a.widget("ui.droppable",{widgetEventPrefix:"drop",options:{accept:"*",activeClass:!1,addClasses:!0,greedy:!1,hoverClass:!1,scope:"default",tolerance:"intersect"},_create:function(){var b=this.options,c=b.accept;this.isover=0,this.isout=1,this.accept=a.isFunction(c)?c:function(a){return a.is(c)},this.proportions={width:this.element[0].offsetWidth,height:this.element[0].offsetHeight},a.ui.ddmanager.droppables[b.scope]=a.ui.ddmanager.droppables[b.scope]||[],a.ui.ddmanager.droppables[b.scope].push(this),b.addClasses&&this.element.addClass("ui-droppable")},destroy:function(){var b=a.ui.ddmanager.droppables[this.options.scope];for(var c=0;c<b.length;c++)b[c]==this&&b.splice(c,1);return this.element.removeClass("ui-droppable ui-droppable-disabled").removeData("droppable").unbind(".droppable"),this},_setOption:function(b,c){b=="accept"&&(this.accept=a.isFunction(c)?c:function(a){return a.is(c)}),a.Widget.prototype._setOption.apply(this,arguments)},_activate:function(b){var c=a.ui.ddmanager.current;this.options.activeClass&&this.element.addClass(this.options.activeClass),c&&this._trigger("activate",b,this.ui(c))},_deactivate:function(b){var c=a.ui.ddmanager.current;this.options.activeClass&&this.element.removeClass(this.options.activeClass),c&&this._trigger("deactivate",b,this.ui(c))},_over:function(b){var c=a.ui.ddmanager.current;if(!c||(c.currentItem||c.element)[0]==this.element[0])return;this.accept.call(this.element[0],c.currentItem||c.element)&&(this.options.hoverClass&&this.element.addClass(this.options.hoverClass),this._trigger("over",b,this.ui(c)))},_out:function(b){var c=a.ui.ddmanager.current;if(!c||(c.currentItem||c.element)[0]==this.element[0])return;this.accept.call(this.element[0],c.currentItem||c.element)&&(this.options.hoverClass&&this.element.removeClass(this.options.hoverClass),this._trigger("out",b,this.ui(c)))},_drop:function(b,c){var d=c||a.ui.ddmanager.current;if(!d||(d.currentItem||d.element)[0]==this.element[0])return!1;var e=!1;return this.element.find(":data(droppable)").not(".ui-draggable-dragging").each(function(){var b=a.data(this,"droppable");if(b.options.greedy&&!b.options.disabled&&b.options.scope==d.options.scope&&b.accept.call(b.element[0],d.currentItem||d.element)&&a.ui.intersect(d,a.extend(b,{offset:b.element.offset()}),b.options.tolerance))return e=!0,!1}),e?!1:this.accept.call(this.element[0],d.currentItem||d.element)?(this.options.activeClass&&this.element.removeClass(this.options.activeClass),this.options.hoverClass&&this.element.removeClass(this.options.hoverClass),this._trigger("drop",b,this.ui(d)),this.element):!1},ui:function(a){return{draggable:a.currentItem||a.element,helper:a.helper,position:a.position,offset:a.positionAbs}}}),a.extend(a.ui.droppable,{version:"1.8.22"}),a.ui.intersect=function(b,c,d){if(!c.offset)return!1;var e=(b.positionAbs||b.position.absolute).left,f=e+b.helperProportions.width,g=(b.positionAbs||b.position.absolute).top,h=g+b.helperProportions.height,i=c.offset.left,j=i+c.proportions.width,k=c.offset.top,l=k+c.proportions.height;switch(d){case"fit":return i<=e&&f<=j&&k<=g&&h<=l;case"intersect":return i<e+b.helperProportions.width/2&&f-b.helperProportions.width/2<j&&k<g+b.helperProportions.height/2&&h-b.helperProportions.height/2<l;case"pointer":var m=(b.positionAbs||b.position.absolute).left+(b.clickOffset||b.offset.click).left,n=(b.positionAbs||b.position.absolute).top+(b.clickOffset||b.offset.click).top,o=a.ui.isOver(n,m,k,i,c.proportions.height,c.proportions.width);return o;case"touch":return(g>=k&&g<=l||h>=k&&h<=l||g<k&&h>l)&&(e>=i&&e<=j||f>=i&&f<=j||e<i&&f>j);default:return!1}},a.ui.ddmanager={current:null,droppables:{"default":[]},prepareOffsets:function(b,c){var d=a.ui.ddmanager.droppables[b.options.scope]||[],e=c?c.type:null,f=(b.currentItem||b.element).find(":data(droppable)").andSelf();g:for(var h=0;h<d.length;h++){if(d[h].options.disabled||b&&!d[h].accept.call(d[h].element[0],b.currentItem||b.element))continue;for(var i=0;i<f.length;i++)if(f[i]==d[h].element[0]){d[h].proportions.height=0;continue g}d[h].visible=d[h].element.css("display")!="none";if(!d[h].visible)continue;e=="mousedown"&&d[h]._activate.call(d[h],c),d[h].offset=d[h].element.offset(),d[h].proportions={width:d[h].element[0].offsetWidth,height:d[h].element[0].offsetHeight}}},drop:function(b,c){var d=!1;return a.each(a.ui.ddmanager.droppables[b.options.scope]||[],function(){if(!this.options)return;!this.options.disabled&&this.visible&&a.ui.intersect(b,this,this.options.tolerance)&&(d=this._drop.call(this,c)||d),!this.options.disabled&&this.visible&&this.accept.call(this.element[0],b.currentItem||b.element)&&(this.isout=1,this.isover=0,this._deactivate.call(this,c))}),d},dragStart:function(b,c){b.element.parents(":not(body,html)").bind("scroll.droppable",function(){b.options.refreshPositions||a.ui.ddmanager.prepareOffsets(b,c)})},drag:function(b,c){b.options.refreshPositions&&a.ui.ddmanager.prepareOffsets(b,c),a.each(a.ui.ddmanager.droppables[b.options.scope]||[],function(){if(this.options.disabled||this.greedyChild||!this.visible)return;var d=a.ui.intersect(b,this,this.options.tolerance),e=!d&&this.isover==1?"isout":d&&this.isover==0?"isover":null;if(!e)return;var f;if(this.options.greedy){var g=this.element.parents(":data(droppable):eq(0)");g.length&&(f=a.data(g[0],"droppable"),f.greedyChild=e=="isover"?1:0)}f&&e=="isover"&&(f.isover=0,f.isout=1,f._out.call(f,c)),this[e]=1,this[e=="isout"?"isover":"isout"]=0,this[e=="isover"?"_over":"_out"].call(this,c),f&&e=="isout"&&(f.isout=0,f.isover=1,f._over.call(f,c))})},dragStop:function(b,c){b.element.parents(":not(body,html)").unbind("scroll.droppable"),b.options.refreshPositions||a.ui.ddmanager.prepareOffsets(b,c)}}}(jQuery),function(a,b){a.widget("ui.resizable",a.ui.mouse,{widgetEventPrefix:"resize",options:{alsoResize:!1,animate:!1,animateDuration:"slow",animateEasing:"swing",aspectRatio:!1,autoHide:!1,containment:!1,ghost:!1,grid:!1,handles:"e,s,se",helper:!1,maxHeight:null,maxWidth:null,minHeight:10,minWidth:10,zIndex:1e3},_create:function(){var b=this,c=this.options;this.element.addClass("ui-resizable"),a.extend(this,{_aspectRatio:!!c.aspectRatio,aspectRatio:c.aspectRatio,originalElement:this.element,_proportionallyResizeElements:[],_helper:c.helper||c.ghost||c.animate?c.helper||"ui-resizable-helper":null}),this.element[0].nodeName.match(/canvas|textarea|input|select|button|img/i)&&(this.element.wrap(a('<div class="ui-wrapper" style="overflow: hidden;"></div>').css({position:this.element.css("position"),width:this.element.outerWidth(),height:this.element.outerHeight(),top:this.element.css("top"),left:this.element.css("left")})),this.element=this.element.parent().data("resizable",this.element.data("resizable")),this.elementIsWrapper=!0,this.element.css({marginLeft:this.originalElement.css("marginLeft"),marginTop:this.originalElement.css("marginTop"),marginRight:this.originalElement.css("marginRight"),marginBottom:this.originalElement.css("marginBottom")}),this.originalElement.css({marginLeft:0,marginTop:0,marginRight:0,marginBottom:0}),this.originalResizeStyle=this.originalElement.css("resize"),this.originalElement.css("resize","none"),this._proportionallyResizeElements.push(this.originalElement.css({position:"static",zoom:1,display:"block"})),this.originalElement.css({margin:this.originalElement.css("margin")}),this._proportionallyResize()),this.handles=c.handles||(a(".ui-resizable-handle",this.element).length?{n:".ui-resizable-n",e:".ui-resizable-e",s:".ui-resizable-s",w:".ui-resizable-w",se:".ui-resizable-se",sw:".ui-resizable-sw",ne:".ui-resizable-ne",nw:".ui-resizable-nw"}:"e,s,se");if(this.handles.constructor==String){this.handles=="all"&&(this.handles="n,e,s,w,se,sw,ne,nw");var d=this.handles.split(",");this.handles={};for(var e=0;e<d.length;e++){var f=a.trim(d[e]),g="ui-resizable-"+f,h=a('<div class="ui-resizable-handle '+g+'"></div>');h.css({zIndex:c.zIndex}),"se"==f&&h.addClass("ui-icon ui-icon-gripsmall-diagonal-se"),this.handles[f]=".ui-resizable-"+f,this.element.append(h)}}this._renderAxis=function(b){b=b||this.element;for(var c in this.handles){this.handles[c].constructor==String&&(this.handles[c]=a(this.handles[c],this.element).show());if(this.elementIsWrapper&&this.originalElement[0].nodeName.match(/textarea|input|select|button/i)){var d=a(this.handles[c],this.element),e=0;e=/sw|ne|nw|se|n|s/.test(c)?d.outerHeight():d.outerWidth();var f=["padding",/ne|nw|n/.test(c)?"Top":/se|sw|s/.test(c)?"Bottom":/^e$/.test(c)?"Right":"Left"].join("");b.css(f,e),this._proportionallyResize()}if(!a(this.handles[c]).length)continue}},this._renderAxis(this.element),this._handles=a(".ui-resizable-handle",this.element).disableSelection(),this._handles.mouseover(function(){if(!b.resizing){if(this.className)var a=this.className.match(/ui-resizable-(se|sw|ne|nw|n|e|s|w)/i);b.axis=a&&a[1]?a[1]:"se"}}),c.autoHide&&(this._handles.hide(),a(this.element).addClass("ui-resizable-autohide").hover(function(){if(c.disabled)return;a(this).removeClass("ui-resizable-autohide"),b._handles.show()},function(){if(c.disabled)return;b.resizing||(a(this).addClass("ui-resizable-autohide"),b._handles.hide())})),this._mouseInit()},destroy:function(){this._mouseDestroy();var b=function(b){a(b).removeClass("ui-resizable ui-resizable-disabled ui-resizable-resizing").removeData("resizable").unbind(".resizable").find(".ui-resizable-handle").remove()};if(this.elementIsWrapper){b(this.element);var c=this.element;c.after(this.originalElement.css({position:c.css("position"),width:c.outerWidth(),height:c.outerHeight(),top:c.css("top"),left:c.css("left")})).remove()}return this.originalElement.css("resize",this.originalResizeStyle),b(this.originalElement),this},_mouseCapture:function(b){var c=!1;for(var d in this.handles)a(this.handles[d])[0]==b.target&&(c=!0);return!this.options.disabled&&c},_mouseStart:function(b){var d=this.options,e=this.element.position(),f=this.element;this.resizing=!0,this.documentScroll={top:a(document).scrollTop(),left:a(document).scrollLeft()},(f.is(".ui-draggable")||/absolute/.test(f.css("position")))&&f.css({position:"absolute",top:e.top,left:e.left}),this._renderProxy();var g=c(this.helper.css("left")),h=c(this.helper.css("top"));d.containment&&(g+=a(d.containment).scrollLeft()||0,h+=a(d.containment).scrollTop()||0),this.offset=this.helper.offset(),this.position={left:g,top:h},this.size=this._helper?{width:f.outerWidth(),height:f.outerHeight()}:{width:f.width(),height:f.height()},this.originalSize=this._helper?{width:f.outerWidth(),height:f.outerHeight()}:{width:f.width(),height:f.height()},this.originalPosition={left:g,top:h},this.sizeDiff={width:f.outerWidth()-f.width(),height:f.outerHeight()-f.height()},this.originalMousePosition={left:b.pageX,top:b.pageY},this.aspectRatio=typeof d.aspectRatio=="number"?d.aspectRatio:this.originalSize.width/this.originalSize.height||1;var i=a(".ui-resizable-"+this.axis).css("cursor");return a("body").css("cursor",i=="auto"?this.axis+"-resize":i),f.addClass("ui-resizable-resizing"),this._propagate("start",b),!0},_mouseDrag:function(b){var c=this.helper,d=this.options,e={},f=this,g=this.originalMousePosition,h=this.axis,i=b.pageX-g.left||0,j=b.pageY-g.top||0,k=this._change[h];if(!k)return!1;var l=k.apply(this,[b,i,j]),m=a.browser.msie&&a.browser.version<7,n=this.sizeDiff;this._updateVirtualBoundaries(b.shiftKey);if(this._aspectRatio||b.shiftKey)l=this._updateRatio(l,b);return l=this._respectSize(l,b),this._propagate("resize",b),c.css({top:this.position.top+"px",left:this.position.left+"px",width:this.size.width+"px",height:this.size.height+"px"}),!this._helper&&this._proportionallyResizeElements.length&&this._proportionallyResize(),this._updateCache(l),this._trigger("resize",b,this.ui()),!1},_mouseStop:function(b){this.resizing=!1;var c=this.options,d=this;if(this._helper){var e=this._proportionallyResizeElements,f=e.length&&/textarea/i.test(e[0].nodeName),g=f&&a.ui.hasScroll(e[0],"left")?0:d.sizeDiff.height,h=f?0:d.sizeDiff.width,i={width:d.helper.width()-h,height:d.helper.height()-g},j=parseInt(d.element.css("left"),10)+(d.position.left-d.originalPosition.left)||null,k=parseInt(d.element.css("top"),10)+(d.position.top-d.originalPosition.top)||null;c.animate||this.element.css(a.extend(i,{top:k,left:j})),d.helper.height(d.size.height),d.helper.width(d.size.width),this._helper&&!c.animate&&this._proportionallyResize()}return a("body").css("cursor","auto"),this.element.removeClass("ui-resizable-resizing"),this._propagate("stop",b),this._helper&&this.helper.remove(),!1},_updateVirtualBoundaries:function(a){var b=this.options,c,e,f,g,h;h={minWidth:d(b.minWidth)?b.minWidth:0,maxWidth:d(b.maxWidth)?b.maxWidth:Infinity,minHeight:d(b.minHeight)?b.minHeight:0,maxHeight:d(b.maxHeight)?b.maxHeight:Infinity};if(this._aspectRatio||a)c=h.minHeight*this.aspectRatio,f=h.minWidth/this.aspectRatio,e=h.maxHeight*this.aspectRatio,g=h.maxWidth/this.aspectRatio,c>h.minWidth&&(h.minWidth=c),f>h.minHeight&&(h.minHeight=f),e<h.maxWidth&&(h.maxWidth=e),g<h.maxHeight&&(h.maxHeight=g);this._vBoundaries=h},_updateCache:function(a){var b=this.options;this.offset=this.helper.offset(),d(a.left)&&(this.position.left=a.left),d(a.top)&&(this.position.top=a.top),d(a.height)&&(this.size.height=a.height),d(a.width)&&(this.size.width=a.width)},_updateRatio:function(a,b){var c=this.options,e=this.position,f=this.size,g=this.axis;return d(a.height)?a.width=a.height*this.aspectRatio:d(a.width)&&(a.height=a.width/this.aspectRatio),g=="sw"&&(a.left=e.left+(f.width-a.width),a.top=null),g=="nw"&&(a.top=e.top+(f.height-a.height),a.left=e.left+(f.width-a.width)),a},_respectSize:function(a,b){var c=this.helper,e=this._vBoundaries,f=this._aspectRatio||b.shiftKey,g=this.axis,h=d(a.width)&&e.maxWidth&&e.maxWidth<a.width,i=d(a.height)&&e.maxHeight&&e.maxHeight<a.height,j=d(a.width)&&e.minWidth&&e.minWidth>a.width,k=d(a.height)&&e.minHeight&&e.minHeight>a.height;j&&(a.width=e.minWidth),k&&(a.height=e.minHeight),h&&(a.width=e.maxWidth),i&&(a.height=e.maxHeight);var l=this.originalPosition.left+this.originalSize.width,m=this.position.top+this.size.height,n=/sw|nw|w/.test(g),o=/nw|ne|n/.test(g);j&&n&&(a.left=l-e.minWidth),h&&n&&(a.left=l-e.maxWidth),k&&o&&(a.top=m-e.minHeight),i&&o&&(a.top=m-e.maxHeight);var p=!a.width&&!a.height;return p&&!a.left&&a.top?a.top=null:p&&!a.top&&a.left&&(a.left=null),a},_proportionallyResize:function(){var b=this.options;if(!this._proportionallyResizeElements.length)return;var c=this.helper||this.element;for(var d=0;d<this._proportionallyResizeElements.length;d++){var e=this._proportionallyResizeElements[d];if(!this.borderDif){var f=[e.css("borderTopWidth"),e.css("borderRightWidth"),e.css("borderBottomWidth"),e.css("borderLeftWidth")],g=[e.css("paddingTop"),e.css("paddingRight"),e.css("paddingBottom"),e.css("paddingLeft")];this.borderDif=a.map(f,function(a,b){var c=parseInt(a,10)||0,d=parseInt(g[b],10)||0;return c+d})}if(!a.browser.msie||!a(c).is(":hidden")&&!a(c).parents(":hidden").length)e.css({height:c.height()-this.borderDif[0]-this.borderDif[2]||0,width:c.width()-this.borderDif[1]-this.borderDif[3]||0});else continue}},_renderProxy:function(){var b=this.element,c=this.options;this.elementOffset=b.offset();if(this._helper){this.helper=this.helper||a('<div style="overflow:hidden;"></div>');var d=a.browser.msie&&a.browser.version<7,e=d?1:0,f=d?2:-1;this.helper.addClass(this._helper).css({width:this.element.outerWidth()+f,height:this.element.outerHeight()+f,position:"absolute",left:this.elementOffset.left-e+"px",top:this.elementOffset.top-e+"px",zIndex:++c.zIndex}),this.helper.appendTo("body").disableSelection()}else this.helper=this.element},_change:{e:function(a,b,c){return{width:this.originalSize.width+b}},w:function(a,b,c){var d=this.options,e=this.originalSize,f=this.originalPosition;return{left:f.left+b,width:e.width-b}},n:function(a,b,c){var d=this.options,e=this.originalSize,f=this.originalPosition;return{top:f.top+c,height:e.height-c}},s:function(a,b,c){return{height:this.originalSize.height+c}},se:function(b,c,d){return a.extend(this._change.s.apply(this,arguments),this._change.e.apply(this,[b,c,d]))},sw:function(b,c,d){return a.extend(this._change.s.apply(this,arguments),this._change.w.apply(this,[b,c,d]))},ne:function(b,c,d){return a.extend(this._change.n.apply(this,arguments),this._change.e.apply(this,[b,c,d]))},nw:function(b,c,d){return a.extend(this._change.n.apply(this,arguments),this._change.w.apply(this,[b,c,d]))}},_propagate:function(b,c){a.ui.plugin.call(this,b,[c,this.ui()]),b!="resize"&&this._trigger(b,c,this.ui())},plugins:{},ui:function(){return{originalElement:this.originalElement,element:this.element,helper:this.helper,position:this.position,size:this.size,originalSize:this.originalSize,originalPosition:this.originalPosition}}}),a.extend(a.ui.resizable,{version:"1.8.22"}),a.ui.plugin.add("resizable","alsoResize",{start:function(b,c){var d=a(this).data("resizable"),e=d.options,f=function(b){a(b).each(function(){var b=a(this);b.data("resizable-alsoresize",{width:parseInt(b.width(),10),height:parseInt(b.height(),10),left:parseInt(b.css("left"),10),top:parseInt(b.css("top"),10)})})};typeof e.alsoResize=="object"&&!e.alsoResize.parentNode?e.alsoResize.length?(e.alsoResize=e.alsoResize[0],f(e.alsoResize)):a.each(e.alsoResize,function(a){f(a)}):f(e.alsoResize)},resize:function(b,c){var d=a(this).data("resizable"),e=d.options,f=d.originalSize,g=d.originalPosition,h={height:d.size.height-f.height||0,width:d.size.width-f.width||0,top:d.position.top-g.top||0,left:d.position.left-g.left||0},i=function(b,d){a(b).each(function(){var b=a(this),e=a(this).data("resizable-alsoresize"),f={},g=d&&d.length?d:b.parents(c.originalElement[0]).length?["width","height"]:["width","height","top","left"];a.each(g,function(a,b){var c=(e[b]||0)+(h[b]||0);c&&c>=0&&(f[b]=c||null)}),b.css(f)})};typeof e.alsoResize=="object"&&!e.alsoResize.nodeType?a.each(e.alsoResize,function(a,b){i(a,b)}):i(e.alsoResize)},stop:function(b,c){a(this).removeData("resizable-alsoresize")}}),a.ui.plugin.add("resizable","animate",{stop:function(b,c){var d=a(this).data("resizable"),e=d.options,f=d._proportionallyResizeElements,g=f.length&&/textarea/i.test(f[0].nodeName),h=g&&a.ui.hasScroll(f[0],"left")?0:d.sizeDiff.height,i=g?0:d.sizeDiff.width,j={width:d.size.width-i,height:d.size.height-h},k=parseInt(d.element.css("left"),10)+(d.position.left-d.originalPosition.left)||null,l=parseInt(d.element.css("top"),10)+(d.position.top-d.originalPosition.top)||null;d.element.animate(a.extend(j,l&&k?{top:l,left:k}:{}),{duration:e.animateDuration,easing:e.animateEasing,step:function(){var c={width:parseInt(d.element.css("width"),10),height:parseInt(d.element.css("height"),10),top:parseInt(d.element.css("top"),10),left:parseInt(d.element.css("left"),10)};f&&f.length&&a(f[0]).css({width:c.width,height:c.height}),d._updateCache(c),d._propagate("resize",b)}})}}),a.ui.plugin.add("resizable","containment",{start:function(b,d){var e=a(this).data("resizable"),f=e.options,g=e.element,h=f.containment,i=h instanceof a?h.get(0):/parent/.test(h)?g.parent().get(0):h;if(!i)return;e.containerElement=a(i);if(/document/.test(h)||h==document)e.containerOffset={left:0,top:0},e.containerPosition={left:0,top:0},e.parentData={element:a(document),left:0,top:0,width:a(document).width(),height:a(document).height()||document.body.parentNode.scrollHeight};else{var j=a(i),k=[];a(["Top","Right","Left","Bottom"]).each(function(a,b){k[a]=c(j.css("padding"+b))}),e.containerOffset=j.offset(),e.containerPosition=j.position(),e.containerSize={height:j.innerHeight()-k[3],width:j.innerWidth()-k[1]};var l=e.containerOffset,m=e.containerSize.height,n=e.containerSize.width,o=a.ui.hasScroll(i,"left")?i.scrollWidth:n,p=a.ui.hasScroll(i)?i.scrollHeight:m;e.parentData={element:i,left:l.left,top:l.top,width:o,height:p}}},resize:function(b,c){var d=a(this).data("resizable"),e=d.options,f=d.containerSize,g=d.containerOffset,h=d.size,i=d.position,j=d._aspectRatio||b.shiftKey,k={top:0,left:0},l=d.containerElement;l[0]!=document&&/static/.test(l.css("position"))&&(k=g),i.left<(d._helper?g.left:0)&&(d.size.width=d.size.width+(d._helper?d.position.left-g.left:d.position.left-k.left),j&&(d.size.height=d.size.width/d.aspectRatio),d.position.left=e.helper?g.left:0),i.top<(d._helper?g.top:0)&&(d.size.height=d.size.height+(d._helper?d.position.top-g.top:d.position.top),j&&(d.size.width=d.size.height*d.aspectRatio),d.position.top=d._helper?g.top:0),d.offset.left=d.parentData.left+d.position.left,d.offset.top=d.parentData.top+d.position.top;var m=Math.abs((d._helper?d.offset.left-k.left:d.offset.left-k.left)+d.sizeDiff.width),n=Math.abs((d._helper?d.offset.top-k.top:d.offset.top-g.top)+d.sizeDiff.height),o=d.containerElement.get(0)==d.element.parent().get(0),p=/relative|absolute/.test(d.containerElement.css("position"));o&&p&&(m-=d.parentData.left),m+d.size.width>=d.parentData.width&&(d.size.width=d.parentData.width-m,j&&(d.size.height=d.size.width/d.aspectRatio)),n+d.size.height>=d.parentData.height&&(d.size.height=d.parentData.height-n,j&&(d.size.width=d.size.height*d.aspectRatio))},stop:function(b,c){var d=a(this).data("resizable"),e=d.options,f=d.position,g=d.containerOffset,h=d.containerPosition,i=d.containerElement,j=a(d.helper),k=j.offset(),l=j.outerWidth()-d.sizeDiff.width,m=j.outerHeight()-d.sizeDiff.height;d._helper&&!e.animate&&/relative/.test(i.css("position"))&&a(this).css({left:k.left-h.left-g.left,width:l,height:m}),d._helper&&!e.animate&&/static/.test(i.css("position"))&&a(this).css({left:k.left-h.left-g.left,width:l,height:m})}}),a.ui.plugin.add("resizable","ghost",{start:function(b,c){var d=a(this).data("resizable"),e=d.options,f=d.size;d.ghost=d.originalElement.clone(),d.ghost.css({opacity:.25,display:"block",position:"relative",height:f.height,width:f.width,margin:0,left:0,top:0}).addClass("ui-resizable-ghost").addClass(typeof e.ghost=="string"?e.ghost:""),d.ghost.appendTo(d.helper)},resize:function(b,c){var d=a(this).data("resizable"),e=d.options;d.ghost&&d.ghost.css({position:"relative",height:d.size.height,width:d.size.width})},stop:function(b,c){var d=a(this).data("resizable"),e=d.options;d.ghost&&d.helper&&d.helper.get(0).removeChild(d.ghost.get(0))}}),a.ui.plugin.add("resizable","grid",{resize:function(b,c){var d=a(this).data("resizable"),e=d.options,f=d.size,g=d.originalSize,h=d.originalPosition,i=d.axis,j=e._aspectRatio||b.shiftKey;e.grid=typeof e.grid=="number"?[e.grid,e.grid]:e.grid;var k=Math.round((f.width-g.width)/(e.grid[0]||1))*(e.grid[0]||1),l=Math.round((f.height-g.height)/(e.grid[1]||1))*(e.grid[1]||1);/^(se|s|e)$/.test(i)?(d.size.width=g.width+k,d.size.height=g.height+l):/^(ne)$/.test(i)?(d.size.width=g.width+k,d.size.height=g.height+l,d.position.top=h.top-l):/^(sw)$/.test(i)?(d.size.width=g.width+k,d.size.height=g.height+l,d.position.left=h.left-k):(d.size.width=g.width+k,d.size.height=g.height+l,d.position.top=h.top-l,d.position.left=h.left-k)}});var c=function(a){return parseInt(a,10)||0},d=function(a){return!isNaN(parseInt(a,10))}}(jQuery),function(a,b){a.widget("ui.selectable",a.ui.mouse,{options:{appendTo:"body",autoRefresh:!0,distance:0,filter:"*",tolerance:"touch"},_create:function(){var b=this;this.element.addClass("ui-selectable"),this.dragged=!1;var c;this.refresh=function(){c=a(b.options.filter,b.element[0]),c.addClass("ui-selectee"),c.each(function(){var b=a(this),c=b.offset();a.data(this,"selectable-item",{element:this,$element:b,left:c.left,top:c.top,right:c.left+b.outerWidth(),bottom:c.top+b.outerHeight(),startselected:!1,selected:b.hasClass("ui-selected"),selecting:b.hasClass("ui-selecting"),unselecting:b.hasClass("ui-unselecting")})})},this.refresh(),this.selectees=c.addClass("ui-selectee"),this._mouseInit(),this.helper=a("<div class='ui-selectable-helper'></div>")},destroy:function(){return this.selectees.removeClass("ui-selectee").removeData("selectable-item"),this.element.removeClass("ui-selectable ui-selectable-disabled").removeData("selectable").unbind(".selectable"),this._mouseDestroy(),this},_mouseStart:function(b){var c=this;this.opos=[b.pageX,b.pageY];if(this.options.disabled)return;var d=this.options;this.selectees=a(d.filter,this.element[0]),this._trigger("start",b),a(d.appendTo).append(this.helper),this.helper.css({left:b.clientX,top:b.clientY,width:0,height:0}),d.autoRefresh&&this.refresh(),this.selectees.filter(".ui-selected").each(function(){var d=a.data(this,"selectable-item");d.startselected=!0,!b.metaKey&&!b.ctrlKey&&(d.$element.removeClass("ui-selected"),d.selected=!1,d.$element.addClass("ui-unselecting"),d.unselecting=!0,c._trigger("unselecting",b,{unselecting:d.element}))}),a(b.target).parents().andSelf().each(function(){var d=a.data(this,"selectable-item");if(d){var e=!b.metaKey&&!b.ctrlKey||!d.$element.hasClass("ui-selected");return d.$element.removeClass(e?"ui-unselecting":"ui-selected").addClass(e?"ui-selecting":"ui-unselecting"),d.unselecting=!e,d.selecting=e,d.selected=e,e?c._trigger("selecting",b,{selecting:d.element}):c._trigger("unselecting",b,{unselecting:d.element}),!1}})},_mouseDrag:function(b){var c=this;this.dragged=!0;if(this.options.disabled)return;var d=this.options,e=this.opos[0],f=this.opos[1],g=b.pageX,h=b.pageY;if(e>g){var i=g;g=e,e=i}if(f>h){var i=h;h=f,f=i}return this.helper.css({left:e,top:f,width:g-e,height:h-f}),this.selectees.each(function(){var i=a.data(this,"selectable-item");if(!i||i.element==c.element[0])return;var j=!1;d.tolerance=="touch"?j=!(i.left>g||i.right<e||i.top>h||i.bottom<f):d.tolerance=="fit"&&(j=i.left>e&&i.right<g&&i.top>f&&i.bottom<h),j?(i.selected&&(i.$element.removeClass("ui-selected"),i.selected=!1),i.unselecting&&(i.$element.removeClass("ui-unselecting"),i.unselecting=!1),i.selecting||(i.$element.addClass("ui-selecting"),i.selecting=!0,c._trigger("selecting",b,{selecting:i.element}))):(i.selecting&&((b.metaKey||b.ctrlKey)&&i.startselected?(i.$element.removeClass("ui-selecting"),i.selecting=!1,i.$element.addClass("ui-selected"),i.selected=!0):(i.$element.removeClass("ui-selecting"),i.selecting=!1,i.startselected&&(i.$element.addClass("ui-unselecting"),i.unselecting=!0),c._trigger("unselecting",b,{unselecting:i.element}))),i.selected&&!b.metaKey&&!b.ctrlKey&&!i.startselected&&(i.$element.removeClass("ui-selected"),i.selected=!1,i.$element.addClass("ui-unselecting"),i.unselecting=!0,c._trigger("unselecting",b,{unselecting:i.element})))}),!1},_mouseStop:function(b){var c=this;this.dragged=!1;var d=this.options;return a(".ui-unselecting",this.element[0]).each(function(){var d=a.data(this,"selectable-item");d.$element.removeClass("ui-unselecting"),d.unselecting=!1,d.startselected=!1,c._trigger("unselected",b,{unselected:d.element})}),a(".ui-selecting",this.element[0]).each(function(){var d=a.data(this,"selectable-item");d.$element.removeClass("ui-selecting").addClass("ui-selected"),d.selecting=!1,d.selected=!0,d.startselected=!0,c._trigger("selected",b,{selected:d.element})}),this._trigger("stop",b),this.helper.remove(),!1}}),a.extend(a.ui.selectable,{version:"1.8.22"})}(jQuery),function(a,b){a.widget("ui.sortable",a.ui.mouse,{widgetEventPrefix:"sort",ready:!1,options:{appendTo:"parent",axis:!1,connectWith:!1,containment:!1,cursor:"auto",cursorAt:!1,dropOnEmpty:!0,forcePlaceholderSize:!1,forceHelperSize:!1,grid:!1,handle:!1,helper:"original",items:"> *",opacity:!1,placeholder:!1,revert:!1,scroll:!0,scrollSensitivity:20,scrollSpeed:20,scope:"default",tolerance:"intersect",zIndex:1e3},_create:function(){var a=this.options;this.containerCache={},this.element.addClass("ui-sortable"),this.refresh(),this.floating=this.items.length?a.axis==="x"||/left|right/.test(this.items[0].item.css("float"))||/inline|table-cell/.test(this.items[0].item.css("display")):!1,this.offset=this.element.offset(),this._mouseInit(),this.ready=!0},destroy:function(){a.Widget.prototype.destroy.call(this),this.element.removeClass("ui-sortable ui-sortable-disabled"),this._mouseDestroy();for(var b=this.items.length-1;b>=0;b--)this.items[b].item.removeData(this.widgetName+"-item");return this},_setOption:function(b,c){b==="disabled"?(this.options[b]=c,this.widget()[c?"addClass":"removeClass"]("ui-sortable-disabled")):a.Widget.prototype._setOption.apply(this,arguments)},_mouseCapture:function(b,c){var d=this;if(this.reverting)return!1;if(this.options.disabled||this.options.type=="static")return!1;this._refreshItems(b);var e=null,f=this,g=a(b.target).parents().each(function(){if(a.data(this,d.widgetName+"-item")==f)return e=a(this),!1});a.data(b.target,d.widgetName+"-item")==f&&(e=a(b.target));if(!e)return!1;if(this.options.handle&&!c){var h=!1;a(this.options.handle,e).find("*").andSelf().each(function(){this==b.target&&(h=!0)});if(!h)return!1}return this.currentItem=e,this._removeCurrentsFromItems(),!0},_mouseStart:function(b,c,d){var e=this.options,f=this;this.currentContainer=this,this.refreshPositions(),this.helper=this._createHelper(b),this._cacheHelperProportions(),this._cacheMargins(),this.scrollParent=this.helper.scrollParent(),this.offset=this.currentItem.offset(),this.offset={top:this.offset.top-this.margins.top,left:this.offset.left-this.margins.left},a.extend(this.offset,{click:{left:b.pageX-this.offset.left,top:b.pageY-this.offset.top},parent:this._getParentOffset(),relative:this._getRelativeOffset()}),this.helper.css("position","absolute"),this.cssPosition=this.helper.css("position"),this.originalPosition=this._generatePosition(b),this.originalPageX=b.pageX,this.originalPageY=b.pageY,e.cursorAt&&this._adjustOffsetFromHelper(e.cursorAt),this.domPosition={prev:this.currentItem.prev()[0],parent:this.currentItem.parent()[0]},this.helper[0]!=this.currentItem[0]&&this.currentItem.hide(),this._createPlaceholder(),e.containment&&this._setContainment(),e.cursor&&(a("body").css("cursor")&&(this._storedCursor=a("body").css("cursor")),a("body").css("cursor",e.cursor)),e.opacity&&(this.helper.css("opacity")&&(this._storedOpacity=this.helper.css("opacity")),this.helper.css("opacity",e.opacity)),e.zIndex&&(this.helper.css("zIndex")&&(this._storedZIndex=this.helper.css("zIndex")),this.helper.css("zIndex",e.zIndex)),this.scrollParent[0]!=document&&this.scrollParent[0].tagName!="HTML"&&(this.overflowOffset=this.scrollParent.offset()),this._trigger("start",b,this._uiHash()),this._preserveHelperProportions||this._cacheHelperProportions();if(!d)for(var g=this.containers.length-1;g>=0;g--)this.containers[g]._trigger("activate",b,f._uiHash(this));return a.ui.ddmanager&&(a.ui.ddmanager.current=this),a.ui.ddmanager&&!e.dropBehaviour&&a.ui.ddmanager.prepareOffsets(this,b),this.dragging=!0,this.helper.addClass("ui-sortable-helper"),this._mouseDrag(b),!0},_mouseDrag:function(b){this.position=this._generatePosition(b),this.positionAbs=this._convertPositionTo("absolute"),this.lastPositionAbs||(this.lastPositionAbs=this.positionAbs);if(this.options.scroll){var c=this.options,d=!1;this.scrollParent[0]!=document&&this.scrollParent[0].tagName!="HTML"?(this.overflowOffset.top+this.scrollParent[0].offsetHeight-b.pageY<c.scrollSensitivity?this.scrollParent[0].scrollTop=d=this.scrollParent[0].scrollTop+c.scrollSpeed:b.pageY-this.overflowOffset.top<c.scrollSensitivity&&(this.scrollParent[0].scrollTop=d=this.scrollParent[0].scrollTop-c.scrollSpeed),this.overflowOffset.left+this.scrollParent[0].offsetWidth-b.pageX<c.scrollSensitivity?this.scrollParent[0].scrollLeft=d=this.scrollParent[0].scrollLeft+c.scrollSpeed:b.pageX-this.overflowOffset.left<c.scrollSensitivity&&(this.scrollParent[0].scrollLeft=d=this.scrollParent[0].scrollLeft-c.scrollSpeed)):(b.pageY-a(document).scrollTop()<c.scrollSensitivity?d=a(document).scrollTop(a(document).scrollTop()-c.scrollSpeed):a(window).height()-(b.pageY-a(document).scrollTop())<c.scrollSensitivity&&(d=a(document).scrollTop(a(document).scrollTop()+c.scrollSpeed)),b.pageX-a(document).scrollLeft()<c.scrollSensitivity?d=a(document).scrollLeft(a(document).scrollLeft()-c.scrollSpeed):a(window).width()-(b.pageX-a(document).scrollLeft())<c.scrollSensitivity&&(d=a(document).scrollLeft(a(document).scrollLeft()+c.scrollSpeed))),d!==!1&&a.ui.ddmanager&&!c.dropBehaviour&&a.ui.ddmanager.prepareOffsets(this,b)}this.positionAbs=this._convertPositionTo("absolute");if(!this.options.axis||this.options.axis!="y")this.helper[0].style.left=this.position.left+"px";if(!this.options.axis||this.options.axis!="x")this.helper[0].style.top=this.position.top+"px";for(var e=this.items.length-1;e>=0;e--){var f=this.items[e],g=f.item[0],h=this._intersectsWithPointer(f);if(!h)continue;if(g!=this.currentItem[0]&&this.placeholder[h==1?"next":"prev"]()[0]!=g&&!a.ui.contains(this.placeholder[0],g)&&(this.options.type=="semi-dynamic"?!a.ui.contains(this.element[0],g):!0)){this.direction=h==1?"down":"up";if(this.options.tolerance=="pointer"||this._intersectsWithSides(f))this._rearrange(b,f);else break;this._trigger("change",b,this._uiHash());break}}return this._contactContainers(b),a.ui.ddmanager&&a.ui.ddmanager.drag(this,b),this._trigger("sort",b,this._uiHash()),this.lastPositionAbs=this.positionAbs,!1},_mouseStop:function(b,c){if(!b)return;a.ui.ddmanager&&!this.options.dropBehaviour&&a.ui.ddmanager.drop(this,b);if(this.options.revert){var d=this,e=d.placeholder.offset();d.reverting=!0,a(this.helper).animate({left:e.left-this.offset.parent.left-d.margins.left+(this.offsetParent[0]==document.body?0:this.offsetParent[0].scrollLeft),top:e.top-this.offset.parent.top-d.margins.top+(this.offsetParent[0]==document.body?0:this.offsetParent[0].scrollTop)},parseInt(this.options.revert,10)||500,function(){d._clear(b)})}else this._clear(b,c);return!1},cancel:function(){var b=this;if(this.dragging){this._mouseUp({target:null}),this.options.helper=="original"?this.currentItem.css(this._storedCSS).removeClass("ui-sortable-helper"):this.currentItem.show();for(var c=this.containers.length-1;c>=0;c--)this.containers[c]._trigger("deactivate",null,b._uiHash(this)),this.containers[c].containerCache.over&&(this.containers[c]._trigger("out",null,b._uiHash(this)),this.containers[c].containerCache.over=0)}return this.placeholder&&(this.placeholder[0].parentNode&&this.placeholder[0].parentNode.removeChild(this.placeholder[0]),this.options.helper!="original"&&this.helper&&this.helper[0].parentNode&&this.helper.remove(),a.extend(this,{helper:null,dragging:!1,reverting:!1,_noFinalSort:null}),this.domPosition.prev?a(this.domPosition.prev).after(this.currentItem):a(this.domPosition.parent).prepend(this.currentItem)),this},serialize:function(b){var c=this._getItemsAsjQuery(b&&b.connected),d=[];return b=b||{},a(c).each(function(){var c=(a(b.item||this).attr(b.attribute||"id")||"").match(b.expression||/(.+)[-=_](.+)/);c&&d.push((b.key||c[1]+"[]")+"="+(b.key&&b.expression?c[1]:c[2]))}),!d.length&&b.key&&d.push(b.key+"="),d.join("&")},toArray:function(b){var c=this._getItemsAsjQuery(b&&b.connected),d=[];return b=b||{},c.each(function(){d.push(a(b.item||this).attr(b.attribute||"id")||"")}),d},_intersectsWith:function(a){var b=this.positionAbs.left,c=b+this.helperProportions.width,d=this.positionAbs.top,e=d+this.helperProportions.height,f=a.left,g=f+a.width,h=a.top,i=h+a.height,j=this.offset.click.top,k=this.offset.click.left,l=d+j>h&&d+j<i&&b+k>f&&b+k<g;return this.options.tolerance=="pointer"||this.options.forcePointerForContainers||this.options.tolerance!="pointer"&&this.helperProportions[this.floating?"width":"height"]>a[this.floating?"width":"height"]?l:f<b+this.helperProportions.width/2&&c-this.helperProportions.width/2<g&&h<d+this.helperProportions.height/2&&e-this.helperProportions.height/2<i},_intersectsWithPointer:function(b){var c=this.options.axis==="x"||a.ui.isOverAxis(this.positionAbs.top+this.offset.click.top,b.top,b.height),d=this.options.axis==="y"||a.ui.isOverAxis(this.positionAbs.left+this.offset.click.left,b.left,b.width),e=c&&d,f=this._getDragVerticalDirection(),g=this._getDragHorizontalDirection();return e?this.floating?g&&g=="right"||f=="down"?2:1:f&&(f=="down"?2:1):!1},_intersectsWithSides:function(b){var c=a.ui.isOverAxis(this.positionAbs.top+this.offset.click.top,b.top+b.height/2,b.height),d=a.ui.isOverAxis(this.positionAbs.left+this.offset.click.left,b.left+b.width/2,b.width),e=this._getDragVerticalDirection(),f=this._getDragHorizontalDirection();return this.floating&&f?f=="right"&&d||f=="left"&&!d:e&&(e=="down"&&c||e=="up"&&!c)},_getDragVerticalDirection:function(){var a=this.positionAbs.top-this.lastPositionAbs.top;return a!=0&&(a>0?"down":"up")},_getDragHorizontalDirection:function(){var a=this.positionAbs.left-this.lastPositionAbs.left;return a!=0&&(a>0?"right":"left")},refresh:function(a){return this._refreshItems(a),this.refreshPositions(),this},_connectWith:function(){var a=this.options;return a.connectWith.constructor==String?[a.connectWith]:a.connectWith},_getItemsAsjQuery:function(b){var c=this,d=[],e=[],f=this._connectWith();if(f&&b)for(var g=f.length-1;g>=0;g--){var h=a(f[g]);for(var i=h.length-1;i>=0;i--){var j=a.data(h[i],this.widgetName);j&&j!=this&&!j.options.disabled&&e.push([a.isFunction(j.options.items)?j.options.items.call(j.element):a(j.options.items,j.element).not(".ui-sortable-helper").not(".ui-sortable-placeholder"),j])}}e.push([a.isFunction(this.options.items)?this.options.items.call(this.element,null,{options:this.options,item:this.currentItem}):a(this.options.items,this.element).not(".ui-sortable-helper").not(".ui-sortable-placeholder"),this]);for(var g=e.length-1;g>=0;g--)e[g][0].each(function(){d.push(this)});return a(d)},_removeCurrentsFromItems:function(){var a=this.currentItem.find(":data("+this.widgetName+"-item)");for(var b=0;b<this.items.length;b++)for(var c=0;c<a.length;c++)a[c]==this.items[b].item[0]&&this.items.splice(b,1)},_refreshItems:function(b){this.items=[],this.containers=[this];var c=this.items,d=this,e=[[a.isFunction(this.options.items)?this.options.items.call(this.element[0],b,{item:this.currentItem}):a(this.options.items,this.element),this]],f=this._connectWith();if(f&&this.ready)for(var g=f.length-1;g>=0;g--){var h=a(f[g]);for(var i=h.length-1;i>=0;i--){var j=a.data(h[i],this.widgetName);j&&j!=this&&!j.options.disabled&&(e.push([a.isFunction(j.options.items)?j.options.items.call(j.element[0],b,{item:this.currentItem}):a(j.options.items,j.element),j]),this.containers.push(j))}}for(var g=e.length-1;g>=0;g--){var k=e[g][1],l=e[g][0];for(var i=0,m=l.length;i<m;i++){var n=a(l[i]);n.data(this.widgetName+"-item",k),c.push({item:n,instance:k,width:0,height:0,left:0,top:0})}}},refreshPositions:function(b){this.offsetParent&&this.helper&&(this.offset.parent=this._getParentOffset());for(var c=this.items.length-1;c>=0;c--){var d=this.items[c];if(d.instance!=this.currentContainer&&this.currentContainer&&d.item[0]!=this.currentItem[0])continue;var e=this.options.toleranceElement?a(this.options.toleranceElement,d.item):d.item;b||(d.width=e.outerWidth(),d.height=e.outerHeight());var f=e.offset();d.left=f.left,d.top=f.top}if(this.options.custom&&this.options.custom.refreshContainers)this.options.custom.refreshContainers.call(this);else for(var c=this.containers.length-1;c>=0;c--){var f=this.containers[c].element.offset();this.containers[c].containerCache.left=f.left,this.containers[c].containerCache.top=f.top,this.containers[c].containerCache.width=this.containers[c].element.outerWidth(),this.containers[c].containerCache.height=this.containers[c].element.outerHeight()}return this},_createPlaceholder:function(b){var c=b||this,d=c.options;if(!d.placeholder||d.placeholder.constructor==String){var e=d.placeholder;d.placeholder={element:function(){var b=a(document.createElement(c.currentItem[0].nodeName)).addClass(e||c.currentItem[0].className+" ui-sortable-placeholder").removeClass("ui-sortable-helper")[0];return e||(b.style.visibility="hidden"),b},update:function(a,b){if(e&&!d.forcePlaceholderSize)return;b.height()||b.height(c.currentItem.innerHeight()-parseInt(c.currentItem.css("paddingTop")||0,10)-parseInt(c.currentItem.css("paddingBottom")||0,10)),b.width()||b.width(c.currentItem.innerWidth()-parseInt(c.currentItem.css("paddingLeft")||0,10)-parseInt(c.currentItem.css("paddingRight")||0,10))}}}c.placeholder=a(d.placeholder.element.call(c.element,c.currentItem)),c.currentItem.after(c.placeholder),d.placeholder.update(c,c.placeholder)},_contactContainers:function(b){var c=null,d=null;for(var e=this.containers.length-1;e>=0;e--){if(a.ui.contains(this.currentItem[0],this.containers[e].element[0]))continue;if(this._intersectsWith(this.containers[e].containerCache)){if(c&&a.ui.contains(this.containers[e].element[0],c.element[0]))continue;c=this.containers[e],d=e}else this.containers[e].containerCache.over&&(this.containers[e]._trigger("out",b,this._uiHash(this)),this.containers[e].containerCache.over=0)}if(!c)return;if(this.containers.length===1)this.containers[d]._trigger("over",b,this._uiHash(this)),this.containers[d].containerCache.over=1;else if(this.currentContainer!=this.containers[d]){var f=1e4,g=null,h=this.positionAbs[this.containers[d].floating?"left":"top"];for(var i=this.items.length-1;i>=0;i--){if(!a.ui.contains(this.containers[d].element[0],this.items[i].item[0]))continue;var j=this.containers[d].floating?this.items[i].item.offset().left:this.items[i].item.offset().top;Math.abs(j-h)<f&&(f=Math.abs(j-h),g=this.items[i],this.direction=j-h>0?"down":"up")}if(!g&&!this.options.dropOnEmpty)return;this.currentContainer=this.containers[d],g?this._rearrange(b,g,null,!0):this._rearrange(b,null,this.containers[d].element,!0),this._trigger("change",b,this._uiHash()),this.containers[d]._trigger("change",b,this._uiHash(this)),this.options.placeholder.update(this.currentContainer,this.placeholder),this.containers[d]._trigger("over",b,this._uiHash(this)),this.containers[d].containerCache.over=1}},_createHelper:function(b){var c=this.options,d=a.isFunction(c.helper)?a(c.helper.apply(this.element[0],[b,this.currentItem])):c.helper=="clone"?this.currentItem.clone():this.currentItem;return d.parents("body").length||a(c.appendTo!="parent"?c.appendTo:this.currentItem[0].parentNode)[0].appendChild(d[0]),d[0]==this.currentItem[0]&&(this._storedCSS={width:this.currentItem[0].style.width,height:this.currentItem[0].style.height,position:this.currentItem.css("position"),top:this.currentItem.css("top"),left:this.currentItem.css("left")}),(d[0].style.width==""||c.forceHelperSize)&&d.width(this.currentItem.width()),(d[0].style.height==""||c.forceHelperSize)&&d.height(this.currentItem.height()),d},_adjustOffsetFromHelper:function(b){typeof b=="string"&&(b=b.split(" ")),a.isArray(b)&&(b={left:+b[0],top:+b[1]||0}),"left"in b&&(this.offset.click.left=b.left+this.margins.left),"right"in b&&(this.offset.click.left=this.helperProportions.width-b.right+this.margins.left),"top"in b&&(this.offset.click.top=b.top+this.margins.top),"bottom"in b&&(this.offset.click.top=this.helperProportions.height-b.bottom+this.margins.top)},_getParentOffset:function(){this.offsetParent=this.helper.offsetParent();var b=this.offsetParent.offset();this.cssPosition=="absolute"&&this.scrollParent[0]!=document&&a.ui.contains(this.scrollParent[0],this.offsetParent[0])&&(b.left+=this.scrollParent.scrollLeft(),b.top+=this.scrollParent.scrollTop());if(this.offsetParent[0]==document.body||this.offsetParent[0].tagName&&this.offsetParent[0].tagName.toLowerCase()=="html"&&a.browser.msie)b={top:0,left:0};return{top:b.top+(parseInt(this.offsetParent.css("borderTopWidth"),10)||0),left:b.left+(parseInt(this.offsetParent.css("borderLeftWidth"),10)||0)}},_getRelativeOffset:function(){if(this.cssPosition=="relative"){var a=this.currentItem.position();return{top:a.top-(parseInt(this.helper.css("top"),10)||0)+this.scrollParent.scrollTop(),left:a.left-(parseInt(this.helper.css("left"),10)||0)+this.scrollParent.scrollLeft()}}return{top:0,left:0}},_cacheMargins:function(){this.margins={left:parseInt(this.currentItem.css("marginLeft"),10)||0,top:parseInt(this.currentItem.css("marginTop"),10)||0}},_cacheHelperProportions:function(){this.helperProportions={width:this.helper.outerWidth(),height:this.helper.outerHeight()}},_setContainment:function(){var b=this.options;b.containment=="parent"&&(b.containment=this.helper[0].parentNode);if(b.containment=="document"||b.containment=="window")this.containment=[0-this.offset.relative.left-this.offset.parent.left,0-this.offset.relative.top-this.offset.parent.top,a(b.containment=="document"?document:window).width()-this.helperProportions.width-this.margins.left,(a(b.containment=="document"?document:window).height()||document.body.parentNode.scrollHeight)-this.helperProportions.height-this.margins.top];if(!/^(document|window|parent)$/.test(b.containment)){var c=a(b.containment)[0],d=a(b.containment).offset(),e=a(c).css("overflow")!="hidden";this.containment=[d.left+(parseInt(a(c).css("borderLeftWidth"),10)||0)+(parseInt(a(c).css("paddingLeft"),10)||0)-this.margins.left,d.top+(parseInt(a(c).css("borderTopWidth"),10)||0)+(parseInt(a(c).css("paddingTop"),10)||0)-this.margins.top,d.left+(e?Math.max(c.scrollWidth,c.offsetWidth):c.offsetWidth)-(parseInt(a(c).css("borderLeftWidth"),10)||0)-(parseInt(a(c).css("paddingRight"),10)||0)-this.helperProportions.width-this.margins.left,d.top+(e?Math.max(c.scrollHeight,c.offsetHeight):c.offsetHeight)-(parseInt(a(c).css("borderTopWidth"),10)||0)-(parseInt(a(c).css("paddingBottom"),10)||0)-this.helperProportions.height-this.margins.top]}},_convertPositionTo:function(b,c){c||(c=this.position);var d=b=="absolute"?1:-1,e=this.options,f=this.cssPosition=="absolute"&&(this.scrollParent[0]==document||!a.ui.contains(this.scrollParent[0],this.offsetParent[0]))?this.offsetParent:this.scrollParent,g=/(html|body)/i.test(f[0].tagName);return{top:c.top+this.offset.relative.top*d+this.offset.parent.top*d-(a.browser.safari&&this.cssPosition=="fixed"?0:(this.cssPosition=="fixed"?-this.scrollParent.scrollTop():g?0:f.scrollTop())*d),left:c.left+this.offset.relative.left*d+this.offset.parent.left*d-(a.browser.safari&&this.cssPosition=="fixed"?0:(this.cssPosition=="fixed"?-this.scrollParent.scrollLeft():g?0:f.scrollLeft())*d)}},_generatePosition:function(b){var c=this.options,d=this.cssPosition=="absolute"&&(this.scrollParent[0]==document||!a.ui.contains(this.scrollParent[0],this.offsetParent[0]))?this.offsetParent:this.scrollParent,e=/(html|body)/i.test(d[0].tagName);this.cssPosition=="relative"&&(this.scrollParent[0]==document||this.scrollParent[0]==this.offsetParent[0])&&(this.offset.relative=this._getRelativeOffset());var f=b.pageX,g=b.pageY;if(this.originalPosition){this.containment&&(b.pageX-this.offset.click.left<this.containment[0]&&(f=this.containment[0]+this.offset.click.left),b.pageY-this.offset.click.top<this.containment[1]&&(g=this.containment[1]+this.offset.click.top),b.pageX-this.offset.click.left>this.containment[2]&&(f=this.containment[2]+this.offset.click.left),b.pageY-this.offset.click.top>this.containment[3]&&(g=this.containment[3]+this.offset.click.top));if(c.grid){var h=this.originalPageY+Math.round((g-this.originalPageY)/c.grid[1])*c.grid[1];g=this.containment?h-this.offset.click.top<this.containment[1]||h-this.offset.click.top>this.containment[3]?h-this.offset.click.top<this.containment[1]?h+c.grid[1]:h-c.grid[1]:h:h;var i=this.originalPageX+Math.round((f-this.originalPageX)/c.grid[0])*c.grid[0];f=this.containment?i-this.offset.click.left<this.containment[0]||i-this.offset.click.left>this.containment[2]?i-this.offset.click.left<this.containment[0]?i+c.grid[0]:i-c.grid[0]:i:i}}return{top:g-this.offset.click.top-this.offset.relative.top-this.offset.parent.top+(a.browser.safari&&this.cssPosition=="fixed"?0:this.cssPosition=="fixed"?-this.scrollParent.scrollTop():e?0:d.scrollTop()),left:f-this.offset.click.left-this.offset.relative.left-this.offset.parent.left+(a.browser.safari&&this.cssPosition=="fixed"?0:this.cssPosition=="fixed"?-this.scrollParent.scrollLeft():e?0:d.scrollLeft())}},_rearrange:function(a,b,c,d){c?c[0].appendChild(this.placeholder[0]):b.item[0].parentNode.insertBefore(this.placeholder[0],this.direction=="down"?b.item[0]:b.item[0].nextSibling),this.counter=this.counter?++this.counter:1;var e=this,f=this.counter;window.setTimeout(function(){f==e.counter&&e.refreshPositions(!d)},0)},_clear:function(b,c){this.reverting=!1;var d=[],e=this;!this._noFinalSort&&this.currentItem.parent().length&&this.placeholder.before(this.currentItem),this._noFinalSort=null;if(this.helper[0]==this.currentItem[0]){for(var f in this._storedCSS)if(this._storedCSS[f]=="auto"||this._storedCSS[f]=="static")this._storedCSS[f]="";this.currentItem.css(this._storedCSS).removeClass("ui-sortable-helper")}else this.currentItem.show();this.fromOutside&&!c&&d.push(function(a){this._trigger("receive",a,this._uiHash(this.fromOutside))}),(this.fromOutside||this.domPosition.prev!=this.currentItem.prev().not(".ui-sortable-helper")[0]||this.domPosition.parent!=this.currentItem.parent()[0])&&!c&&d.push(function(a){this._trigger("update",a,this._uiHash())});if(!a.ui.contains(this.element[0],this.currentItem[0])){c||d.push(function(a){this._trigger("remove",a,this._uiHash())});for(var f=this.containers.length-1;f>=0;f--)a.ui.contains(this.containers[f].element[0],this.currentItem[0])&&!c&&(d.push(function(a){return function(b){a._trigger("receive",b,this._uiHash(this))}}.call(this,this.containers[f])),d.push(function(a){return function(b){a._trigger("update",b,this._uiHash(this))}}.call(this,this.containers[f])))}for(var f=this.containers.length-1;f>=0;f--)c||d.push(function(a){return function(b){a._trigger("deactivate",b,this._uiHash(this))}}.call(this,this.containers[f])),this.containers[f].containerCache.over&&(d.push(function(a){return function(b){a._trigger("out",b,this._uiHash(this))}}.call(this,this.containers[f])),this.containers[f].containerCache.over=0);this._storedCursor&&a("body").css("cursor",this._storedCursor),this._storedOpacity&&this.helper.css("opacity",this._storedOpacity),this._storedZIndex&&this.helper.css("zIndex",this._storedZIndex=="auto"?"":this._storedZIndex),this.dragging=!1;if(this.cancelHelperRemoval){if(!c){this._trigger("beforeStop",b,this._uiHash());for(var f=0;f<d.length;f++)d[f].call(this,b);this._trigger("stop",b,this._uiHash())}return this.fromOutside=!1,!1}c||this._trigger("beforeStop",b,this._uiHash()),this.placeholder[0].parentNode.removeChild(this.placeholder[0]),this.helper[0]!=this.currentItem[0]&&this.helper.remove(),this.helper=null;if(!c){for(var f=0;f<d.length;f++)d[f].call(this,b);this._trigger("stop",b,this._uiHash())}return this.fromOutside=!1,!0},_trigger:function(){a.Widget.prototype._trigger.apply(this,arguments)===!1&&this.cancel()},_uiHash:function(b){var c=b||this;return{helper:c.helper,placeholder:c.placeholder||a([]),position:c.position,originalPosition:c.originalPosition,offset:c.positionAbs,item:c.currentItem,sender:b?b.element:null}}}),a.extend(a.ui.sortable,{version:"1.8.22"})}(jQuery),jQuery.effects||function(a,b){function c(b){var c;return b&&b.constructor==Array&&b.length==3?b:(c=/rgb\(\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*\)/.exec(b))?[parseInt(c[1],10),parseInt(c[2],10),parseInt(c[3],10)]:(c=/rgb\(\s*([0-9]+(?:\.[0-9]+)?)\%\s*,\s*([0-9]+(?:\.[0-9]+)?)\%\s*,\s*([0-9]+(?:\.[0-9]+)?)\%\s*\)/.exec(b))?[parseFloat(c[1])*2.55,parseFloat(c[2])*2.55,parseFloat(c[3])*2.55]:(c=/#([a-fA-F0-9]{2})([a-fA-F0-9]{2})([a-fA-F0-9]{2})/.exec(b))?[parseInt(c[1],16),parseInt(c[2],16),parseInt(c[3],16)]:(c=/#([a-fA-F0-9])([a-fA-F0-9])([a-fA-F0-9])/.exec(b))?[parseInt(c[1]+c[1],16),parseInt(c[2]+c[2],16),parseInt(c[3]+c[3],16)]:(c=/rgba\(0, 0, 0, 0\)/.exec(b))?e.transparent:e[a.trim(b).toLowerCase()]}function d(b,d){var e;do{e=(a.curCSS||a.css)(b,d);if(e!=""&&e!="transparent"||a.nodeName(b,"body"))break;d="backgroundColor"}while(b=b.parentNode);return c(e)}function h(){var a=document.defaultView?document.defaultView.getComputedStyle(this,null):this.currentStyle,b={},c,d;if(a&&a.length&&a[0]&&a[a[0]]){var e=a.length;while(e--)c=a[e],typeof a[c]=="string"&&(d=c.replace(/\-(\w)/g,function(a,b){return b.toUpperCase()}),b[d]=a[c])}else for(c in a)typeof a[c]=="string"&&(b[c]=a[c]);return b}function i(b){var c,d;for(c in b)d=b[c],(d==null||a.isFunction(d)||c in g||/scrollbar/.test(c)||!/color/i.test(c)&&isNaN(parseFloat(d)))&&delete b[c];return b}function j(a,b){var c={_:0},d;for(d in b)a[d]!=b[d]&&(c[d]=b[d]);return c}function k(b,c,d,e){typeof b=="object"&&(e=c,d=null,c=b,b=c.effect),a.isFunction(c)&&(e=c,d=null,c={});if(typeof c=="number"||a.fx.speeds[c])e=d,d=c,c={};return a.isFunction(d)&&(e=d,d=null),c=c||{},d=d||c.duration,d=a.fx.off?0:typeof d=="number"?d:d in a.fx.speeds?a.fx.speeds[d]:a.fx.speeds._default,e=e||c.complete,[b,c,d,e]}function l(b){return!b||typeof b=="number"||a.fx.speeds[b]?!0:typeof b=="string"&&!a.effects[b]?!0:!1}a.effects={},a.each(["backgroundColor","borderBottomColor","borderLeftColor","borderRightColor","borderTopColor","borderColor","color","outlineColor"],function(b,e){a.fx.step[e]=function(a){a.colorInit||(a.start=d(a.elem,e),a.end=c(a.end),a.colorInit=!0),a.elem.style[e]="rgb("+Math.max(Math.min(parseInt(a.pos*(a.end[0]-a.start[0])+a.start[0],10),255),0)+","+Math.max(Math.min(parseInt(a.pos*(a.end[1]-a.start[1])+a.start[1],10),255),0)+","+Math.max(Math.min(parseInt(a.pos*(a.end[2]-a.start[2])+a.start[2],10),255),0)+")"}});var e={aqua:[0,255,255],azure:[240,255,255],beige:[245,245,220],black:[0,0,0],blue:[0,0,255],brown:[165,42,42],cyan:[0,255,255],darkblue:[0,0,139],darkcyan:[0,139,139],darkgrey:[169,169,169],darkgreen:[0,100,0],darkkhaki:[189,183,107],darkmagenta:[139,0,139],darkolivegreen:[85,107,47],darkorange:[255,140,0],darkorchid:[153,50,204],darkred:[139,0,0],darksalmon:[233,150,122],darkviolet:[148,0,211],fuchsia:[255,0,255],gold:[255,215,0],green:[0,128,0],indigo:[75,0,130],khaki:[240,230,140],lightblue:[173,216,230],lightcyan:[224,255,255],lightgreen:[144,238,144],lightgrey:[211,211,211],lightpink:[255,182,193],lightyellow:[255,255,224],lime:[0,255,0],magenta:[255,0,255],maroon:[128,0,0],navy:[0,0,128],olive:[128,128,0],orange:[255,165,0],pink:[255,192,203],purple:[128,0,128],violet:[128,0,128],red:[255,0,0],silver:[192,192,192],white:[255,255,255],yellow:[255,255,0],transparent:[255,255,255]},f=["add","remove","toggle"],g={border:1,borderBottom:1,borderColor:1,borderLeft:1,borderRight:1,borderTop:1,borderWidth:1,margin:1,padding:1};a.effects.animateClass=function(b,c,d,e){return a.isFunction(d)&&(e=d,d=null),this.queue(function(){var g=a(this),k=g.attr("style")||" ",l=i(h.call(this)),m,n=g.attr("class")||"";a.each(f,function(a,c){b[c]&&g[c+"Class"](b[c])}),m=i(h.call(this)),g.attr("class",n),g.animate(j(l,m),{queue:!1,duration:c,easing:d,complete:function(){a.each(f,function(a,c){b[c]&&g[c+"Class"](b[c])}),typeof g.attr("style")=="object"?(g.attr("style").cssText="",g.attr("style").cssText=k):g.attr("style",k),e&&e.apply(this,arguments),a.dequeue(this)}})})},a.fn.extend({_addClass:a.fn.addClass,addClass:function(b,c,d,e){return c?a.effects.animateClass.apply(this,[{add:b},c,d,e]):this._addClass(b)},_removeClass:a.fn.removeClass,removeClass:function(b,c,d,e){return c?a.effects.animateClass.apply(this,[{remove:b},c,d,e]):this._removeClass(b)},_toggleClass:a.fn.toggleClass,toggleClass:function(c,d,e,f,g){return typeof d=="boolean"||d===b?e?a.effects.animateClass.apply(this,[d?{add:c}:{remove:c},e,f,g]):this._toggleClass(c,d):a.effects.animateClass.apply(this,[{toggle:c},d,e,f])},switchClass:function(b,c,d,e,f){return a.effects.animateClass.apply(this,[{add:c,remove:b},d,e,f])}}),a.extend(a.effects,{version:"1.8.22",save:function(a,b){for(var c=0;c<b.length;c++)b[c]!==null&&a.data("ec.storage."+b[c],a[0].style[b[c]])},restore:function(a,b){for(var c=0;c<b.length;c++)b[c]!==null&&a.css(b[c],a.data("ec.storage."+b[c]))},setMode:function(a,b){return b=="toggle"&&(b=a.is(":hidden")?"show":"hide"),b},getBaseline:function(a,b){var c,d;switch(a[0]){case"top":c=0;break;case"middle":c=.5;break;case"bottom":c=1;break;default:c=a[0]/b.height}switch(a[1]){case"left":d=0;break;case"center":d=.5;break;case"right":d=1;break;default:d=a[1]/b.width}return{x:d,y:c}},createWrapper:function(b){if(b.parent().is(".ui-effects-wrapper"))return b.parent();var c={width:b.outerWidth(!0),height:b.outerHeight(!0),"float":b.css("float")},d=a("<div></div>").addClass("ui-effects-wrapper").css({fontSize:"100%",background:"transparent",border:"none",margin:0,padding:0}),e=document.activeElement;try{e.id}catch(f){e=document.body}return b.wrap(d),(b[0]===e||a.contains(b[0],e))&&a(e).focus(),d=b.parent(),b.css("position")=="static"?(d.css({position:"relative"}),b.css({position:"relative"})):(a.extend(c,{position:b.css("position"),zIndex:b.css("z-index")}),a.each(["top","left","bottom","right"],function(a,d){c[d]=b.css(d),isNaN(parseInt(c[d],10))&&(c[d]="auto")}),b.css({position:"relative",top:0,left:0,right:"auto",bottom:"auto"})),d.css(c).show()},removeWrapper:function(b){var c,d=document.activeElement;return b.parent().is(".ui-effects-wrapper")?(c=b.parent().replaceWith(b),(b[0]===d||a.contains(b[0],d))&&a(d).focus(),c):b},setTransition:function(b,c,d,e){return e=e||{},a.each(c,function(a,c){var f=b.cssUnit(c);f[0]>0&&(e[c]=f[0]*d+f[1])}),e}}),a.fn.extend({effect:function(b,c,d,e){var f=k.apply(this,arguments),g={options:f[1],duration:f[2],callback:f[3]},h=g.options.mode,i=a.effects[b];return a.fx.off||!i?h?this[h](g.duration,g.callback):this.each(function(){g.callback&&g.callback.call(this)}):i.call(this,g)},_show:a.fn.show,show:function(a){if(l(a))return this._show.apply(this,arguments);var b=k.apply(this,arguments);return b[1].mode="show",this.effect.apply(this,b)},_hide:a.fn.hide,hide:function(a){if(l(a))return this._hide.apply(this,arguments);var b=k.apply(this,arguments);return b[1].mode="hide",this.effect.apply(this,b)},__toggle:a.fn.toggle,toggle:function(b){if(l(b)||typeof b=="boolean"||a.isFunction(b))return this.__toggle.apply(this,arguments);var c=k.apply(this,arguments);return c[1].mode="toggle",this.effect.apply(this,c)},cssUnit:function(b){var c=this.css(b),d=[];return a.each(["em","px","%","pt"],function(a,b){c.indexOf(b)>0&&(d=[parseFloat(c),b])}),d}}),a.easing.jswing=a.easing.swing,a.extend(a.easing,{def:"easeOutQuad",swing:function(b,c,d,e,f){return a.easing[a.easing.def](b,c,d,e,f)},easeInQuad:function(a,b,c,d,e){return d*(b/=e)*b+c},easeOutQuad:function(a,b,c,d,e){return-d*(b/=e)*(b-2)+c},easeInOutQuad:function(a,b,c,d,e){return(b/=e/2)<1?d/2*b*b+c:-d/2*(--b*(b-2)-1)+c},easeInCubic:function(a,b,c,d,e){return d*(b/=e)*b*b+c},easeOutCubic:function(a,b,c,d,e){return d*((b=b/e-1)*b*b+1)+c},easeInOutCubic:function(a,b,c,d,e){return(b/=e/2)<1?d/2*b*b*b+c:d/2*((b-=2)*b*b+2)+c},easeInQuart:function(a,b,c,d,e){return d*(b/=e)*b*b*b+c},easeOutQuart:function(a,b,c,d,e){return-d*((b=b/e-1)*b*b*b-1)+c},easeInOutQuart:function(a,b,c,d,e){return(b/=e/2)<1?d/2*b*b*b*b+c:-d/2*((b-=2)*b*b*b-2)+c},easeInQuint:function(a,b,c,d,e){return d*(b/=e)*b*b*b*b+c},easeOutQuint:function(a,b,c,d,e){return d*((b=b/e-1)*b*b*b*b+1)+c},easeInOutQuint:function(a,b,c,d,e){return(b/=e/2)<1?d/2*b*b*b*b*b+c:d/2*((b-=2)*b*b*b*b+2)+c},easeInSine:function(a,b,c,d,e){return-d*Math.cos(b/e*(Math.PI/2))+d+c},easeOutSine:function(a,b,c,d,e){return d*Math.sin(b/e*(Math.PI/2))+c},easeInOutSine:function(a,b,c,d,e){return-d/2*(Math.cos(Math.PI*b/e)-1)+c},easeInExpo:function(a,b,c,d,e){return b==0?c:d*Math.pow(2,10*(b/e-1))+c},easeOutExpo:function(a,b,c,d,e){return b==e?c+d:d*(-Math.pow(2,-10*b/e)+1)+c},easeInOutExpo:function(a,b,c,d,e){return b==0?c:b==e?c+d:(b/=e/2)<1?d/2*Math.pow(2,10*(b-1))+c:d/2*(-Math.pow(2,-10*--b)+2)+c},easeInCirc:function(a,b,c,d,e){return-d*(Math.sqrt(1-(b/=e)*b)-1)+c},easeOutCirc:function(a,b,c,d,e){return d*Math.sqrt(1-(b=b/e-1)*b)+c},easeInOutCirc:function(a,b,c,d,e){return(b/=e/2)<1?-d/2*(Math.sqrt(1-b*b)-1)+c:d/2*(Math.sqrt(1-(b-=2)*b)+1)+c},easeInElastic:function(a,b,c,d,e){var f=1.70158,g=0,h=d;if(b==0)return c;if((b/=e)==1)return c+d;g||(g=e*.3);if(h<Math.abs(d)){h=d;var f=g/4}else var f=g/(2*Math.PI)*Math.asin(d/h);return-(h*Math.pow(2,10*(b-=1))*Math.sin((b*e-f)*2*Math.PI/g))+c},easeOutElastic:function(a,b,c,d,e){var f=1.70158,g=0,h=d;if(b==0)return c;if((b/=e)==1)return c+d;g||(g=e*.3);if(h<Math.abs(d)){h=d;var f=g/4}else var f=g/(2*Math.PI)*Math.asin(d/h);return h*Math.pow(2,-10*b)*Math.sin((b*e-f)*2*Math.PI/g)+d+c},easeInOutElastic:function(a,b,c,d,e){var f=1.70158,g=0,h=d;if(b==0)return c;if((b/=e/2)==2)return c+d;g||(g=e*.3*1.5);if(h<Math.abs(d)){h=d;var f=g/4}else var f=g/(2*Math.PI)*Math.asin(d/h);return b<1?-0.5*h*Math.pow(2,10*(b-=1))*Math.sin((b*e-f)*2*Math.PI/g)+c:h*Math.pow(2,-10*(b-=1))*Math.sin((b*e-f)*2*Math.PI/g)*.5+d+c},easeInBack:function(a,c,d,e,f,g){return g==b&&(g=1.70158),e*(c/=f)*c*((g+1)*c-g)+d},easeOutBack:function(a,c,d,e,f,g){return g==b&&(g=1.70158),e*((c=c/f-1)*c*((g+1)*c+g)+1)+d},easeInOutBack:function(a,c,d,e,f,g){return g==b&&(g=1.70158),(c/=f/2)<1?e/2*c*c*(((g*=1.525)+1)*c-g)+d:e/2*((c-=2)*c*(((g*=1.525)+1)*c+g)+2)+d},easeInBounce:function(b,c,d,e,f){return e-a.easing.easeOutBounce(b,f-c,0,e,f)+d},easeOutBounce:function(a,b,c,d,e){return(b/=e)<1/2.75?d*7.5625*b*b+c:b<2/2.75?d*(7.5625*(b-=1.5/2.75)*b+.75)+c:b<2.5/2.75?d*(7.5625*(b-=2.25/2.75)*b+.9375)+c:d*(7.5625*(b-=2.625/2.75)*b+.984375)+c},easeInOutBounce:function(b,c,d,e,f){return c<f/2?a.easing.easeInBounce(b,c*2,0,e,f)*.5+d:a.easing.easeOutBounce(b,c*2-f,0,e,f)*.5+e*.5+d}})}(jQuery),function(a,b){a.effects.blind=function(b){return this.queue(function(){var c=a(this),d=["position","top","bottom","left","right"],e=a.effects.setMode(c,b.options.mode||"hide"),f=b.options.direction||"vertical";a.effects.save(c,d),c.show();var g=a.effects.createWrapper(c).css({overflow:"hidden"}),h=f=="vertical"?"height":"width",i=f=="vertical"?g.height():g.width();e=="show"&&g.css(h,0);var j={};j[h]=e=="show"?i:0,g.animate(j,b.duration,b.options.easing,function(){e=="hide"&&c.hide(),a.effects.restore(c,d),a.effects.removeWrapper(c),b.callback&&b.callback.apply(c[0],arguments),c.dequeue()})})}}(jQuery),function(a,b){a.effects.bounce=function(b){return this.queue(function(){var c=a(this),d=["position","top","bottom","left","right"],e=a.effects.setMode(c,b.options.mode||"effect"),f=b.options.direction||"up",g=b.options.distance||20,h=b.options.times||5,i=b.duration||250;/show|hide/.test(e)&&d.push("opacity"),a.effects.save(c,d),c.show(),a.effects.createWrapper(c);var j=f=="up"||f=="down"?"top":"left",k=f=="up"||f=="left"?"pos":"neg",g=b.options.distance||(j=="top"?c.outerHeight(!0)/3:c.outerWidth(!0)/3);e=="show"&&c.css("opacity",0).css(j,k=="pos"?-g:g),e=="hide"&&(g=g/(h*2)),e!="hide"&&h--;if(e=="show"){var l={opacity:1};l[j]=(k=="pos"?"+=":"-=")+g,c.animate(l,i/2,b.options.easing),g=g/2,h--}for(var m=0;m<h;m++){var n={},p={};n[j]=(k=="pos"?"-=":"+=")+g,p[j]=(k=="pos"?"+=":"-=")+g,c.animate(n,i/2,b.options.easing).animate(p,i/2,b.options.easing),g=e=="hide"?g*2:g/2}if(e=="hide"){var l={opacity:0};l[j]=(k=="pos"?"-=":"+=")+g,c.animate(l,i/2,b.options.easing,function(){c.hide(),a.effects.restore(c,d),a.effects.removeWrapper(c),b.callback&&b.callback.apply(this,arguments)})}else{var n={},p={};n[j]=(k=="pos"?"-=":"+=")+g,p[j]=(k=="pos"?"+=":"-=")+g,c.animate(n,i/2,b.options.easing).animate(p,i/2,b.options.easing,function(){a.effects.restore(c,d),a.effects.removeWrapper(c),b.callback&&b.callback.apply(this,arguments)})}c.queue("fx",function(){c.dequeue()}),c.dequeue()})}}(jQuery),function(a,b){a.effects.clip=function(b){return this.queue(function(){var c=a(this),d=["position","top","bottom","left","right","height","width"],e=a.effects.setMode(c,b.options.mode||"hide"),f=b.options.direction||"vertical";a.effects.save(c,d),c.show();var g=a.effects.createWrapper(c).css({overflow:"hidden"}),h=c[0].tagName=="IMG"?g:c,i={size:f=="vertical"?"height":"width",position:f=="vertical"?"top":"left"},j=f=="vertical"?h.height():h.width();e=="show"&&(h.css(i.size,0),h.css(i.position,j/2));var k={};k[i.size]=e=="show"?j:0,k[i.position]=e=="show"?0:j/2,h.animate(k,{queue:!1,duration:b.duration,easing:b.options.easing,complete:function(){e=="hide"&&c.hide(),a.effects.restore(c,d),a.effects.removeWrapper(c),b.callback&&b.callback.apply(c[0],arguments),c.dequeue()}})})}}(jQuery),function(a,b){a.effects.drop=function(b){return this.queue(function(){var c=a(this),d=["position","top","bottom","left","right","opacity"],e=a.effects.setMode(c,b.options.mode||"hide"),f=b.options.direction||"left";a.effects.save(c,d),c.show(),a.effects.createWrapper(c);var g=f=="up"||f=="down"?"top":"left",h=f=="up"||f=="left"?"pos":"neg",i=b.options.distance||(g=="top"?c.outerHeight(!0)/2:c.outerWidth(!0)/2);e=="show"&&c.css("opacity",0).css(g,h=="pos"?-i:i);var j={opacity:e=="show"?1:0};j[g]=(e=="show"?h=="pos"?"+=":"-=":h=="pos"?"-=":"+=")+i,c.animate(j,{queue:!1,duration:b.duration,easing:b.options.easing,complete:function(){e=="hide"&&c.hide(),a.effects.restore(c,d),a.effects.removeWrapper(c),b.callback&&b.callback.apply(this,arguments),c.dequeue()}})})}}(jQuery),function(a,b){a.effects.explode=function(b){return this.queue(function(){var c=b.options.pieces?Math.round(Math.sqrt(b.options.pieces)):3,d=b.options.pieces?Math.round(Math.sqrt(b.options.pieces)):3;b.options.mode=b.options.mode=="toggle"?a(this).is(":visible")?"hide":"show":b.options.mode;var e=a(this).show().css("visibility","hidden"),f=e.offset();f.top-=parseInt(e.css("marginTop"),10)||0,f.left-=parseInt(e.css("marginLeft"),10)||0;var g=e.outerWidth(!0),h=e.outerHeight(!0);for(var i=0;i<c;i++)for(var j=0;j<d;j++)e.clone().appendTo("body").wrap("<div></div>").css({position:"absolute",visibility:"visible",left:-j*(g/d),top:-i*(h/c)}).parent().addClass("ui-effects-explode").css({position:"absolute",overflow:"hidden",width:g/d,height:h/c,left:f.left+j*(g/d)+(b.options.mode=="show"?(j-Math.floor(d/2))*(g/d):0),top:f.top+i*(h/c)+(b.options.mode=="show"?(i-Math.floor(c/2))*(h/c):0),opacity:b.options.mode=="show"?0:1}).animate({left:f.left+j*(g/d)+(b.options.mode=="show"?0:(j-Math.floor(d/2))*(g/d)),top:f.top+i*(h/c)+(b.options.mode=="show"?0:(i-Math.floor(c/2))*(h/c)),opacity:b.options.mode=="show"?1:0},b.duration||500);setTimeout(function(){b.options.mode=="show"?e.css({visibility:"visible"}):e.css({visibility:"visible"}).hide(),b.callback&&b.callback.apply(e[0]),e.dequeue(),a("div.ui-effects-explode").remove()},b.duration||500)})}}(jQuery),function(a,b){a.effects.fade=function(b){return this.queue(function(){var c=a(this),d=a.effects.setMode(c,b.options.mode||"hide");c.animate({opacity:d},{queue:!1,duration:b.duration,easing:b.options.easing,complete:function(){b.callback&&b.callback.apply(this,arguments),c.dequeue()}})})}}(jQuery),function(a,b){a.effects.fold=function(b){return this.queue(function(){var c=a(this),d=["position","top","bottom","left","right"],e=a.effects.setMode(c,b.options.mode||"hide"),f=b.options.size||15,g=!!b.options.horizFirst,h=b.duration?b.duration/2:a.fx.speeds._default/2;a.effects.save(c,d),c.show();var i=a.effects.createWrapper(c).css({overflow:"hidden"}),j=e=="show"!=g,k=j?["width","height"]:["height","width"],l=j?[i.width(),i.height()]:[i.height(),i.width()],m=/([0-9]+)%/.exec(f);m&&(f=parseInt(m[1],10)/100*l[e=="hide"?0:1]),e=="show"&&i.css(g?{height:0,width:f}:{height:f,width:0});var n={},p={};n[k[0]]=e=="show"?l[0]:f,p[k[1]]=e=="show"?l[1]:0,i.animate(n,h,b.options.easing).animate(p,h,b.options.easing,function(){e=="hide"&&c.hide(),a.effects.restore(c,d),a.effects.removeWrapper(c),b.callback&&b.callback.apply(c[0],arguments),c.dequeue()})})}}(jQuery),function(a,b){a.effects.highlight=function(b){return this.queue(function(){var c=a(this),d=["backgroundImage","backgroundColor","opacity"],e=a.effects.setMode(c,b.options.mode||"show"),f={backgroundColor:c.css("backgroundColor")};e=="hide"&&(f.opacity=0),a.effects.save(c,d),c.show().css({backgroundImage:"none",backgroundColor:b.options.color||"#ffff99"}).animate(f,{queue:!1,duration:b.duration,easing:b.options.easing,complete:function(){e=="hide"&&c.hide(),a.effects.restore(c,d),e=="show"&&!a.support.opacity&&this.style.removeAttribute("filter"),b.callback&&b.callback.apply(this,arguments),c.dequeue()}})})}}(jQuery),function(a,b){a.effects.pulsate=function(b){return this.queue(function(){var c=a(this),d=a.effects.setMode(c,b.options.mode||"show"),e=(b.options.times||5)*2-1,f=b.duration?b.duration/2:a.fx.speeds._default/2,g=c.is(":visible"),h=0;g||(c.css("opacity",0).show(),h=1),(d=="hide"&&g||d=="show"&&!g)&&e--;for(var i=0;i<e;i++)c.animate({opacity:h},f,b.options.easing),h=(h+1)%2;c.animate({opacity:h},f,b.options.easing,function(){h==0&&c.hide(),b.callback&&b.callback.apply(this,arguments)}),c.queue("fx",function(){c.dequeue()}).dequeue()})}}(jQuery),function(a,b){a.effects.puff=function(b){return this.queue(function(){var c=a(this),d=a.effects.setMode(c,b.options.mode||"hide"),e=parseInt(b.options.percent,10)||150,f=e/100,g={height:c.height(),width:c.width()};a.extend(b.options,{fade:!0,mode:d,percent:d=="hide"?e:100,from:d=="hide"?g:{height:g.height*f,width:g.width*f}}),c.effect("scale",b.options,b.duration,b.callback),c.dequeue()})},a.effects.scale=function(b){return this.queue(function(){var c=a(this),d=a.extend(!0,{},b.options),e=a.effects.setMode(c,b.options.mode||"effect"),f=parseInt(b.options.percent,10)||(parseInt(b.options.percent,10)==0?0:e=="hide"?0:100),g=b.options.direction||"both",h=b.options.origin;e!="effect"&&(d.origin=h||["middle","center"],d.restore=!0);var i={height:c.height(),width:c.width()};c.from=b.options.from||(e=="show"?{height:0,width:0}:i);var j={y:g!="horizontal"?f/100:1,x:g!="vertical"?f/100:1};c.to={height:i.height*j.y,width:i.width*j.x},b.options.fade&&(e=="show"&&(c.from.opacity=0,c.to.opacity=1),e=="hide"&&(c.from.opacity=1,c.to.opacity=0)),d.from=c.from,d.to=c.to,d.mode=e,c.effect("size",d,b.duration,b.callback),c.dequeue()})},a.effects.size=function(b){return this.queue(function(){var c=a(this),d=["position","top","bottom","left","right","width","height","overflow","opacity"],e=["position","top","bottom","left","right","overflow","opacity"],f=["width","height","overflow"],g=["fontSize"],h=["borderTopWidth","borderBottomWidth","paddingTop","paddingBottom"],i=["borderLeftWidth","borderRightWidth","paddingLeft","paddingRight"],j=a.effects.setMode(c,b.options.mode||"effect"),k=b.options.restore||!1,l=b.options.scale||"both",m=b.options.origin,n={height:c.height(),width:c.width()};c.from=b.options.from||n,c.to=b.options.to||n;if(m){var p=a.effects.getBaseline(m,n);c.from.top=(n.height-c.from.height)*p.y,c.from.left=(n.width-c.from.width)*p.x,c.to.top=(n.height-c.to.height)*p.y,c.to.left=(n.width-c.to.width)*p.x}var q={from:{y:c.from.height/n.height,x:c.from.width/n.width},to:{y:c.to.height/n.height,x:c.to.width/n.width}};if(l=="box"||l=="both")q.from.y!=q.to.y&&(d=d.concat(h),c.from=a.effects.setTransition(c,h,q.from.y,c.from),c.to=a.effects.setTransition(c,h,q.to.y,c.to)),q.from.x!=q.to.x&&(d=d.concat(i),c.from=a.effects.setTransition(c,i,q.from.x,c.from),c.to=a.effects.setTransition(c,i,q.to.x,c.to));(l=="content"||l=="both")&&q.from.y!=q.to.y&&(d=d.concat(g),c.from=a.effects.setTransition(c,g,q.from.y,c.from),c.to=a.effects.setTransition(c,g,q.to.y,c.to)),a.effects.save(c,k?d:e),c.show(),a.effects.createWrapper(c),c.css("overflow","hidden").css(c.from);if(l=="content"||l=="both")h=h.concat(["marginTop","marginBottom"]).concat(g),i=i.concat(["marginLeft","marginRight"]),f=d.concat(h).concat(i),c.find("*[width]").each(function(){var c=a(this);k&&a.effects.save(c,f);var d={height:c.height(),width:c.width()};c.from={height:d.height*q.from.y,width:d.width*q.from.x},c.to={height:d.height*q.to.y,width:d.width*q.to.x},q.from.y!=q.to.y&&(c.from=a.effects.setTransition(c,h,q.from.y,c.from),c.to=a.effects.setTransition(c,h,q.to.y,c.to)),q.from.x!=q.to.x&&(c.from=a.effects.setTransition(c,i,q.from.x,c.from),c.to=a.effects.setTransition(c,i,q.to.x,c.to)),c.css(c.from),c.animate(c.to,b.duration,b.options.easing,function(){k&&a.effects.restore(c,f)})});c.animate(c.to,{queue:!1,duration:b.duration,easing:b.options.easing,complete:function(){c.to.opacity===0&&c.css("opacity",c.from.opacity),j=="hide"&&c.hide(),a.effects.restore(c,k?d:e),a.effects.removeWrapper(c),b.callback&&b.callback.apply(this,arguments),c.dequeue()}})})}}(jQuery),function(a,b){a.effects.shake=function(b){return this.queue(function(){var c=a(this),d=["position","top","bottom","left","right"],e=a.effects.setMode(c,b.options.mode||"effect"),f=b.options.direction||"left",g=b.options.distance||20,h=b.options.times||3,i=b.duration||b.options.duration||140;a.effects.save(c,d),c.show(),a.effects.createWrapper(c);var j=f=="up"||f=="down"?"top":"left",k=f=="up"||f=="left"?"pos":"neg",l={},m={},n={};l[j]=(k=="pos"?"-=":"+=")+g,m[j]=(k=="pos"?"+=":"-=")+g*2,n[j]=(k=="pos"?"-=":"+=")+g*2,c.animate(l,i,b.options.easing);for(var p=1;p<h;p++)c.animate(m,i,b.options.easing).animate(n,i,b.options.easing);c.animate(m,i,b.options.easing).animate(l,i/2,b.options.easing,function(){a.effects.restore(c,d),a.effects.removeWrapper(c),b.callback&&b.callback.apply(this,arguments)}),c.queue("fx",function(){c.dequeue()}),c.dequeue()})}}(jQuery),function(a,b){a.effects.slide=function(b){return this.queue(function(){var c=a(this),d=["position","top","bottom","left","right"],e=a.effects.setMode(c,b.options.mode||"show"),f=b.options.direction||"left";a.effects.save(c,d),c.show(),a.effects.createWrapper(c).css({overflow:"hidden"});var g=f=="up"||f=="down"?"top":"left",h=f=="up"||f=="left"?"pos":"neg",i=b.options.distance||(g=="top"?c.outerHeight(!0):c.outerWidth(!0));e=="show"&&c.css(g,h=="pos"?isNaN(i)?"-"+i:-i:i);var j={};j[g]=(e=="show"?h=="pos"?"+=":"-=":h=="pos"?"-=":"+=")+i,c.animate(j,{queue:!1,duration:b.duration,easing:b.options.easing,complete:function(){e=="hide"&&c.hide(),a.effects.restore(c,d),a.effects.removeWrapper(c),b.callback&&b.callback.apply(this,arguments),c.dequeue()}})})}}(jQuery),function(a,b){a.effects.transfer=function(b){return this.queue(function(){var c=a(this),d=a(b.options.to),e=d.offset(),f={top:e.top,left:e.left,height:d.innerHeight(),width:d.innerWidth()},g=c.offset(),h=a('<div class="ui-effects-transfer"></div>').appendTo(document.body).addClass(b.options.className).css({top:g.top,left:g.left,height:c.innerHeight(),width:c.innerWidth(),position:"absolute"}).animate(f,b.duration,b.options.easing,function(){h.remove(),b.callback&&b.callback.apply(c[0],arguments),c.dequeue()})})}}(jQuery),function(a,b){a.widget("ui.accordion",{options:{active:0,animated:"slide",autoHeight:!0,clearStyle:!1,collapsible:!1,event:"click",fillSpace:!1,header:"> li > :first-child,> :not(li):even",icons:{header:"ui-icon-triangle-1-e",headerSelected:"ui-icon-triangle-1-s"},navigation:!1,navigationFilter:function(){return this.href.toLowerCase()===location.href.toLowerCase()}},_create:function(){var b=this,c=b.options;b.running=0,b.element.addClass("ui-accordion ui-widget ui-helper-reset").children("li").addClass("ui-accordion-li-fix"),b.headers=b.element.find(c.header).addClass("ui-accordion-header ui-helper-reset ui-state-default ui-corner-all").bind("mouseenter.accordion",function(){if(c.disabled)return;a(this).addClass("ui-state-hover")}).bind("mouseleave.accordion",function(){if(c.disabled)return;a(this).removeClass("ui-state-hover")}).bind("focus.accordion",function(){if(c.disabled)return;a(this).addClass("ui-state-focus")}).bind("blur.accordion",function(){if(c.disabled)return;a(this).removeClass("ui-state-focus")}),b.headers.next().addClass("ui-accordion-content ui-helper-reset ui-widget-content ui-corner-bottom");if(c.navigation){var d=b.element.find("a").filter(c.navigationFilter).eq(0);if(d.length){var e=d.closest(".ui-accordion-header");e.length?b.active=e:b.active=d.closest(".ui-accordion-content").prev()}}b.active=b._findActive(b.active||c.active).addClass("ui-state-default ui-state-active").toggleClass("ui-corner-all").toggleClass("ui-corner-top"),b.active.next().addClass("ui-accordion-content-active"),b._createIcons(),b.resize(),b.element.attr("role","tablist"),b.headers.attr("role","tab").bind("keydown.accordion",function(a){return b._keydown(a)}).next().attr("role","tabpanel"),b.headers.not(b.active||"").attr({"aria-expanded":"false","aria-selected":"false",tabIndex:-1}).next().hide(),b.active.length?b.active.attr({"aria-expanded":"true","aria-selected":"true",tabIndex:0}):b.headers.eq(0).attr("tabIndex",0),a.browser.safari||b.headers.find("a").attr("tabIndex",-1),c.event&&b.headers.bind(c.event.split(" ").join(".accordion ")+".accordion",function(a){b._clickHandler.call(b,a,this),a.preventDefault()})},_createIcons:function(){var b=this.options;b.icons&&(a("<span></span>").addClass("ui-icon "+b.icons.header).prependTo(this.headers),this.active.children(".ui-icon").toggleClass(b.icons.header).toggleClass(b.icons.headerSelected),this.element.addClass("ui-accordion-icons"))},_destroyIcons:function(){this.headers.children(".ui-icon").remove(),this.element.removeClass("ui-accordion-icons")},destroy:function(){var b=this.options;this.element.removeClass("ui-accordion ui-widget ui-helper-reset").removeAttr("role"),this.headers.unbind(".accordion").removeClass("ui-accordion-header ui-accordion-disabled ui-helper-reset ui-state-default ui-corner-all ui-state-active ui-state-disabled ui-corner-top").removeAttr("role").removeAttr("aria-expanded").removeAttr("aria-selected").removeAttr("tabIndex"),this.headers.find("a").removeAttr("tabIndex"),this._destroyIcons();var c=this.headers.next().css("display","").removeAttr("role").removeClass("ui-helper-reset ui-widget-content ui-corner-bottom ui-accordion-content ui-accordion-content-active ui-accordion-disabled ui-state-disabled");return(b.autoHeight||b.fillHeight)&&c.css("height",""),a.Widget.prototype.destroy.call(this)},_setOption:function(b,c){a.Widget.prototype._setOption.apply(this,arguments),b=="active"&&this.activate(c),b=="icons"&&(this._destroyIcons(),c&&this._createIcons()),b=="disabled"&&this.headers.add(this.headers.next())[c?"addClass":"removeClass"]("ui-accordion-disabled ui-state-disabled")},_keydown:function(b){if(this.options.disabled||b.altKey||b.ctrlKey)return;var c=a.ui.keyCode,d=this.headers.length,e=this.headers.index(b.target),f=!1;switch(b.keyCode){case c.RIGHT:case c.DOWN:f=this.headers[(e+1)%d];break;case c.LEFT:case c.UP:f=this.headers[(e-1+d)%d];break;case c.SPACE:case c.ENTER:this._clickHandler({target:b.target},b.target),b.preventDefault()}return f?(a(b.target).attr("tabIndex",-1),a(f).attr("tabIndex",0),f.focus(),!1):!0},resize:function(){var b=this.options,c;if(b.fillSpace){if(a.browser.msie){var d=this.element.parent().css("overflow");this.element.parent().css("overflow","hidden")}c=this.element.parent().height(),a.browser.msie&&this.element.parent().css("overflow",d),this.headers.each(function(){c-=a(this).outerHeight(!0)}),this.headers.next().each(function(){a(this).height(Math.max(0,c-a(this).innerHeight()+a(this).height()))}).css("overflow","auto")}else b.autoHeight&&(c=0,this.headers.next().each(function(){c=Math.max(c,a(this).height("").height())}).height(c));return this},activate:function(a){this.options.active=a;var b=this._findActive(a)[0];return this._clickHandler({target:b},b),this},_findActive:function(b){return b?typeof b=="number"?this.headers.filter(":eq("+b+")"):this.headers.not(this.headers.not(b)):b===!1?a([]):this.headers.filter(":eq(0)")},_clickHandler:function(b,c){var d=this.options;if(d.disabled)return;if(!b.target){if(!d.collapsible)return;this.active.removeClass("ui-state-active ui-corner-top").addClass("ui-state-default ui-corner-all").children(".ui-icon").removeClass(d.icons.headerSelected).addClass(d.icons.header),this.active.next().addClass("ui-accordion-content-active");var e=this.active.next(),f={options:d,newHeader:a([]),oldHeader:d.active,newContent:a([]),oldContent:e},g=this.active=a([]);this._toggle(g,e,f);return}var h=a(b.currentTarget||c),i=h[0]===this.active[0];d.active=d.collapsible&&i?!1:this.headers.index(h);if(this.running||!d.collapsible&&i)return;var j=this.active,g=h.next(),e=this.active.next(),f={options:d,newHeader:i&&d.collapsible?a([]):h,oldHeader:this.active,newContent:i&&d.collapsible?a([]):g,oldContent:e},k=this.headers.index(this.active[0])>this.headers.index(h[0]);this.active=i?a([]):h,this._toggle(g,e,f,i,k),j.removeClass("ui-state-active ui-corner-top").addClass("ui-state-default ui-corner-all").children(".ui-icon").removeClass(d.icons.headerSelected).addClass(d.icons.header),i||(h.removeClass("ui-state-default ui-corner-all").addClass("ui-state-active ui-corner-top").children(".ui-icon").removeClass(d.icons.header).addClass(d.icons.headerSelected),h.next().addClass("ui-accordion-content-active"));return},_toggle:function(b,c,d,e,f){var g=this,h=g.options;g.toShow=b,g.toHide=c,g.data=d;var i=function(){if(!g)return;return g._completed.apply(g,arguments)};g._trigger("changestart",null,g.data),g.running=c.size()===0?b.size():c.size();if(h.animated){var j={};h.collapsible&&e?j={toShow:a([]),toHide:c,complete:i,down:f,autoHeight:h.autoHeight||h.fillSpace}:j={toShow:b,toHide:c,complete:i,down:f,autoHeight:h.autoHeight||h.fillSpace},h.proxied||(h.proxied=h.animated),h.proxiedDuration||(h.proxiedDuration=h.duration),h.animated=a.isFunction(h.proxied)?h.proxied(j):h.proxied,h.duration=a.isFunction(h.proxiedDuration)?h.proxiedDuration(j):h.proxiedDuration;var k=a.ui.accordion.animations,l=h.duration,m=h.animated;m&&!k[m]&&!a.easing[m]&&(m="slide"),k[m]||(k[m]=function(a){this.slide(a,{easing:m,duration:l||700})}),k[m](j)}else h.collapsible&&e?b.toggle():(c.hide(),b.show()),i(!0);c.prev().attr({"aria-expanded":"false","aria-selected":"false",tabIndex:-1}).blur(),b.prev().attr({"aria-expanded":"true","aria-selected":"true",tabIndex:0}).focus()},_completed:function(a){this.running=a?0:--this.running;if(this.running)return;this.options.clearStyle&&this.toShow.add(this.toHide).css({height:"",overflow:""}),this.toHide.removeClass("ui-accordion-content-active"),this.toHide.length&&(this.toHide.parent()[0].className=this.toHide.parent()[0].className),this._trigger("change",null,this.data)}}),a.extend(a.ui.accordion,{version:"1.8.22",animations:{slide:function(b,c){b=a.extend({easing:"swing",duration:300},b,c);if(!b.toHide.size()){b.toShow.animate({height:"show",paddingTop:"show",paddingBottom:"show"},b);return}if(!b.toShow.size()){b.toHide.animate({height:"hide",paddingTop:"hide",paddingBottom:"hide"},b);return}var d=b.toShow.css("overflow"),e=0,f={},g={},h=["height","paddingTop","paddingBottom"],i,j=b.toShow;i=j[0].style.width,j.width(j.parent().width()-parseFloat(j.css("paddingLeft"))-parseFloat(j.css("paddingRight"))-(parseFloat(j.css("borderLeftWidth"))||0)-(parseFloat(j.css("borderRightWidth"))||0)),a.each(h,function(c,d){g[d]="hide";var e=(""+a.css(b.toShow[0],d)).match(/^([\d+-.]+)(.*)$/);f[d]={value:e[1],unit:e[2]||"px"}}),b.toShow.css({height:0,overflow:"hidden"}).show(),b.toHide.filter(":hidden").each(b.complete).end().filter(":visible").animate(g,{step:function(a,c){c.prop=="height"&&(e=c.end-c.start===0?0:(c.now-c.start)/(c.end-c.start)),b.toShow[0].style[c.prop]=e*f[c.prop].value+f[c.prop].unit},duration:b.duration,easing:b.easing,complete:function(){b.autoHeight||b.toShow.css("height",""),b.toShow.css({width:i,overflow:d}),b.complete()}})},bounceslide:function(a){this.slide(a,{easing:a.down?"easeOutBounce":"swing",duration:a.down?1e3:200})}}})}(jQuery),function(a,b){var c=0;a.widget("ui.autocomplete",{options:{appendTo:"body",autoFocus:!1,delay:300,minLength:1,position:{my:"left top",at:"left bottom",collision:"none"},source:null},pending:0,_create:function(){var b=this,c=this.element[0].ownerDocument,d;this.isMultiLine=this.element.is("textarea"),this.element.addClass("ui-autocomplete-input").attr("autocomplete","off").attr({role:"textbox","aria-autocomplete":"list","aria-haspopup":"true"}).bind("keydown.autocomplete",function(c){if(b.options.disabled||b.element.propAttr("readOnly"))return;d=!1;var e=a.ui.keyCode;switch(c.keyCode){case e.PAGE_UP:b._move("previousPage",c);break;case e.PAGE_DOWN:b._move("nextPage",c);break;case e.UP:b._keyEvent("previous",c);break;case e.DOWN:b._keyEvent("next",c);break;case e.ENTER:case e.NUMPAD_ENTER:b.menu.active&&(d=!0,c.preventDefault());case e.TAB:if(!b.menu.active)return;b.menu.select(c);break;case e.ESCAPE:b.element.val(b.term),b.close(c);break;default:clearTimeout(b.searching),b.searching=setTimeout(function(){b.term!=b.element.val()&&(b.selectedItem=null,b.search(null,c))},b.options.delay)}}).bind("keypress.autocomplete",function(a){d&&(d=!1,a.preventDefault())}).bind("focus.autocomplete",function(){if(b.options.disabled)return;b.selectedItem=null,b.previous=b.element.val()}).bind("blur.autocomplete",function(a){if(b.options.disabled)return;clearTimeout(b.searching),b.closing=setTimeout(function(){b.close(a),b._change(a)},150)}),this._initSource(),this.menu=a("<ul></ul>").addClass("ui-autocomplete").appendTo(a(this.options.appendTo||"body",c)[0]).mousedown(function(c){var d=b.menu.element[0];a(c.target).closest(".ui-menu-item").length||setTimeout(function(){a(document).one("mousedown",function(c){c.target!==b.element[0]&&c.target!==d&&!a.ui.contains(d,c.target)&&b.close()})},1),setTimeout(function(){clearTimeout(b.closing)},13)}).menu({focus:function(a,c){var d=c.item.data("item.autocomplete");!1!==b._trigger("focus",a,{item:d})&&/^key/.test(a.originalEvent.type)&&b.element.val(d.value)},selected:function(a,d){var e=d.item.data("item.autocomplete"),f=b.previous;b.element[0]!==c.activeElement&&(b.element.focus(),b.previous=f,setTimeout(function(){b.previous=f,b.selectedItem=e},1)),!1!==b._trigger("select",a,{item:e})&&b.element.val(e.value),b.term=b.element.val(),b.close(a),b.selectedItem=e},blur:function(a,c){b.menu.element.is(":visible")&&b.element.val()!==b.term&&b.element.val(b.term)}}).zIndex(this.element.zIndex()+1).css({top:0,left:0}).hide().data("menu"),a.fn.bgiframe&&this.menu.element.bgiframe(),b.beforeunloadHandler=function(){b.element.removeAttr("autocomplete")},a(window).bind("beforeunload",b.beforeunloadHandler)},destroy:function(){this.element.removeClass("ui-autocomplete-input").removeAttr("autocomplete").removeAttr("role").removeAttr("aria-autocomplete").removeAttr("aria-haspopup"),this.menu.element.remove(),a(window).unbind("beforeunload",this.beforeunloadHandler),a.Widget.prototype.destroy.call(this)},_setOption:function(b,c){a.Widget.prototype._setOption.apply(this,arguments),b==="source"&&this._initSource(),b==="appendTo"&&this.menu.element.appendTo(a(c||"body",this.element[0].ownerDocument)[0]),b==="disabled"&&c&&this.xhr&&this.xhr.abort()},_initSource:function(){var b=this,c,d;a.isArray(this.options.source)?(c=this.options.source,this.source=function(b,d){d(a.ui.autocomplete.filter(c,b.term))}):typeof this.options.source=="string"?(d=this.options.source,this.source=function(c,e){b.xhr&&b.xhr.abort(),b.xhr=a.ajax({url:d,data:c,dataType:"json",success:function(a,b){e(a)},error:function(){e([])}})}):this.source=this.options.source},search:function(a,b){a=a!=null?a:this.element.val(),this.term=this.element.val();if(a.length<this.options.minLength)return this.close(b);clearTimeout(this.closing);if(this._trigger("search",b)===!1)return;return this._search(a)},_search:function(a){this.pending++,this.element.addClass("ui-autocomplete-loading"),this.source({term:a},this._response())},_response:function(){var a=this,b=++c;return function(d){b===c&&a.__response(d),a.pending--,a.pending||a.element.removeClass("ui-autocomplete-loading")}},__response:function(a){!this.options.disabled&&a&&a.length?(a=this._normalize(a),this._suggest(a),this._trigger("open")):this.close()},close:function(a){clearTimeout(this.closing),this.menu.element.is(":visible")&&(this.menu.element.hide(),this.menu.deactivate(),this._trigger("close",a))},_change:function(a){this.previous!==this.element.val()&&this._trigger("change",a,{item:this.selectedItem})},_normalize:function(b){return b.length&&b[0].label&&b[0].value?b:a.map(b,function(b){return typeof b=="string"?{label:b,value:b}:a.extend({label:b.label||b.value,value:b.value||b.label},b)})},_suggest:function(b){var c=this.menu.element.empty().zIndex(this.element.zIndex()+1);this._renderMenu(c,b),this.menu.deactivate(),this.menu.refresh(),c.show(),this._resizeMenu(),c.position(a.extend({of:this.element},this.options.position)),this.options.autoFocus&&this.menu.next(new a.Event("mouseover"))},_resizeMenu:function(){var a=this.menu.element;a.outerWidth(Math.max(a.width("").outerWidth()+1,this.element.outerWidth()))},_renderMenu:function(b,c){var d=this;a.each(c,function(a,c){d._renderItem(b,c)})},_renderItem:function(b,c){return a("<li></li>").data("item.autocomplete",c).append(a("<a></a>").text(c.label)).appendTo(b)},_move:function(a,b){if(!this.menu.element.is(":visible")){this.search(null,b);return}if(this.menu.first()&&/^previous/.test(a)||this.menu.last()&&/^next/.test(a)){this.element.val(this.term),this.menu.deactivate();return}this.menu[a](b)},widget:function(){return this.menu.element},_keyEvent:function(a,b){if(!this.isMultiLine||this.menu.element.is(":visible"))this._move(a,b),b.preventDefault()}}),a.extend(a.ui.autocomplete,{escapeRegex:function(a){return a.replace(/[-[\]{}()*+?.,\\^$|#\s]/g,"\\$&")},filter:function(b,c){var d=new RegExp(a.ui.autocomplete.escapeRegex(c),"i");return a.grep(b,function(a){return d.test(a.label||a.value||a)})}})}(jQuery),function(a){a.widget("ui.menu",{_create:function(){var b=this;this.element.addClass("ui-menu ui-widget ui-widget-content ui-corner-all").attr({role:"listbox","aria-activedescendant":"ui-active-menuitem"}).click(function(c){if(!a(c.target).closest(".ui-menu-item a").length)return;c.preventDefault(),b.select(c)}),this.refresh()},refresh:function(){var b=this,c=this.element.children("li:not(.ui-menu-item):has(a)").addClass("ui-menu-item").attr("role","menuitem");c.children("a").addClass("ui-corner-all").attr("tabindex",-1).mouseenter(function(c){b.activate(c,a(this).parent())}).mouseleave(function(){b.deactivate()})},activate:function(a,b){this.deactivate();if(this.hasScroll()){var c=b.offset().top-this.element.offset().top,d=this.element.scrollTop(),e=this.element.height();c<0?this.element.scrollTop(d+c):c>=e&&this.element.scrollTop(d+c-e+b.height())}this.active=b.eq(0).children("a").addClass("ui-state-hover").attr("id","ui-active-menuitem").end(),this._trigger("focus",a,{item:b})},deactivate:function(){if(!this.active)return;this.active.children("a").removeClass("ui-state-hover").removeAttr("id"),this._trigger("blur"),this.active=null},next:function(a){this.move("next",".ui-menu-item:first",a)},previous:function(a){this.move("prev",".ui-menu-item:last",a)},first:function(){return this.active&&!this.active.prevAll(".ui-menu-item").length},last:function(){return this.active&&!this.active.nextAll(".ui-menu-item").length},move:function(a,b,c){if(!this.active){this.activate(c,this.element.children(b));return}var d=this.active[a+"All"](".ui-menu-item").eq(0);d.length?this.activate(c,d):this.activate(c,this.element.children(b))},nextPage:function(b){if(this.hasScroll()){if(!this.active||this.last()){this.activate(b,this.element.children(".ui-menu-item:first"));return}var c=this.active.offset().top,d=this.element.height(),e=this.element.children(".ui-menu-item").filter(function(){var b=a(this).offset().top-c-d+a(this).height();return b<10&&b>-10});e.length||(e=this.element.children(".ui-menu-item:last")),this.activate(b,e)}else this.activate(b,this.element.children(".ui-menu-item").filter(!this.active||this.last()?":first":":last"))},previousPage:function(b){if(this.hasScroll()){if(!this.active||this.first()){this.activate(b,this.element.children(".ui-menu-item:last"));return}var c=this.active.offset().top,d=this.element.height(),e=this.element.children(".ui-menu-item").filter(function(){var b=a(this).offset().top-c+d-a(this).height();return b<10&&b>-10});e.length||(e=this.element.children(".ui-menu-item:first")),this.activate(b,e)}else this.activate(b,this.element.children(".ui-menu-item").filter(!this.active||this.first()?":last":":first"))},hasScroll:function(){return this.element.height()<this.element[a.fn.prop?"prop":"attr"]("scrollHeight")},select:function(a){this._trigger("selected",a,{item:this.active})}})}(jQuery),function(a,b){var c,d,e,f,g="ui-button ui-widget ui-state-default ui-corner-all",h="ui-state-hover ui-state-active ",i="ui-button-icons-only ui-button-icon-only ui-button-text-icons ui-button-text-icon-primary ui-button-text-icon-secondary ui-button-text-only",j=function(){var b=a(this).find(":ui-button");setTimeout(function(){b.button("refresh")},1)},k=function(b){var c=b.name,d=b.form,e=a([]);return c&&(d?e=a(d).find("[name='"+c+"']"):e=a("[name='"+c+"']",b.ownerDocument).filter(function(){return!this.form})),e};a.widget("ui.button",{options:{disabled:null,text:!0,label:null,icons:{primary:null,secondary:null}},_create:function(){this.element.closest("form").unbind("reset.button").bind("reset.button",j),typeof this.options.disabled!="boolean"?this.options.disabled=!!this.element.propAttr("disabled"):this.element.propAttr("disabled",this.options.disabled),this._determineButtonType(),this.hasTitle=!!this.buttonElement.attr("title");var b=this,h=this.options,i=this.type==="checkbox"||this.type==="radio",l="ui-state-hover"+(i?"":" ui-state-active"),m="ui-state-focus";h.label===null&&(h.label=this.buttonElement.html()),this.buttonElement.addClass(g).attr("role","button").bind("mouseenter.button",function(){if(h.disabled)return;a(this).addClass("ui-state-hover"),this===c&&a(this).addClass("ui-state-active")}).bind("mouseleave.button",function(){if(h.disabled)return;a(this).removeClass(l)}).bind("click.button",function(a){h.disabled&&(a.preventDefault(),a.stopImmediatePropagation())}),this.element.bind("focus.button",function(){b.buttonElement.addClass(m)}).bind("blur.button",function(){b.buttonElement.removeClass(m)}),i&&(this.element.bind("change.button",function(){if(f)return;b.refresh()}),this.buttonElement.bind("mousedown.button",function(a){if(h.disabled)return;f=!1,d=a.pageX,e=a.pageY}).bind("mouseup.button",function(a){if(h.disabled)return;if(d!==a.pageX||e!==a.pageY)f=!0})),this.type==="checkbox"?this.buttonElement.bind("click.button",function(){if(h.disabled||f)return!1;a(this).toggleClass("ui-state-active"),b.buttonElement.attr("aria-pressed",b.element[0].checked)}):this.type==="radio"?this.buttonElement.bind("click.button",function(){if(h.disabled||f)return!1;a(this).addClass("ui-state-active"),b.buttonElement.attr("aria-pressed","true");var c=b.element[0];k(c).not(c).map(function(){return a(this).button("widget")[0]}).removeClass("ui-state-active").attr("aria-pressed","false")}):(this.buttonElement.bind("mousedown.button",function(){if(h.disabled)return!1;a(this).addClass("ui-state-active"),c=this,a(document).one("mouseup",function(){c=null})}).bind("mouseup.button",function(){if(h.disabled)return!1;a(this).removeClass("ui-state-active")}).bind("keydown.button",function(b){if(h.disabled)return!1;(b.keyCode==a.ui.keyCode.SPACE||b.keyCode==a.ui.keyCode.ENTER)&&a(this).addClass("ui-state-active")}).bind("keyup.button",function(){a(this).removeClass("ui-state-active")}),this.buttonElement.is("a")&&this.buttonElement.keyup(function(b){b.keyCode===a.ui.keyCode.SPACE&&a(this).click()})),this._setOption("disabled",h.disabled),this._resetButton()},_determineButtonType:function(){this.element.is(":checkbox")?this.type="checkbox":this.element.is(":radio")?this.type="radio":this.element.is("input")?this.type="input":this.type="button";if(this.type==="checkbox"||this.type==="radio"){var a=this.element.parents().filter(":last"),b="label[for='"+this.element.attr("id")+"']";this.buttonElement=a.find(b),this.buttonElement.length||(a=a.length?a.siblings():this.element.siblings(),this.buttonElement=a.filter(b),this.buttonElement.length||(this.buttonElement=a.find(b))),this.element.addClass("ui-helper-hidden-accessible");var c=this.element.is(":checked");c&&this.buttonElement.addClass("ui-state-active"),this.buttonElement.attr("aria-pressed",c)}else this.buttonElement=this.element},widget:function(){return this.buttonElement},destroy:function(){this.element.removeClass("ui-helper-hidden-accessible"),this.buttonElement.removeClass(g+" "+h+" "+i).removeAttr("role").removeAttr("aria-pressed").html(this.buttonElement.find(".ui-button-text").html()),this.hasTitle||this.buttonElement.removeAttr("title"),a.Widget.prototype.destroy.call(this)},_setOption:function(b,c){a.Widget.prototype._setOption.apply(this,arguments);if(b==="disabled"){c?this.element.propAttr("disabled",!0):this.element.propAttr("disabled",!1);return}this._resetButton()},refresh:function(){var b=this.element.is(":disabled");b!==this.options.disabled&&this._setOption("disabled",b),this.type==="radio"?k(this.element[0]).each(function(){a(this).is(":checked")?a(this).button("widget").addClass("ui-state-active").attr("aria-pressed","true"):a(this).button("widget").removeClass("ui-state-active").attr("aria-pressed","false")}):this.type==="checkbox"&&(this.element.is(":checked")?this.buttonElement.addClass("ui-state-active").attr("aria-pressed","true"):this.buttonElement.removeClass("ui-state-active").attr("aria-pressed","false"))},_resetButton:function(){if(this.type==="input"){this.options.label&&this.element.val(this.options.label);return}var b=this.buttonElement.removeClass(i),c=a("<span></span>",this.element[0].ownerDocument).addClass("ui-button-text").html(this.options.label).appendTo(b.empty()).text(),d=this.options.icons,e=d.primary&&d.secondary,f=[];d.primary||d.secondary?(this.options.text&&f.push("ui-button-text-icon"+(e?"s":d.primary?"-primary":"-secondary")),d.primary&&b.prepend("<span class='ui-button-icon-primary ui-icon "+d.primary+"'></span>"),d.secondary&&b.append("<span class='ui-button-icon-secondary ui-icon "+d.secondary+"'></span>"),this.options.text||(f.push(e?"ui-button-icons-only":"ui-button-icon-only"),this.hasTitle||b.attr("title",c))):f.push("ui-button-text-only"),b.addClass(f.join(" "))}}),a.widget("ui.buttonset",{options:{items:":button, :submit, :reset, :checkbox, :radio, a, :data(button)"},_create:function(){this.element.addClass("ui-buttonset")},_init:function(){this.refresh()},_setOption:function(b,c){b==="disabled"&&this.buttons.button("option",b,c),a.Widget.prototype._setOption.apply(this,arguments)},refresh:function(){var b=this.element.css("direction")==="rtl";this.buttons=this.element.find(this.options.items).filter(":ui-button").button("refresh").end().not(":ui-button").button().end().map(function(){return a(this).button("widget")[0]}).removeClass("ui-corner-all ui-corner-left ui-corner-right").filter(":first").addClass(b?"ui-corner-right":"ui-corner-left").end().filter(":last").addClass(b?"ui-corner-left":"ui-corner-right").end().end()},destroy:function(){this.element.removeClass("ui-buttonset"),this.buttons.map(function(){return a(this).button("widget")[0]}).removeClass("ui-corner-left ui-corner-right").end().button("destroy"),a.Widget.prototype.destroy.call(this)}})}(jQuery),function($,undefined){function Datepicker(){this.debug=!1,this._curInst=null,this._keyEvent=!1,this._disabledInputs=[],this._datepickerShowing=!1,this._inDialog=!1,this._mainDivId="ui-datepicker-div",this._inlineClass="ui-datepicker-inline",this._appendClass="ui-datepicker-append",this._triggerClass="ui-datepicker-trigger",this._dialogClass="ui-datepicker-dialog",this._disableClass="ui-datepicker-disabled",this._unselectableClass="ui-datepicker-unselectable",this._currentClass="ui-datepicker-current-day",this._dayOverClass="ui-datepicker-days-cell-over",this.regional=[],this.regional[""]={closeText:"Done",prevText:"Prev",nextText:"Next",currentText:"Today",monthNames:["January","February","March","April","May","June","July","August","September","October","November","December"],monthNamesShort:["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],dayNames:["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],dayNamesShort:["Sun","Mon","Tue","Wed","Thu","Fri","Sat"],dayNamesMin:["Su","Mo","Tu","We","Th","Fr","Sa"],weekHeader:"Wk",dateFormat:"mm/dd/yy",firstDay:0,isRTL:!1,showMonthAfterYear:!1,yearSuffix:""},this._defaults={showOn:"focus",showAnim:"fadeIn",showOptions:{},defaultDate:null,appendText:"",buttonText:"...",buttonImage:"",buttonImageOnly:!1,hideIfNoPrevNext:!1,navigationAsDateFormat:!1,gotoCurrent:!1,changeMonth:!1,changeYear:!1,yearRange:"c-10:c+10",showOtherMonths:!1,selectOtherMonths:!1,showWeek:!1,calculateWeek:this.iso8601Week,shortYearCutoff:"+10",minDate:null,maxDate:null,duration:"fast",beforeShowDay:null,beforeShow:null,onSelect:null,onChangeMonthYear:null,onClose:null,numberOfMonths:1,showCurrentAtPos:0,stepMonths:1,stepBigMonths:12,altField:"",altFormat:"",constrainInput:!0,showButtonPanel:!1,autoSize:!1,disabled:!1},$.extend(this._defaults,this.regional[""]),this.dpDiv=bindHover($('<div id="'+this._mainDivId+'" class="ui-datepicker ui-widget ui-widget-content ui-helper-clearfix ui-corner-all"></div>'))}function bindHover(a){var b="button, .ui-datepicker-prev, .ui-datepicker-next, .ui-datepicker-calendar td a";return a.bind("mouseout",function(a){var c=$(a.target).closest(b);if(!c.length)return;c.removeClass("ui-state-hover ui-datepicker-prev-hover ui-datepicker-next-hover")}).bind("mouseover",function(c){var d=$(c.target).closest(b);if($.datepicker._isDisabledDatepicker(instActive.inline?a.parent()[0]:instActive.input[0])||!d.length)return;d.parents(".ui-datepicker-calendar").find("a").removeClass("ui-state-hover"),d.addClass("ui-state-hover"),d.hasClass("ui-datepicker-prev")&&d.addClass("ui-datepicker-prev-hover"),d.hasClass("ui-datepicker-next")&&d.addClass("ui-datepicker-next-hover")})}function extendRemove(a,b){$.extend(a,b);for(var c in b)if(b[c]==null||b[c]==undefined)a[c]=b[c];return a}function isArray(a){return a&&($.browser.safari&&typeof a=="object"&&a.length||a.constructor&&a.constructor.toString().match(/\Array\(\)/))}$.extend($.ui,{datepicker:{version:"1.8.22"}});var PROP_NAME="datepicker",dpuuid=(new Date).getTime(),instActive;$.extend(Datepicker.prototype,{markerClassName:"hasDatepicker",maxRows:4,log:function(){this.debug&&console.log.apply("",arguments)},_widgetDatepicker:function(){return this.dpDiv},setDefaults:function(a){return extendRemove(this._defaults,a||{}),this},_attachDatepicker:function(target,settings){var inlineSettings=null;for(var attrName in this._defaults){var attrValue=target.getAttribute("date:"+attrName);if(attrValue){inlineSettings=inlineSettings||{};try{inlineSettings[attrName]=eval(attrValue)}catch(err){inlineSettings[attrName]=attrValue}}}var nodeName=target.nodeName.toLowerCase(),inline=nodeName=="div"||nodeName=="span";target.id||(this.uuid+=1,target.id="dp"+this.uuid);var inst=this._newInst($(target),inline);inst.settings=$.extend({},settings||{},inlineSettings||{}),nodeName=="input"?this._connectDatepicker(target,inst):inline&&this._inlineDatepicker(target,inst)},_newInst:function(a,b){var c=a[0].id.replace(/([^A-Za-z0-9_-])/g,"\\\\$1");return{id:c,input:a,selectedDay:0,selectedMonth:0,selectedYear:0,drawMonth:0,drawYear:0,inline:b,dpDiv:b?bindHover($('<div class="'+this._inlineClass+' ui-datepicker ui-widget ui-widget-content ui-helper-clearfix ui-corner-all"></div>')):this.dpDiv}},_connectDatepicker:function(a,b){var c=$(a);b.append=$([]),b.trigger=$([]);if(c.hasClass(this.markerClassName))return;this._attachments(c,b),c.addClass(this.markerClassName).keydown(this._doKeyDown).keypress(this._doKeyPress).keyup(this._doKeyUp).bind("setData.datepicker",function(a,c,d){b.settings[c]=d}).bind("getData.datepicker",function(a,c){return this._get(b,c)}),this._autoSize(b),$.data(a,PROP_NAME,b),b.settings.disabled&&this._disableDatepicker(a)},_attachments:function(a,b){var c=this._get(b,"appendText"),d=this._get(b,"isRTL");b.append&&b.append.remove(),c&&(b.append=$('<span class="'+this._appendClass+'">'+c+"</span>"),a[d?"before":"after"](b.append)),a.unbind("focus",this._showDatepicker),b.trigger&&b.trigger.remove();var e=this._get(b,"showOn");(e=="focus"||e=="both")&&a.focus(this._showDatepicker);if(e=="button"||e=="both"){var f=this._get(b,"buttonText"),g=this._get(b,"buttonImage");b.trigger=$(this._get(b,"buttonImageOnly")?$("<img/>").addClass(this._triggerClass).attr({src:g,alt:f,title:f}):$('<button type="button"></button>').addClass(this._triggerClass).html(g==""?f:$("<img/>").attr({src:g,alt:f,title:f}))),a[d?"before":"after"](b.trigger),b.trigger.click(function(){return $.datepicker._datepickerShowing&&$.datepicker._lastInput==a[0]?$.datepicker._hideDatepicker():$.datepicker._datepickerShowing&&$.datepicker._lastInput!=a[0]?($.datepicker._hideDatepicker(),$.datepicker._showDatepicker(a[0])):$.datepicker._showDatepicker(a[0]),!1})}},_autoSize:function(a){if(this._get(a,"autoSize")&&!a.inline){var b=new Date(2009,11,20),c=this._get(a,"dateFormat");if(c.match(/[DM]/)){var d=function(a){var b=0,c=0;for(var d=0;d<a.length;d++)a[d].length>b&&(b=a[d].length,c=d);return c};b.setMonth(d(this._get(a,c.match(/MM/)?"monthNames":"monthNamesShort"))),b.setDate(d(this._get(a,c.match(/DD/)?"dayNames":"dayNamesShort"))+20-b.getDay())}a.input.attr("size",this._formatDate(a,b).length)}},_inlineDatepicker:function(a,b){var c=$(a);if(c.hasClass(this.markerClassName))return;c.addClass(this.markerClassName).append(b.dpDiv).bind("setData.datepicker",function(a,c,d){b.settings[c]=d}).bind("getData.datepicker",function(a,c){return this._get(b,c)}),$.data(a,PROP_NAME,b),this._setDate(b,this._getDefaultDate(b),!0),this._updateDatepicker(b),this._updateAlternate(b),b.settings.disabled&&this._disableDatepicker(a),b.dpDiv.css("display","block")},_dialogDatepicker:function(a,b,c,d,e){var f=this._dialogInst;if(!f){this.uuid+=1;var g="dp"+this.uuid;this._dialogInput=$('<input type="text" id="'+g+'" style="position: absolute; top: -100px; width: 0px;"/>'),this._dialogInput.keydown(this._doKeyDown),$("body").append(this._dialogInput),f=this._dialogInst=this._newInst(this._dialogInput,!1),f.settings={},$.data(this._dialogInput[0],PROP_NAME,f)}extendRemove(f.settings,d||{}),b=b&&b.constructor==Date?this._formatDate(f,b):b,this._dialogInput.val(b),this._pos=e?e.length?e:[e.pageX,e.pageY]:null;if(!this._pos){var h=document.documentElement.clientWidth,i=document.documentElement.clientHeight,j=document.documentElement.scrollLeft||document.body.scrollLeft,k=document.documentElement.scrollTop||document.body.scrollTop;this._pos=[h/2-100+j,i/2-150+k]}return this._dialogInput.css("left",this._pos[0]+20+"px").css("top",this._pos[1]+"px"),f.settings.onSelect=c,this._inDialog=!0,this.dpDiv.addClass(this._dialogClass),this._showDatepicker(this._dialogInput[0]),$.blockUI&&$.blockUI(this.dpDiv),$.data(this._dialogInput[0],PROP_NAME,f),this},_destroyDatepicker:function(a){var b=$(a),c=$.data(a,PROP_NAME);if(!b.hasClass(this.markerClassName))return;var d=a.nodeName.toLowerCase();$.removeData(a,PROP_NAME),d=="input"?(c.append.remove(),c.trigger.remove(),b.removeClass(this.markerClassName).unbind("focus",this._showDatepicker).unbind("keydown",this._doKeyDown).unbind("keypress",this._doKeyPress).unbind("keyup",this._doKeyUp)):(d=="div"||d=="span")&&b.removeClass(this.markerClassName).empty()},_enableDatepicker:function(a){var b=$(a),c=$.data(a,PROP_NAME);if(!b.hasClass(this.markerClassName))return;var d=a.nodeName.toLowerCase();if(d=="input")a.disabled=!1,c.trigger.filter("button").each(function(){this.disabled=!1}).end().filter("img").css({opacity:"1.0",cursor:""});else if(d=="div"||d=="span"){var e=b.children("."+this._inlineClass);e.children().removeClass("ui-state-disabled"),e.find("select.ui-datepicker-month, select.ui-datepicker-year").removeAttr("disabled")}this._disabledInputs=$.map(this._disabledInputs,function(b){return b==a?null:b})},_disableDatepicker:function(a){var b=$(a),c=$.data(a,PROP_NAME);if(!b.hasClass(this.markerClassName))return;var d=a.nodeName.toLowerCase();if(d=="input")a.disabled=!0,c.trigger.filter("button").each(function(){this.disabled=!0}).end().filter("img").css({opacity:"0.5",cursor:"default"});else if(d=="div"||d=="span"){var e=b.children("."+this._inlineClass);e.children().addClass("ui-state-disabled"),e.find("select.ui-datepicker-month, select.ui-datepicker-year").attr("disabled","disabled")}this._disabledInputs=$.map(this._disabledInputs,function(b){return b==a?null:b}),this._disabledInputs[this._disabledInputs.length]=a},_isDisabledDatepicker:function(a){if(!a)return!1;for(var b=0;b<this._disabledInputs.length;b++)if(this._disabledInputs[b]==a)return!0;return!1},_getInst:function(a){try{return $.data(a,PROP_NAME)}catch(b){throw"Missing instance data for this datepicker"}},_optionDatepicker:function(a,b,c){var d=this._getInst(a);if(arguments.length==2&&typeof b=="string")return b=="defaults"?$.extend({},$.datepicker._defaults):d?b=="all"?$.extend({},d.settings):this._get(d,b):null;var e=b||{};typeof b=="string"&&(e={},e[b]=c);if(d){this._curInst==d&&this._hideDatepicker();var f=this._getDateDatepicker(a,!0),g=this._getMinMaxDate(d,"min"),h=this._getMinMaxDate(d,"max");extendRemove(d.settings,e),g!==null&&e.dateFormat!==undefined&&e.minDate===undefined&&(d.settings.minDate=this._formatDate(d,g)),h!==null&&e.dateFormat!==undefined&&e.maxDate===undefined&&(d.settings.maxDate=this._formatDate(d,h)),this._attachments($(a),d),this._autoSize(d),this._setDate(d,f),this._updateAlternate(d),this._updateDatepicker(d)}},_changeDatepicker:function(a,b,c){this._optionDatepicker(a,b,c)},_refreshDatepicker:function(a){var b=this._getInst(a);b&&this._updateDatepicker(b)},_setDateDatepicker:function(a,b){var c=this._getInst(a);c&&(this._setDate(c,b),this._updateDatepicker(c),this._updateAlternate(c))},_getDateDatepicker:function(a,b){var c=this._getInst(a);return c&&!c.inline&&this._setDateFromField(c,b),c?this._getDate(c):null},_doKeyDown:function(a){var b=$.datepicker._getInst(a.target),c=!0,d=b.dpDiv.is(".ui-datepicker-rtl");b._keyEvent=!0;if($.datepicker._datepickerShowing)switch(a.keyCode){case 9:$.datepicker._hideDatepicker(),c=!1;break;case 13:var e=$("td."+$.datepicker._dayOverClass+":not(."+$.datepicker._currentClass+")",b.dpDiv);e[0]&&$.datepicker._selectDay(a.target,b.selectedMonth,b.selectedYear,e[0]);var f=$.datepicker._get(b,"onSelect");if(f){var g=$.datepicker._formatDate(b);f.apply(b.input?b.input[0]:null,[g,b])}else $.datepicker._hideDatepicker();return!1;case 27:$.datepicker._hideDatepicker();break;case 33:$.datepicker._adjustDate(a.target,a.ctrlKey?-$.datepicker._get(b,"stepBigMonths"):-$.datepicker._get(b,"stepMonths"),"M");break;case 34:$.datepicker._adjustDate(a.target,a.ctrlKey?+$.datepicker._get(b,"stepBigMonths"):+$.datepicker._get(b,"stepMonths"),"M");break;case 35:(a.ctrlKey||a.metaKey)&&$.datepicker._clearDate(a.target),c=a.ctrlKey||a.metaKey;break;case 36:(a.ctrlKey||a.metaKey)&&$.datepicker._gotoToday(a.target),c=a.ctrlKey||a.metaKey;break;case 37:(a.ctrlKey||a.metaKey)&&$.datepicker._adjustDate(a.target,d?1:-1,"D"),c=a.ctrlKey||a.metaKey,a.originalEvent.altKey&&$.datepicker._adjustDate(a.target,a.ctrlKey?-$.datepicker._get(b,"stepBigMonths"):-$.datepicker._get(b,"stepMonths"),"M");break;case 38:(a.ctrlKey||a.metaKey)&&$.datepicker._adjustDate(a.target,-7,"D"),c=a.ctrlKey||a.metaKey;break;case 39:(a.ctrlKey||a.metaKey)&&$.datepicker._adjustDate(a.target,d?-1:1,"D"),c=a.ctrlKey||a.metaKey,a.originalEvent.altKey&&$.datepicker._adjustDate(a.target,a.ctrlKey?+$.datepicker._get(b,"stepBigMonths"):+$.datepicker._get(b,"stepMonths"),"M");break;case 40:(a.ctrlKey||a.metaKey)&&$.datepicker._adjustDate(a.target,7,"D"),c=a.ctrlKey||a.metaKey;break;default:c=!1}else a.keyCode==36&&a.ctrlKey?$.datepicker._showDatepicker(this):c=!1;c&&(a.preventDefault(),a.stopPropagation())},_doKeyPress:function(a){var b=$.datepicker._getInst(a.target);if($.datepicker._get(b,"constrainInput")){var c=$.datepicker._possibleChars($.datepicker._get(b,"dateFormat")),d=String.fromCharCode(a.charCode==undefined?a.keyCode:a.charCode);return a.ctrlKey||a.metaKey||d<" "||!c||c.indexOf(d)>-1}},_doKeyUp:function(a){var b=$.datepicker._getInst(a.target);if(b.input.val()!=b.lastVal)try{var c=$.datepicker.parseDate($.datepicker._get(b,"dateFormat"),b.input?b.input.val():null,$.datepicker._getFormatConfig(b));c&&($.datepicker._setDateFromField(b),$.datepicker._updateAlternate(b),$.datepicker._updateDatepicker(b))}catch(d){$.datepicker.log(d)}return!0},_showDatepicker:function(a){a=a.target||a,a.nodeName.toLowerCase()!="input"&&(a=$("input",a.parentNode)[0]);if($.datepicker._isDisabledDatepicker(a)||$.datepicker._lastInput==a)return;var b=$.datepicker._getInst(a);$.datepicker._curInst&&$.datepicker._curInst!=b&&($.datepicker._curInst.dpDiv.stop(!0,!0),b&&$.datepicker._datepickerShowing&&$.datepicker._hideDatepicker($.datepicker._curInst.input[0]));var c=$.datepicker._get(b,"beforeShow"),d=c?c.apply(a,[a,b]):{};if(d===!1)return;extendRemove(b.settings,d),b.lastVal=null,$.datepicker._lastInput=a,$.datepicker._setDateFromField(b),$.datepicker._inDialog&&(a.value=""),$.datepicker._pos||($.datepicker._pos=$.datepicker._findPos(a),$.datepicker._pos[1]+=a.offsetHeight);var e=!1;$(a).parents().each(function(){return e|=$(this).css("position")=="fixed",!e}),e&&$.browser.opera&&($.datepicker._pos[0]-=document.documentElement.scrollLeft,$.datepicker._pos[1]-=document.documentElement.scrollTop);var f={left:$.datepicker._pos[0],top:$.datepicker._pos[1]};$.datepicker._pos=null,b.dpDiv.empty(),b.dpDiv.css({position:"absolute",display:"block",top:"-1000px"}),$.datepicker._updateDatepicker(b),f=$.datepicker._checkOffset(b,f,e),b.dpDiv.css({position:$.datepicker._inDialog&&$.blockUI?"static":e?"fixed":"absolute",display:"none",left:f.left+"px",top:f.top+"px"});if(!b.inline){var g=$.datepicker._get(b,"showAnim"),h=$.datepicker._get(b,"duration"),i=function(){var a=b.dpDiv.find("iframe.ui-datepicker-cover");if(!!a.length){var c=$.datepicker._getBorders(b.dpDiv);a.css({left:-c[0],top:-c[1],width:b.dpDiv.outerWidth(),height:b.dpDiv.outerHeight()})}};b.dpDiv.zIndex($(a).zIndex()+1),$.datepicker._datepickerShowing=!0,$.effects&&$.effects[g]?b.dpDiv.show(g,$.datepicker._get(b,"showOptions"),h,i):b.dpDiv[g||"show"](g?h:null,i),(!g||!h)&&i(),b.input.is(":visible")&&!b.input.is(":disabled")&&b.input.focus(),$.datepicker._curInst=b}},_updateDatepicker:function(a){var b=this;b.maxRows=4;var c=$.datepicker._getBorders(a.dpDiv);instActive=a,a.dpDiv.empty().append(this._generateHTML(a)),this._attachHandlers(a);var d=a.dpDiv.find("iframe.ui-datepicker-cover");!d.length||d.css({left:-c[0],top:-c[1],width:a.dpDiv.outerWidth(),height:a.dpDiv.outerHeight()}),a.dpDiv.find("."+this._dayOverClass+" a").mouseover();var e=this._getNumberOfMonths(a),f=e[1],g=17;a.dpDiv.removeClass("ui-datepicker-multi-2 ui-datepicker-multi-3 ui-datepicker-multi-4").width(""),f>1&&a.dpDiv.addClass("ui-datepicker-multi-"+f).css("width",g*f+"em"),a.dpDiv[(e[0]!=1||e[1]!=1?"add":"remove")+"Class"]("ui-datepicker-multi"),a.dpDiv[(this._get(a,"isRTL")?"add":"remove")+"Class"]("ui-datepicker-rtl"),a==$.datepicker._curInst&&$.datepicker._datepickerShowing&&a.input&&a.input.is(":visible")&&!a.input.is(":disabled")&&a.input[0]!=document.activeElement&&a.input.focus();if(a.yearshtml){var h=a.yearshtml;setTimeout(function(){h===a.yearshtml&&a.yearshtml&&a.dpDiv.find("select.ui-datepicker-year:first").replaceWith(a.yearshtml),h=a.yearshtml=null},0)}},_getBorders:function(a){var b=function(a){return{thin:1,medium:2,thick:3}[a]||a};return[parseFloat(b(a.css("border-left-width"))),parseFloat(b(a.css("border-top-width")))]},_checkOffset:function(a,b,c){var d=a.dpDiv.outerWidth(),e=a.dpDiv.outerHeight(),f=a.input?a.input.outerWidth():0,g=a.input?a.input.outerHeight():0,h=document.documentElement.clientWidth+(c?0:$(document).scrollLeft()),i=document.documentElement.clientHeight+(c?0:$(document).scrollTop());return b.left-=this._get(a,"isRTL")?d-f:0,b.left-=c&&b.left==a.input.offset().left?$(document).scrollLeft():0,b.top-=c&&b.top==a.input.offset().top+g?$(document).scrollTop():0,b.left-=Math.min(b.left,b.left+d>h&&h>d?Math.abs(b.left+d-h):0),b.top-=Math.min(b.top,b.top+e>i&&i>e?Math.abs(e+g):0),b},_findPos:function(a){var b=this._getInst(a),c=this._get(b,"isRTL");while(a&&(a.type=="hidden"||a.nodeType!=1||$.expr.filters.hidden(a)))a=a[c?"previousSibling":"nextSibling"];var d=$(a).offset();return[d.left,d.top]},_hideDatepicker:function(a){var b=this._curInst;if(!b||a&&b!=$.data(a,PROP_NAME))return;if(this._datepickerShowing){var c=this._get(b,"showAnim"),d=this._get(b,"duration"),e=function(){$.datepicker._tidyDialog(b)};$.effects&&$.effects[c]?b.dpDiv.hide(c,$.datepicker._get(b,"showOptions"),d,e):b.dpDiv[c=="slideDown"?"slideUp":c=="fadeIn"?"fadeOut":"hide"](c?d:null,e),c||e(),this._datepickerShowing=!1;var f=this._get(b,"onClose");f&&f.apply(b.input?b.input[0]:null,[b.input?b.input.val():"",b]),this._lastInput=null,this._inDialog&&(this._dialogInput.css({position:"absolute",left:"0",top:"-100px"}),$.blockUI&&($.unblockUI(),$("body").append(this.dpDiv))),this._inDialog=!1}},_tidyDialog:function(a){a.dpDiv.removeClass(this._dialogClass).unbind(".ui-datepicker-calendar")},_checkExternalClick:function(a){if(!$.datepicker._curInst)return;var b=$(a.target),c=$.datepicker._getInst(b[0]);(b[0].id!=$.datepicker._mainDivId&&b.parents("#"+$.datepicker._mainDivId).length==0&&!b.hasClass($.datepicker.markerClassName)&&!b.closest("."+$.datepicker._triggerClass).length&&$.datepicker._datepickerShowing&&(!$.datepicker._inDialog||!$.blockUI)||b.hasClass($.datepicker.markerClassName)&&$.datepicker._curInst!=c)&&$.datepicker._hideDatepicker()},_adjustDate:function(a,b,c){var d=$(a),e=this._getInst(d[0]);if(this._isDisabledDatepicker(d[0]))return;this._adjustInstDate(e,b+(c=="M"?this._get(e,"showCurrentAtPos"):0),c),this._updateDatepicker(e)},_gotoToday:function(a){var b=$(a),c=this._getInst(b[0]);if(this._get(c,"gotoCurrent")&&c.currentDay)c.selectedDay=c.currentDay,c.drawMonth=c.selectedMonth=c.currentMonth,c.drawYear=c.selectedYear=c.currentYear;else{var d=new Date;c.selectedDay=d.getDate(),c.drawMonth=c.selectedMonth=d.getMonth(),c.drawYear=c.selectedYear=d.getFullYear()}this._notifyChange(c),this._adjustDate(b)},_selectMonthYear:function(a,b,c){var d=$(a),e=this._getInst(d[0]);e["selected"+(c=="M"?"Month":"Year")]=e["draw"+(c=="M"?"Month":"Year")]=parseInt(b.options[b.selectedIndex].value,10),this._notifyChange(e),this._adjustDate(d)},_selectDay:function(a,b,c,d){var e=$(a);if($(d).hasClass(this._unselectableClass)||this._isDisabledDatepicker(e[0]))return;var f=this._getInst(e[0]);f.selectedDay=f.currentDay=$("a",d).html(),f.selectedMonth=f.currentMonth=b,f.selectedYear=f.currentYear=c,this._selectDate(a,this._formatDate(f,f.currentDay,f.currentMonth,f.currentYear))},_clearDate:function(a){var b=$(a),c=this._getInst(b[0]);this._selectDate(b,"")},_selectDate:function(a,b){var c=$(a),d=this._getInst(c[0]);b=b!=null?b:this._formatDate(d),d.input&&d.input.val(b),this._updateAlternate(d);var e=this._get(d,"onSelect");e?e.apply(d.input?d.input[0]:null,[b,d]):d.input&&d.input.trigger("change"),d.inline?this._updateDatepicker(d):(this._hideDatepicker(),this._lastInput=d.input[0],typeof d.input[0]!="object"&&d.input.focus(),this._lastInput=null)},_updateAlternate:function(a){var b=this._get(a,"altField");if(b){var c=this._get(a,"altFormat")||this._get(a,"dateFormat"),d=this._getDate(a),e=this.formatDate(c,d,this._getFormatConfig(a));$(b).each(function(){$(this).val(e)})}},noWeekends:function(a){var b=a.getDay();return[b>0&&b<6,""]},iso8601Week:function(a){var b=new Date(a.getTime());b.setDate(b.getDate()+4-(b.getDay()||7));var c=b.getTime();return b.setMonth(0),b.setDate(1),Math.floor(Math.round((c-b)/864e5)/7)+1},parseDate:function(a,b,c){if(a==null||b==null)throw"Invalid arguments";b=typeof b=="object"?b.toString():b+"";if(b=="")return null;var d=(c?c.shortYearCutoff:null)||this._defaults.shortYearCutoff;d=typeof d!="string"?d:(new Date).getFullYear()%100+parseInt(d,10);var e=(c?c.dayNamesShort:null)||this._defaults.dayNamesShort,f=(c?c.dayNames:null)||this._defaults.dayNames,g=(c?c.monthNamesShort:null)||this._defaults.monthNamesShort,h=(c?c.monthNames:null)||this._defaults.monthNames,i=-1,j=-1,k=-1,l=-1,m=!1,n=function(b){var c=s+1<a.length&&a.charAt(s+1)==b;return c&&s++,c},o=function(a){var c=n(a),d=a=="@"?14:a=="!"?20:a=="y"&&c?4:a=="o"?3:2,e=new RegExp("^\\d{1,"+d+"}"),f=b.substring(r).match(e);if(!f)throw"Missing number at position "+r;return r+=f[0].length,parseInt(f[0],10)},p=function(a,c,d){var e=$.map(n(a)?d:c,function(a,b){return[[b,a]]}).sort(function(a,b){return-(a[1].length-b[1].length)}),f=-1;$.each(e,function(a,c){var d=c[1];if(b.substr(r,d.length).toLowerCase()==d.toLowerCase())return f=c[0],r+=d.length,!1});if(f!=-1)return f+1;throw"Unknown name at position "+r},q=function(){if(b.charAt(r)!=a.charAt(s))throw"Unexpected literal at position "+r;r++},r=0;for(var s=0;s<a.length;s++)if(m)a.charAt(s)=="'"&&!n("'")?m=!1:q();else switch(a.charAt(s)){case"d":k=o("d");break;case"D":p("D",e,f);break;case"o":l=o("o");break;case"m":j=o("m");break;case"M":j=p("M",g,h);break;case"y":i=o("y");break;case"@":var t=new Date(o("@"));i=t.getFullYear(),j=t.getMonth()+1,k=t.getDate();break;case"!":var t=new Date((o("!")-this._ticksTo1970)/1e4);i=t.getFullYear(),j=t.getMonth()+1,k=t.getDate();break;case"'":n("'")?q():m=!0;break;default:q()}if(r<b.length)throw"Extra/unparsed characters found in date: "+b.substring(r);i==-1?i=(new Date).getFullYear():i<100&&(i+=(new Date).getFullYear()-(new Date).getFullYear()%100+(i<=d?0:-100));if(l>-1){j=1,k=l;do{var u=this._getDaysInMonth(i,j-1);if(k<=u)break;j++,k-=u}while(!0)}var t=this._daylightSavingAdjust(new Date(i,j-1,k));if(t.getFullYear()!=i||t.getMonth()+1!=j||t.getDate()!=k)throw"Invalid date";return t},ATOM:"yy-mm-dd",COOKIE:"D, dd M yy",ISO_8601:"yy-mm-dd",RFC_822:"D, d M y",RFC_850:"DD, dd-M-y",RFC_1036:"D, d M y",RFC_1123:"D, d M yy",RFC_2822:"D, d M yy",RSS:"D, d M y",TICKS:"!",TIMESTAMP:"@",W3C:"yy-mm-dd",_ticksTo1970:(718685+Math.floor(492.5)-Math.floor(19.7)+Math.floor(4.925))*24*60*60*1e7,formatDate:function(a,b,c){if(!b)return"";var d=(c?c.dayNamesShort:null)||this._defaults.dayNamesShort,e=(c?c.dayNames:null)||this._defaults.dayNames,f=(c?c.monthNamesShort:null)||this._defaults.monthNamesShort,g=(c?c.monthNames:null)||this._defaults.monthNames,h=function(b){var c=m+1<a.length&&a.charAt(m+1)==b;return c&&m++,c},i=function(a,b,c){var d=""+b;if(h(a))while(d.length<c)d="0"+d;return d},j=function(a,b,c,d){return h(a)?d[b]:c[b]},k="",l=!1;if(b)for(var m=0;m<a.length;m++)if(l)a.charAt(m)=="'"&&!h("'")?l=!1:k+=a.charAt(m);else switch(a.charAt(m)){case"d":k+=i("d",b.getDate(),2);break;case"D":k+=j("D",b.getDay(),d,e);break;case"o":k+=i("o",Math.round(((new Date(b.getFullYear(),b.getMonth(),b.getDate())).getTime()-(new Date(b.getFullYear(),0,0)).getTime())/864e5),3);break;case"m":k+=i("m",b.getMonth()+1,2);break;case"M":k+=j("M",b.getMonth(),f,g);break;case"y":k+=h("y")?b.getFullYear():(b.getYear()%100<10?"0":"")+b.getYear()%100;break;case"@":k+=b.getTime();break;case"!":k+=b.getTime()*1e4+this._ticksTo1970;break;case"'":h("'")?k+="'":l=!0;break;default:k+=a.charAt(m)}return k},_possibleChars:function(a){var b="",c=!1,d=function(b){var c=e+1<a.length&&a.charAt(e+1)==b;return c&&e++,c};for(var e=0;e<a.length;e++)if(c)a.charAt(e)=="'"&&!d("'")?c=!1:b+=a.charAt(e);else switch(a.charAt(e)){case"d":case"m":case"y":case"@":b+="0123456789";break;case"D":case"M":return null;case"'":d("'")?b+="'":c=!0;break;default:b+=a.charAt(e)}return b},_get:function(a,b){return a.settings[b]!==undefined?a.settings[b]:this._defaults[b]},_setDateFromField:function(a,b){if(a.input.val()==a.lastVal)return;var c=this._get(a,"dateFormat"),d=a.lastVal=a.input?a.input.val():null,e,f;e=f=this._getDefaultDate(a);var g=this._getFormatConfig(a);try{e=this.parseDate(c,d,g)||f}catch(h){this.log(h),d=b?"":d}a.selectedDay=e.getDate(),a.drawMonth=a.selectedMonth=e.getMonth(),a.drawYear=a.selectedYear=e.getFullYear(),a.currentDay=d?e.getDate():0,a.currentMonth=d?e.getMonth():0,a.currentYear=d?e.getFullYear():0,this._adjustInstDate(a)},_getDefaultDate:function(a){return this._restrictMinMax(a,this._determineDate(a,this._get(a,"defaultDate"),new Date))},_determineDate:function(a,b,c){var d=function(a){var b=new Date;return b.setDate(b.getDate()+a),b},e=function(b){try{return $.datepicker.parseDate($.datepicker._get(a,"dateFormat"),b,$.datepicker._getFormatConfig(a))}catch(c){}var d=(b.toLowerCase().match(/^c/)?$.datepicker._getDate(a):null)||new Date,e=d.getFullYear(),f=d.getMonth(),g=d.getDate(),h=/([+-]?[0-9]+)\s*(d|D|w|W|m|M|y|Y)?/g,i=h.exec(b);while(i){switch(i[2]||"d"){case"d":case"D":g+=parseInt(i[1],10);break;case"w":case"W":g+=parseInt(i[1],10)*7;break;case"m":case"M":f+=parseInt(i[1],10),g=Math.min(g,$.datepicker._getDaysInMonth(e,f));break;case"y":case"Y":e+=parseInt(i[1],10),g=Math.min(g,$.datepicker._getDaysInMonth(e,f))}i=h.exec(b)}return new Date(e,f,g)},f=b==null||b===""?c:typeof b=="string"?e(b):typeof b=="number"?isNaN(b)?c:d(b):new Date(b.getTime());return f=f&&f.toString()=="Invalid Date"?c:f,f&&(f.setHours(0),f.setMinutes(0),f.setSeconds(0),f.setMilliseconds(0)),this._daylightSavingAdjust(f)},_daylightSavingAdjust:function(a){return a?(a.setHours(a.getHours()>12?a.getHours()+2:0),a):null},_setDate:function(a,b,c){var d=!b,e=a.selectedMonth,f=a.selectedYear,g=this._restrictMinMax(a,this._determineDate(a,b,new Date));a.selectedDay=a.currentDay=g.getDate(),a.drawMonth=a.selectedMonth=a.currentMonth=g.getMonth(),a.drawYear=a.selectedYear=a.currentYear=g.getFullYear(),(e!=a.selectedMonth||f!=a.selectedYear)&&!c&&this._notifyChange(a),this._adjustInstDate(a),a.input&&a.input.val(d?"":this._formatDate(a))},_getDate:function(a){var b=!a.currentYear||a.input&&a.input.val()==""?null:this._daylightSavingAdjust(new Date(a.currentYear,a.currentMonth,a.currentDay));return b},_attachHandlers:function(a){var b=this._get(a,"stepMonths"),c="#"+a.id;a.dpDiv.find("[data-handler]").map(function(){var a={prev:function(){window["DP_jQuery_"+dpuuid].datepicker._adjustDate(c,-b,"M")},next:function(){window["DP_jQuery_"+dpuuid].datepicker._adjustDate(c,+b,"M")},hide:function(){window["DP_jQuery_"+dpuuid].datepicker._hideDatepicker()},today:function(){window["DP_jQuery_"+dpuuid].datepicker._gotoToday(c)},selectDay:function(){return window["DP_jQuery_"+dpuuid].datepicker._selectDay(c,+this.getAttribute("data-month"),+this.getAttribute("data-year"),this),!1},selectMonth:function(){return window["DP_jQuery_"+dpuuid].datepicker._selectMonthYear(c,this,"M"),!1},selectYear:function(){return window["DP_jQuery_"+dpuuid].datepicker._selectMonthYear(c,this,"Y"),!1}};$(this).bind(this.getAttribute("data-event"),a[this.getAttribute("data-handler")])})},_generateHTML:function(a){var b=new Date;b=this._daylightSavingAdjust(new Date(b.getFullYear(),b.getMonth(),b.getDate()));var c=this._get(a,"isRTL"),d=this._get(a,"showButtonPanel"),e=this._get(a,"hideIfNoPrevNext"),f=this._get(a,"navigationAsDateFormat"),g=this._getNumberOfMonths(a),h=this._get(a,"showCurrentAtPos"),i=this._get(a,"stepMonths"),j=g[0]!=1||g[1]!=1,k=this._daylightSavingAdjust(a.currentDay?new Date(a.currentYear,a.currentMonth,a.currentDay):new Date(9999,9,9)),l=this._getMinMaxDate(a,"min"),m=this._getMinMaxDate(a,"max"),n=a.drawMonth-h,o=a.drawYear;n<0&&(n+=12,o--);if(m){var p=this._daylightSavingAdjust(new Date(m.getFullYear(),m.getMonth()-g[0]*g[1]+1,m.getDate()));p=l&&p<l?l:p;while(this._daylightSavingAdjust(new Date(o,n,1))>p)n--,n<0&&(n=11,o--)}a.drawMonth=n,a.drawYear=o;var q=this._get(a,"prevText");q=f?this.formatDate(q,this._daylightSavingAdjust(new Date(o,n-i,1)),this._getFormatConfig(a)):q;var r=this._canAdjustMonth(a,-1,o,n)?'<a class="ui-datepicker-prev ui-corner-all" data-handler="prev" data-event="click" title="'+q+'"><span class="ui-icon ui-icon-circle-triangle-'+(c?"e":"w")+'">'+q+"</span></a>":e?"":'<a class="ui-datepicker-prev ui-corner-all ui-state-disabled" title="'+q+'"><span class="ui-icon ui-icon-circle-triangle-'+(c?"e":"w")+'">'+q+"</span></a>",s=this._get(a,"nextText");s=f?this.formatDate(s,this._daylightSavingAdjust(new Date(o,n+i,1)),this._getFormatConfig(a)):s;var t=this._canAdjustMonth(a,1,o,n)?'<a class="ui-datepicker-next ui-corner-all" data-handler="next" data-event="click" title="'+s+'"><span class="ui-icon ui-icon-circle-triangle-'+(c?"w":"e")+'">'+s+"</span></a>":e?"":'<a class="ui-datepicker-next ui-corner-all ui-state-disabled" title="'+s+'"><span class="ui-icon ui-icon-circle-triangle-'+(c?"w":"e")+'">'+s+"</span></a>",u=this._get(a,"currentText"),v=this._get(a,"gotoCurrent")&&a.currentDay?k:b;u=f?this.formatDate(u,v,this._getFormatConfig(a)):u;var w=a.inline?"":'<button type="button" class="ui-datepicker-close ui-state-default ui-priority-primary ui-corner-all" data-handler="hide" data-event="click">'+this._get(a,"closeText")+"</button>",x=d?'<div class="ui-datepicker-buttonpane ui-widget-content">'+(c?w:"")+(this._isInRange(a,v)?'<button type="button" class="ui-datepicker-current ui-state-default ui-priority-secondary ui-corner-all" data-handler="today" data-event="click">'+u+"</button>":"")+(c?"":w)+"</div>":"",y=parseInt(this._get(a,"firstDay"),10);y=isNaN(y)?0:y;var z=this._get(a,"showWeek"),A=this._get(a,"dayNames"),B=this._get(a,"dayNamesShort"),C=this._get(a,"dayNamesMin"),D=this._get(a,"monthNames"),E=this._get(a,"monthNamesShort"),F=this._get(a,"beforeShowDay"),G=this._get(a,"showOtherMonths"),H=this._get(a,"selectOtherMonths"),I=this._get(a,"calculateWeek")||this.iso8601Week,J=this._getDefaultDate(a),K="";for(var L=0;L<g[0];L++){var M="";this.maxRows=4;for(var N=0;N<g[1];N++){var O=this._daylightSavingAdjust(new Date(o,n,a.selectedDay)),P=" ui-corner-all",Q="";if(j){Q+='<div class="ui-datepicker-group';if(g[1]>1)switch(N){case 0:Q+=" ui-datepicker-group-first",P=" ui-corner-"+(c?"right":"left");break;case g[1]-1:Q+=" ui-datepicker-group-last",P=" ui-corner-"+(c?"left":"right");break;default:Q+=" ui-datepicker-group-middle",P=""}Q+='">'}Q+='<div class="ui-datepicker-header ui-widget-header ui-helper-clearfix'+P+'">'+(/all|left/.test(P)&&L==0?c?t:r:"")+(/all|right/.test(P)&&L==0?c?r:t:"")+this._generateMonthYearHeader(a,n,o,l,m,L>0||N>0,D,E)+'</div><table class="ui-datepicker-calendar"><thead>'+"<tr>";var R=z?'<th class="ui-datepicker-week-col">'+this._get(a,"weekHeader")+"</th>":"";for(var S=0;S<7;S++){var T=(S+y)%7;R+="<th"+((S+y+6)%7>=5?' class="ui-datepicker-week-end"':"")+">"+'<span title="'+A[T]+'">'+C[T]+"</span></th>"}Q+=R+"</tr></thead><tbody>";var U=this._getDaysInMonth(o,n);o==a.selectedYear&&n==a.selectedMonth&&(a.selectedDay=Math.min(a.selectedDay,U));var V=(this._getFirstDayOfMonth(o,n)-y+7)%7,W=Math.ceil((V+U)/7),X=j?this.maxRows>W?this.maxRows:W:W;this.maxRows=X;var Y=this._daylightSavingAdjust(new Date(o,n,1-V));for(var Z=0;Z<X;Z++){Q+="<tr>";var _=z?'<td class="ui-datepicker-week-col">'+this._get(a,"calculateWeek")(Y)+"</td>":"";for(var S=0;S<7;S++){var ba=F?F.apply(a.input?a.input[0]:null,[Y]):[!0,""],bb=Y.getMonth()!=n,bc=bb&&!H||!ba[0]||l&&Y<l||m&&Y>m;_+='<td class="'+((S+y+6)%7>=5?" ui-datepicker-week-end":"")+(bb?" ui-datepicker-other-month":"")+(Y.getTime()==O.getTime()&&n==a.selectedMonth&&a._keyEvent||J.getTime()==Y.getTime()&&J.getTime()==O.getTime()?" "+this._dayOverClass:"")+(bc?" "+this._unselectableClass+" ui-state-disabled":"")+(bb&&!G?"":" "+ba[1]+(Y.getTime()==k.getTime()?" "+this._currentClass:"")+(Y.getTime()==b.getTime()?" ui-datepicker-today":""))+'"'+((!bb||G)&&ba[2]?' title="'+ba[2]+'"':"")+(bc?"":' data-handler="selectDay" data-event="click" data-month="'+Y.getMonth()+'" data-year="'+Y.getFullYear()+'"')+">"+(bb&&!G?"&#xa0;":bc?'<span class="ui-state-default">'+Y.getDate()+"</span>":'<a class="ui-state-default'+(Y.getTime()==b.getTime()?" ui-state-highlight":"")+(Y.getTime()==k.getTime()?" ui-state-active":"")+(bb?" ui-priority-secondary":"")+'" href="#">'+Y.getDate()+"</a>")+"</td>",Y.setDate(Y.getDate()+1),Y=this._daylightSavingAdjust(Y)}Q+=_+"</tr>"}n++,n>11&&(n=0,o++),Q+="</tbody></table>"+(j?"</div>"+(g[0]>0&&N==g[1]-1?'<div class="ui-datepicker-row-break"></div>':""):""),M+=Q}K+=M}return K+=x+($.browser.msie&&parseInt($.browser.version,10)<7&&!a.inline?'<iframe src="javascript:false;" class="ui-datepicker-cover" frameborder="0"></iframe>':""),a._keyEvent=!1,K},_generateMonthYearHeader:function(a,b,c,d,e,f,g,h){var i=this._get(a,"changeMonth"),j=this._get(a,"changeYear"),k=this._get(a,"showMonthAfterYear"),l='<div class="ui-datepicker-title">',m="";if(f||!i)m+='<span class="ui-datepicker-month">'+g[b]+"</span>";else{var n=d&&d.getFullYear()==c,o=e&&e.getFullYear()==c;m+='<select class="ui-datepicker-month" data-handler="selectMonth" data-event="change">';for(var p=0;p<12;p++)(!n||p>=d.getMonth())&&(!o||p<=e.getMonth())&&(m+='<option value="'+p+'"'+(p==b?' selected="selected"':"")+">"+h[p]+"</option>");m+="</select>"}k||(l+=m+(f||!i||!j?"&#xa0;":""));if(!a.yearshtml){a.yearshtml="";if(f||!j)l+='<span class="ui-datepicker-year">'+c+"</span>";else{var q=this._get(a,"yearRange").split(":"),r=(new Date).getFullYear(),s=function(a){var b=a.match(/c[+-].*/)?c+parseInt(a.substring(1),10):a.match(/[+-].*/)?r+parseInt(a,10):parseInt(a,10);return isNaN(b)?r:b},t=s(q[0]),u=Math.max(t,s(q[1]||""));t=d?Math.max(t,d.getFullYear()):t,u=e?Math.min(u,e.getFullYear()):u,a.yearshtml+='<select class="ui-datepicker-year" data-handler="selectYear" data-event="change">';for(;t<=u;t++)a.yearshtml+='<option value="'+t+'"'+(t==c?' selected="selected"':"")+">"+t+"</option>";a.yearshtml+="</select>",l+=a.yearshtml,a.yearshtml=null}}return l+=this._get(a,"yearSuffix"),k&&(l+=(f||!i||!j?"&#xa0;":"")+m),l+="</div>",l},_adjustInstDate:function(a,b,c){var d=a.drawYear+(c=="Y"?b:0),e=a.drawMonth+(c=="M"?b:0),f=Math.min(a.selectedDay,this._getDaysInMonth(d,e))+(c=="D"?b:0),g=this._restrictMinMax(a,this._daylightSavingAdjust(new Date(d,e,f)));a.selectedDay=g.getDate(),a.drawMonth=a.selectedMonth=g.getMonth(),a.drawYear=a.selectedYear=g.getFullYear(),(c=="M"||c=="Y")&&this._notifyChange(a)},_restrictMinMax:function(a,b){var c=this._getMinMaxDate(a,"min"),d=this._getMinMaxDate(a,"max"),e=c&&b<c?c:b;return e=d&&e>d?d:e,e},_notifyChange:function(a){var b=this._get(a,"onChangeMonthYear");b&&b.apply(a.input?a.input[0]:null,[a.selectedYear,a.selectedMonth+1,a])},_getNumberOfMonths:function(a){var b=this._get(a,"numberOfMonths");return b==null?[1,1]:typeof b=="number"?[1,b]:b},_getMinMaxDate:function(a,b){return this._determineDate(a,this._get(a,b+"Date"),null)},_getDaysInMonth:function(a,b){return 32-this._daylightSavingAdjust(new Date(a,b,32)).getDate()},_getFirstDayOfMonth:function(a,b){return(new Date(a,b,1)).getDay()},_canAdjustMonth:function(a,b,c,d){var e=this._getNumberOfMonths(a),f=this._daylightSavingAdjust(new Date(c,d+(b<0?b:e[0]*e[1]),1));return b<0&&f.setDate(this._getDaysInMonth(f.getFullYear(),f.getMonth())),this._isInRange(a,f)},_isInRange:function(a,b){var c=this._getMinMaxDate(a,"min"),d=this._getMinMaxDate(a,"max");return(!c||b.getTime()>=c.getTime())&&(!d||b.getTime()<=d.getTime())},_getFormatConfig:function(a){var b=this._get(a,"shortYearCutoff");return b=typeof b!="string"?b:(new Date).getFullYear()%100+parseInt(b,10),{shortYearCutoff:b,dayNamesShort:this._get(a,"dayNamesShort"),dayNames:this._get(a,"dayNames"),monthNamesShort:this._get(a,"monthNamesShort"),monthNames:this._get(a,"monthNames")}},_formatDate:function(a,b,c,d){b||(a.currentDay=a.selectedDay,a.currentMonth=a.selectedMonth,a.currentYear=a.selectedYear);var e=b?typeof b=="object"?b:this._daylightSavingAdjust(new Date(d,c,b)):this._daylightSavingAdjust(new Date(a.currentYear,a.currentMonth,a.currentDay));return this.formatDate(this._get(a,"dateFormat"),e,this._getFormatConfig(a))}}),$.fn.datepicker=function(a){if(!this.length)return this;$.datepicker.initialized||($(document).mousedown($.datepicker._checkExternalClick).find("body").append($.datepicker.dpDiv),$.datepicker.initialized=!0);var b=Array.prototype.slice.call(arguments,1);return typeof a!="string"||a!="isDisabled"&&a!="getDate"&&a!="widget"?a=="option"&&arguments.length==2&&typeof arguments[1]=="string"?$.datepicker["_"+a+"Datepicker"].apply($.datepicker,[this[0]].concat(b)):this.each(function(){typeof a=="string"?$.datepicker["_"+a+"Datepicker"].apply($.datepicker,[this].concat(b)):$.datepicker._attachDatepicker(this,a)}):$.datepicker["_"+a+"Datepicker"].apply($.datepicker,[this[0]].concat(b))},$.datepicker=new Datepicker,$.datepicker.initialized=!1,$.datepicker.uuid=(new Date).getTime(),$.datepicker.version="1.8.22",window["DP_jQuery_"+dpuuid]=$}(jQuery),function(a,b){var c="ui-dialog ui-widget ui-widget-content ui-corner-all ",d={buttons:!0,height:!0,maxHeight:!0,maxWidth:!0,minHeight:!0,minWidth:!0,width:!0},e={maxHeight:!0,maxWidth:!0,minHeight:!0,minWidth:!0},f=a.attrFn||{val:!0,css:!0,html:!0,text:!0,data:!0,width:!0,height:!0,offset:!0,click:!0};a.widget("ui.dialog",{options:{autoOpen:!0,buttons:{},closeOnEscape:!0,closeText:"close",dialogClass:"",draggable:!0,hide:null,height:"auto",maxHeight:!1,maxWidth:!1,minHeight:150,minWidth:150,modal:!1,position:{my:"center",at:"center",collision:"fit",using:function(b){var c=a(this).css(b).offset().top;c<0&&a(this).css("top",b.top-c)}},resizable:!0,show:null,stack:!0,title:"",width:300,zIndex:1e3},_create:function(){this.originalTitle=this.element.attr("title"),typeof this.originalTitle!="string"&&(this.originalTitle=""),this.options.title=this.options.title||this.originalTitle;var b=this,d=b.options,e=d.title||"&#160;",f=a.ui.dialog.getTitleId(b.element),g=(b.uiDialog=a("<div></div>")).appendTo(document.body).hide().addClass(c+d.dialogClass).css({zIndex:d.zIndex}).attr("tabIndex",-1).css("outline",0).keydown(function(c){d.closeOnEscape&&!c.isDefaultPrevented()&&c.keyCode&&c.keyCode===a.ui.keyCode.ESCAPE&&(b.close(c),c.preventDefault())}).attr({role:"dialog","aria-labelledby":f}).mousedown(function(a){b.moveToTop(!1,a)}),h=b.element.show().removeAttr("title").addClass("ui-dialog-content ui-widget-content").appendTo(g),i=(b.uiDialogTitlebar=a("<div></div>")).addClass("ui-dialog-titlebar ui-widget-header ui-corner-all ui-helper-clearfix").prependTo(g),j=a('<a href="#"></a>').addClass("ui-dialog-titlebar-close ui-corner-all").attr("role","button").hover(function(){j.addClass("ui-state-hover")},function(){j.removeClass("ui-state-hover")}).focus(function(){j.addClass("ui-state-focus")}).blur(function(){j.removeClass("ui-state-focus")}).click(function(a){return b.close(a),!1}).appendTo(i),k=(b.uiDialogTitlebarCloseText=a("<span></span>")).addClass("ui-icon ui-icon-closethick").text(d.closeText).appendTo(j),l=a("<span></span>").addClass("ui-dialog-title").attr("id",f).html(e).prependTo(i);a.isFunction(d.beforeclose)&&!a.isFunction(d.beforeClose)&&(d.beforeClose=d.beforeclose),i.find("*").add(i).disableSelection(),d.draggable&&a.fn.draggable&&b._makeDraggable(),d.resizable&&a.fn.resizable&&b._makeResizable(),b._createButtons(d.buttons),b._isOpen=!1,a.fn.bgiframe&&g.bgiframe()},_init:function(){this.options.autoOpen&&this.open()},destroy:function(){var a=this;return a.overlay&&a.overlay.destroy(),a.uiDialog.hide(),a.element.unbind(".dialog").removeData("dialog").removeClass("ui-dialog-content ui-widget-content").hide().appendTo("body"),a.uiDialog.remove(),a.originalTitle&&a.element.attr("title",a.originalTitle),a},widget:function(){return this.uiDialog},close:function(b){var c=this,d,e;if(!1===c._trigger("beforeClose",b))return;return c.overlay&&c.overlay.destroy(),c.uiDialog.unbind("keypress.ui-dialog"),c._isOpen=!1,c.options.hide?c.uiDialog.hide(c.options.hide,function(){c._trigger("close",b)}):(c.uiDialog.hide(),c._trigger("close",b)),a.ui.dialog.overlay.resize(),c.options.modal&&(d=0,a(".ui-dialog").each(function(){this!==c.uiDialog[0]&&(e=a(this).css("z-index"),isNaN(e)||(d=Math.max(d,e)))}),a.ui.dialog.maxZ=d),c},isOpen:function(){return this._isOpen},moveToTop:function(b,c){var d=this,e=d.options,f;return e.modal&&!b||!e.stack&&!e.modal?d._trigger("focus",c):(e.zIndex>a.ui.dialog.maxZ&&(a.ui.dialog.maxZ=e.zIndex),d.overlay&&(a.ui.dialog.maxZ+=1,d.overlay.$el.css("z-index",a.ui.dialog.overlay.maxZ=a.ui.dialog.maxZ)),f={scrollTop:d.element.scrollTop(),scrollLeft:d.element.scrollLeft()},a.ui.dialog.maxZ+=1,d.uiDialog.css("z-index",a.ui.dialog.maxZ),d.element.attr(f),d._trigger("focus",c),d)},open:function(){if(this._isOpen)return;var b=this,c=b.options,d=b.uiDialog;return b.overlay=c.modal?new a.ui.dialog.overlay(b):null,b._size(),b._position(c.position),d.show(c.show),b.moveToTop(!0),c.modal&&d.bind("keydown.ui-dialog",function(b){if(b.keyCode!==a.ui.keyCode.TAB)return;var c=a(":tabbable",this),d=c.filter(":first"),e=c.filter(":last");if(b.target===e[0]&&!b.shiftKey)return d.focus(1),!1;if(b.target===d[0]&&b.shiftKey)return e.focus(1),!1}),a(b.element.find(":tabbable").get().concat(d.find(".ui-dialog-buttonpane :tabbable").get().concat(d.get()))).eq(0).focus(),b._isOpen=!0,b._trigger("open"),b},_createButtons:function(b){var c=this,d=!1,e=a("<div></div>").addClass("ui-dialog-buttonpane ui-widget-content ui-helper-clearfix"),g=a("<div></div>").addClass("ui-dialog-buttonset").appendTo(e);c.uiDialog.find(".ui-dialog-buttonpane").remove(),typeof b=="object"&&b!==null&&a.each(b,function(){return!(d=!0)}),d&&(a.each(b,function(b,d){d=a.isFunction(d)?{click:d,text:b}:d;var e=a('<button type="button"></button>').click(function(){d.click.apply(c.element[0],arguments)}).appendTo(g);a.each(d,function(a,b){if(a==="click")return;a in f?e[a](b):e.attr(a,b)}),a.fn.button&&e.button()}),e.appendTo(c.uiDialog))},_makeDraggable:function(){function f(a){return{position:a.position,offset:a.offset}}var b=this,c=b.options,d=a(document),e;b.uiDialog.draggable({cancel:".ui-dialog-content, .ui-dialog-titlebar-close",handle:".ui-dialog-titlebar",containment:"document",start:function(d,g){e=c.height==="auto"?"auto":a(this).height(),a(this).height(a(this).height()).addClass("ui-dialog-dragging"),b._trigger("dragStart",d,f(g))},drag:function(a,c){b._trigger("drag",a,f(c))},stop:function(g,h){c.position=[h.position.left-d.scrollLeft(),h.position.top-d.scrollTop()],a(this).removeClass("ui-dialog-dragging").height(e),b._trigger("dragStop",g,f(h)),a.ui.dialog.overlay.resize()}})},_makeResizable:function(c){function h(a){return{originalPosition:a.originalPosition,originalSize:a.originalSize,position:a.position,size:a.size}}c=c===b?this.options.resizable:c;var d=this,e=d.options,f=d.uiDialog.css("position"),g=typeof c=="string"?c:"n,e,s,w,se,sw,ne,nw";d.uiDialog.resizable({cancel:".ui-dialog-content",containment:"document",alsoResize:d.element,maxWidth:e.maxWidth,maxHeight:e.maxHeight,minWidth:e.minWidth,minHeight:d._minHeight(),handles:g,start:function(b,c){a(this).addClass("ui-dialog-resizing"),d._trigger("resizeStart",b,h(c))},resize:function(a,b){d._trigger("resize",a,h(b))},stop:function(b,c){a(this).removeClass("ui-dialog-resizing"),e.height=a(this).height(),e.width=a(this).width(),d._trigger("resizeStop",b,h(c)),a.ui.dialog.overlay.resize()}}).css("position",f).find(".ui-resizable-se").addClass("ui-icon ui-icon-grip-diagonal-se")},_minHeight:function(){var a=this.options;return a.height==="auto"?a.minHeight:Math.min(a.minHeight,a.height)},_position:function(b){var c=[],d=[0,0],e;if(b){if(typeof b=="string"||typeof b=="object"&&"0"in b)c=b.split?b.split(" "):[b[0],b[1]],c.length===1&&(c[1]=c[0]),a.each(["left","top"],function(a,b){+c[a]===c[a]&&(d[a]=c[a],c[a]=b)}),b={my:c.join(" "),at:c.join(" "),offset:d.join(" ")};b=a.extend({},a.ui.dialog.prototype.options.position,b)}else b=a.ui.dialog.prototype.options.position;e=this.uiDialog.is(":visible"),e||this.uiDialog.show(),this.uiDialog.css({top:0,left:0}).position(a.extend({of:window},b)),e||this.uiDialog.hide()},_setOptions:function(b){var c=this,f={},g=!1;a.each(b,function(a,b){c._setOption(a,b),a in d&&(g=!0),a in e&&(f[a]=b)}),g&&this._size(),this.uiDialog.is(":data(resizable)")&&this.uiDialog.resizable("option",f)},_setOption:function(b,d){var e=this,f=e.uiDialog;switch(b){case"beforeclose":b="beforeClose";break;case"buttons":e._createButtons(d);break;case"closeText":e.uiDialogTitlebarCloseText.text(""+d);break;case"dialogClass":f.removeClass(e.options.dialogClass).addClass(c+d);break;case"disabled":d?f.addClass("ui-dialog-disabled"):f.removeClass("ui-dialog-disabled");break;case"draggable":var g=f.is(":data(draggable)");g&&!d&&f.draggable("destroy"),!g&&d&&e._makeDraggable();break;case"position":e._position(d);break;case"resizable":var h=f.is(":data(resizable)");h&&!d&&f.resizable("destroy"),h&&typeof d=="string"&&f.resizable("option","handles",d),!h&&d!==!1&&e._makeResizable(d);break;case"title":a(".ui-dialog-title",e.uiDialogTitlebar).html(""+(d||"&#160;"))}a.Widget.prototype._setOption.apply(e,arguments)},_size:function(){var b=this.options,c,d,e=this.uiDialog.is(":visible");this.element.show().css({width:"auto",minHeight:0,height:0}),b.minWidth>b.width&&(b.width=b.minWidth),c=this.uiDialog.css({height:"auto",width:b.width}).height(),d=Math.max(0,b.minHeight-c);if(b.height==="auto")if(a.support.minHeight)this.element.css({minHeight:d,height:"auto"});else{this.uiDialog.show();var f=this.element.css("height","auto").height();e||this.uiDialog.hide(),this.element.height(Math.max(f,d))}else this.element.height(Math.max(b.height-c,0));this.uiDialog.is(":data(resizable)")&&this.uiDialog.resizable("option","minHeight",this._minHeight())}}),a.extend(a.ui.dialog,{version:"1.8.22",uuid:0,maxZ:0,getTitleId:function(a){var b=a.attr("id");return b||(this.uuid+=1,b=this.uuid),"ui-dialog-title-"+b},overlay:function(b){this.$el=a.ui.dialog.overlay.create(b)}}),a.extend(a.ui.dialog.overlay,{instances:[],oldInstances:[],maxZ:0,events:a.map("focus,mousedown,mouseup,keydown,keypress,click".split(","),function(a){return a+".dialog-overlay"}).join(" "),create:function(b){this.instances.length===0&&(setTimeout(function(){a.ui.dialog.overlay.instances.length&&a(document).bind(a.ui.dialog.overlay.events,function(b){if(a(b.target).zIndex()<a.ui.dialog.overlay.maxZ)return!1})},1),a(document).bind("keydown.dialog-overlay",function(c){b.options.closeOnEscape&&!c.isDefaultPrevented()&&c.keyCode&&c.keyCode===a.ui.keyCode.ESCAPE&&(b.close(c),c.preventDefault())}),a(window).bind("resize.dialog-overlay",a.ui.dialog.overlay.resize));var c=(this.oldInstances.pop()||a("<div></div>").addClass("ui-widget-overlay")).appendTo(document.body).css({width:this.width(),height:this.height()});return a.fn.bgiframe&&c.bgiframe(),this.instances.push(c),c},destroy:function(b){var c=a.inArray(b,this.instances);c!=-1&&this.oldInstances.push(this.instances.splice(c,1)[0]),this.instances.length===0&&a([document,window]).unbind(".dialog-overlay"),b.remove();var d=0;a.each(this.instances,function(){d=Math.max(d,this.css("z-index"))}),this.maxZ=d},height:function(){var b,c;return a.browser.msie&&a.browser.version<7?(b=Math.max(document.documentElement.scrollHeight,document.body.scrollHeight),c=Math.max(document.documentElement.offsetHeight,document.body.offsetHeight),b<c?a(window).height()+"px":b+"px"):a(document).height()+"px"},width:function(){var b,c;return a.browser.msie?(b=Math.max(document.documentElement.scrollWidth,document.body.scrollWidth),c=Math.max(document.documentElement.offsetWidth,document.body.offsetWidth),b<c?a(window).width()+"px":b+"px"):a(document).width()+"px"},resize:function(){var b=a([]);a.each(a.ui.dialog.overlay.instances,function(){b=b.add(this)}),b.css({width:0,height:0}).css({width:a.ui.dialog.overlay.width(),height:a.ui.dialog.overlay.height()})}}),a.extend(a.ui.dialog.overlay.prototype,{destroy:function(){a.ui.dialog.overlay.destroy(this.$el)}})}(jQuery),function(a,b){a.ui=a.ui||{};var c=/left|center|right/,d=/top|center|bottom/,e="center",f={},g=a.fn.position,h=a.fn.offset;a.fn.position=function(b){if(!b||!b.of)return g.apply(this,arguments);b=a.extend({},b);var h=a(b.of),i=h[0],j=(b.collision||"flip").split(" "),k=b.offset?b.offset.split(" "):[0,0],l,m,n;return i.nodeType===9?(l=h.width(),m=h.height(),n={top:0,left:0}):i.setTimeout?(l=h.width(),m=h.height(),n={top:h.scrollTop(),left:h.scrollLeft()}):i.preventDefault?(b.at="left top",l=m=0,n={top:b.of.pageY,left:b.of.pageX}):(l=h.outerWidth(),m=h.outerHeight(),n=h.offset()),a.each(["my","at"],function(){var a=(b[this]||"").split(" ");a.length===1&&(a=c.test(a[0])?a.concat([e]):d.test(a[0])?[e].concat(a):[e,e]),a[0]=c.test(a[0])?a[0]:e,a[1]=d.test(a[1])?a[1]:e,b[this]=a}),j.length===1&&(j[1]=j[0]),k[0]=parseInt(k[0],10)||0,k.length===1&&(k[1]=k[0]),k[1]=parseInt(k[1],10)||0,b.at[0]==="right"?n.left+=l:b.at[0]===e&&(n.left+=l/2),b.at[1]==="bottom"?n.top+=m:b.at[1]===e&&(n.top+=m/2),n.left+=k[0],n.top+=k[1],this.each(function(){var c=a(this),d=c.outerWidth(),g=c.outerHeight(),h=parseInt(a.curCSS(this,"marginLeft",!0))||0,i=parseInt(a.curCSS(this,"marginTop",!0))||0,o=d+h+(parseInt(a.curCSS(this,"marginRight",!0))||0),p=g+i+(parseInt(a.curCSS(this,"marginBottom",!0))||0),q=a.extend({},n),r;b.my[0]==="right"?q.left-=d:b.my[0]===e&&(q.left-=d/2),b.my[1]==="bottom"?q.top-=g:b.my[1]===e&&(q.top-=g/2),f.fractions||(q.left=Math.round(q.left),q.top=Math.round(q.top)),r={left:q.left-h,top:q.top-i},a.each(["left","top"],function(c,e){a.ui.position[j[c]]&&a.ui.position[j[c]][e](q,{targetWidth:l,targetHeight:m,elemWidth:d,elemHeight:g,collisionPosition:r,collisionWidth:o,collisionHeight:p,offset:k,my:b.my,at:b.at})}),a.fn.bgiframe&&c.bgiframe(),c.offset(a.extend(q,{using:b.using}))})},a.ui.position={fit:{left:function(b,c){var d=a(window),e=c.collisionPosition.left+c.collisionWidth-d.width()-d.scrollLeft();b.left=e>0?b.left-e:Math.max(b.left-c.collisionPosition.left,b.left)},top:function(b,c){var d=a(window),e=c.collisionPosition.top+c.collisionHeight-d.height()-d.scrollTop();b.top=e>0?b.top-e:Math.max(b.top-c.collisionPosition.top,b.top)}},flip:{left:function(b,c){if(c.at[0]===e)return;var d=a(window),f=c.collisionPosition.left+c.collisionWidth-d.width()-d.scrollLeft(),g=c.my[0]==="left"?-c.elemWidth:c.my[0]==="right"?c.elemWidth:0,h=c.at[0]==="left"?c.targetWidth:-c.targetWidth,i=-2*c.offset[0];b.left+=c.collisionPosition.left<0?g+h+i:f>0?g+h+i:0},top:function(b,c){if(c.at[1]===e)return;var d=a(window),f=c.collisionPosition.top+c.collisionHeight-d.height()-d.scrollTop(),g=c.my[1]==="top"?-c.elemHeight:c.my[1]==="bottom"?c.elemHeight:0,h=c.at[1]==="top"?c.targetHeight:-c.targetHeight,i=-2*c.offset[1];b.top+=c.collisionPosition.top<0?g+h+i:f>0?g+h+i:0}}},a.offset.setOffset||(a.offset.setOffset=function(b,c){/static/.test(a.curCSS(b,"position"))&&(b.style.position="relative");var d=a(b),e=d.offset(),f=parseInt(a.curCSS(b,"top",!0),10)||0,g=parseInt(a.curCSS(b,"left",!0),10)||0,h={top:c.top-e.top+f,left:c.left-e.left+g};"using"in c?c.using.call(b,h):d.css(h)},a.fn.offset=function(b){var c=this[0];return!c||!c.ownerDocument?null:b?a.isFunction(b)?this.each(function(c){a(this).offset(b.call(this,c,a(this).offset()))}):this.each(function(){a.offset.setOffset(this,b)}):h.call(this)}),function(){var b=document.getElementsByTagName("body")[0],c=document.createElement("div"),d,e,g,h,i;d=document.createElement(b?"div":"body"),g={visibility:"hidden",width:0,height:0,border:0,margin:0,background:"none"},b&&a.extend(g,{position:"absolute",left:"-1000px",top:"-1000px"});for(var j in g)d.style[j]=g[j];d.appendChild(c),e=b||document.documentElement,e.insertBefore(d,e.firstChild),c.style.cssText="position: absolute; left: 10.7432222px; top: 10.432325px; height: 30px; width: 201px;",h=a(c).offset(function(a,b){return b}).offset(),d.innerHTML="",e.removeChild(d),i=h.top+h.left+(b?2e3:0),f.fractions=i>21&&i<22}()}(jQuery),function(a,b){a.widget("ui.progressbar",{options:{value:0,max:100},min:0,_create:function(){this.element.addClass("ui-progressbar ui-widget ui-widget-content ui-corner-all").attr({role:"progressbar","aria-valuemin":this.min,"aria-valuemax":this.options.max,"aria-valuenow":this._value()}),this.valueDiv=a("<div class='ui-progressbar-value ui-widget-header ui-corner-left'></div>").appendTo(this.element),this.oldValue=this._value(),this._refreshValue()},destroy:function(){this.element.removeClass("ui-progressbar ui-widget ui-widget-content ui-corner-all").removeAttr("role").removeAttr("aria-valuemin").removeAttr("aria-valuemax").removeAttr("aria-valuenow"),this.valueDiv.remove(),a.Widget.prototype.destroy.apply(this,arguments)},value:function(a){return a===b?this._value():(this._setOption("value",a),this)},_setOption:function(b,c){b==="value"&&(this.options.value=c,this._refreshValue(),this._value()===this.options.max&&this._trigger("complete")),a.Widget.prototype._setOption.apply(this,arguments)},_value:function(){var a=this.options.value;return typeof a!="number"&&(a=0),Math.min(this.options.max,Math.max(this.min,a))},_percentage:function(){return 100*this._value()/this.options.max},_refreshValue:function(){var a=this.value(),b=this._percentage();this.oldValue!==a&&(this.oldValue=a,this._trigger("change")),this.valueDiv.toggle(a>this.min).toggleClass("ui-corner-right",a===this.options.max).width(b.toFixed(0)+"%"),this.element.attr("aria-valuenow",a)}}),a.extend(a.ui.progressbar,{version:"1.8.22"})}(jQuery),function(a,b){var c=5;a.widget("ui.slider",a.ui.mouse,{widgetEventPrefix:"slide",options:{animate:!1,distance:0,max:100,min:0,orientation:"horizontal",range:!1,step:1,value:0,values:null},_create:function(){var b=this,d=this.options,e=this.element.find(".ui-slider-handle").addClass("ui-state-default ui-corner-all"),f="<a class='ui-slider-handle ui-state-default ui-corner-all' href='#'></a>",g=d.values&&d.values.length||1,h=[];this._keySliding=!1,this._mouseSliding=!1,this._animateOff=!0,this._handleIndex=null,this._detectOrientation(),this._mouseInit(),this.element.addClass("ui-slider ui-slider-"+this.orientation+" ui-widget"+" ui-widget-content"+" ui-corner-all"+(d.disabled?" ui-slider-disabled ui-disabled":"")),this.range=a([]),d.range&&(d.range===!0&&(d.values||(d.values=[this._valueMin(),this._valueMin()]),d.values.length&&d.values.length!==2&&(d.values=[d.values[0],d.values[0]])),this.range=a("<div></div>").appendTo(this.element).addClass("ui-slider-range ui-widget-header"+(d.range==="min"||d.range==="max"?" ui-slider-range-"+d.range:"")));for(var i=e.length;i<g;i+=1)h.push(f);this.handles=e.add(a(h.join("")).appendTo(b.element)),this.handle=this.handles.eq(0),this.handles.add(this.range).filter("a").click(function(a){a.preventDefault()}).hover(function(){d.disabled||a(this).addClass("ui-state-hover")},function(){a(this).removeClass("ui-state-hover")}).focus(function(){d.disabled?a(this).blur():(a(".ui-slider .ui-state-focus").removeClass("ui-state-focus"),a(this).addClass("ui-state-focus"))}).blur(function(){a(this).removeClass("ui-state-focus")}),this.handles.each(function(b){a(this).data("index.ui-slider-handle",b)}),this.handles.keydown(function(d){var e=a(this).data("index.ui-slider-handle"),f,g,h,i;if(b.options.disabled)return;switch(d.keyCode){case a.ui.keyCode.HOME:case a.ui.keyCode.END:case a.ui.keyCode.PAGE_UP:case a.ui.keyCode.PAGE_DOWN:case a.ui.keyCode.UP:case a.ui.keyCode.RIGHT:case a.ui.keyCode.DOWN:case a.ui.keyCode.LEFT:d.preventDefault();if(!b._keySliding){b._keySliding=!0,a(this).addClass("ui-state-active"),f=b._start(d,e);if(f===!1)return}}i=b.options.step,b.options.values&&b.options.values.length?g=h=b.values(e):g=h=b.value();switch(d.keyCode){case a.ui.keyCode.HOME:h=b._valueMin();break;case a.ui.keyCode.END:h=b._valueMax();break;case a.ui.keyCode.PAGE_UP:h=b._trimAlignValue(g+(b._valueMax()-b._valueMin())/c);break;case a.ui.keyCode.PAGE_DOWN:h=b._trimAlignValue(g-(b._valueMax()-b._valueMin())/c);break;case a.ui.keyCode.UP:case a.ui.keyCode.RIGHT:if(g===b._valueMax())return;h=b._trimAlignValue(g+i);break;case a.ui.keyCode.DOWN:case a.ui.keyCode.LEFT:if(g===b._valueMin())return;h=b._trimAlignValue(g-i)}b._slide(d,e,h)}).keyup(function(c){var d=a(this).data("index.ui-slider-handle");b._keySliding&&(b._keySliding=!1,b._stop(c,d),b._change(c,d),a(this).removeClass("ui-state-active"))}),this._refreshValue(),this._animateOff=!1},destroy:function(){return this.handles.remove(),this.range.remove(),this.element.removeClass("ui-slider ui-slider-horizontal ui-slider-vertical ui-slider-disabled ui-widget ui-widget-content ui-corner-all").removeData("slider").unbind(".slider"),this._mouseDestroy(),this},_mouseCapture:function(b){var c=this.options,d,e,f,g,h,i,j,k,l;return c.disabled?!1:(this.elementSize={width:this.element.outerWidth(),height:this.element.outerHeight()},this.elementOffset=this.element.offset(),d={x:b.pageX,y:b.pageY},e=this._normValueFromMouse(d),f=this._valueMax()-this._valueMin()+1,h=this,this.handles.each(function(b){var c=Math.abs(e-h.values(b));f>c&&(f=c,g=a(this),i=b)}),c.range===!0&&this.values(1)===c.min&&(i+=1,g=a(this.handles[i])),j=this._start(b,i),j===!1?!1:(this._mouseSliding=!0,h._handleIndex=i,g.addClass("ui-state-active").focus(),k=g.offset(),l=!a(b.target).parents().andSelf().is(".ui-slider-handle"),this._clickOffset=l?{left:0,top:0}:{left:b.pageX-k.left-g.width()/2,top:b.pageY-k.top-g.height()/2-(parseInt(g.css("borderTopWidth"),10)||0)-(parseInt(g.css("borderBottomWidth"),10)||0)+(parseInt(g.css("marginTop"),10)||0)},this.handles.hasClass("ui-state-hover")||this._slide(b,i,e),this._animateOff=!0,!0))},_mouseStart:function(a){return!0},_mouseDrag:function(a){var b={x:a.pageX,y:a.pageY},c=this._normValueFromMouse(b);return this._slide(a,this._handleIndex,c),!1},_mouseStop:function(a){return this.handles.removeClass("ui-state-active"),this._mouseSliding=!1,this._stop(a,this._handleIndex),this._change(a,this._handleIndex),this._handleIndex=null,this._clickOffset=null,this._animateOff=!1,!1},_detectOrientation:function(){this.orientation=this.options.orientation==="vertical"?"vertical":"horizontal"},_normValueFromMouse:function(a){var b,c,d,e,f;return this.orientation==="horizontal"?(b=this.elementSize.width,c=a.x-this.elementOffset.left-(this._clickOffset?this._clickOffset.left:0)):(b=this.elementSize.height,c=a.y-this.elementOffset.top-(this._clickOffset?this._clickOffset.top:0)),d=c/b,d>1&&(d=1),d<0&&(d=0),this.orientation==="vertical"&&(d=1-d),e=this._valueMax()-this._valueMin(),f=this._valueMin()+d*e,this._trimAlignValue(f)},_start:function(a,b){var c={handle:this.handles[b],value:this.value()};return this.options.values&&this.options.values.length&&(c.value=this.values(b),c.values=this.values()),this._trigger("start",a,c)},_slide:function(a,b,c){var d,e,f;this.options.values&&this.options.values.length?(d=this.values(b?0:1),this.options.values.length===2&&this.options.range===!0&&(b===0&&c>d||b===1&&c<d)&&(c=d),c!==this.values(b)&&(e=this.values(),e[b]=c,f=this._trigger("slide",a,{handle:this.handles[b],value:c,values:e}),d=this.values(b?0:1),f!==!1&&this.values(b,c,!0))):c!==this.value()&&(f=this._trigger("slide",a,{handle:this.handles[b],value:c}),f!==!1&&this.value(c))},_stop:function(a,b){var c={handle:this.handles[b],value:this.value()};this.options.values&&this.options.values.length&&(c.value=this.values(b),c.values=this.values()),this._trigger("stop",a,c)},_change:function(a,b){if(!this._keySliding&&!this._mouseSliding){var c={handle:this.handles[b],value:this.value()};this.options.values&&this.options.values.length&&(c.value=this.values(b),c.values=this.values()),this._trigger("change",a,c)}},value:function(a){if(arguments.length){this.options.value=this._trimAlignValue(a),this._refreshValue(),this._change(null,0);return}return this._value()},values:function(b,c){var d,e,f;if(arguments.length>1){this.options.values[b]=this._trimAlignValue(c),this._refreshValue(),this._change(null,b);return}if(!arguments.length)return this._values();if(!a.isArray(arguments[0]))return this.options.values&&this.options.values.length?this._values(b):this.value();d=this.options.values,e=arguments[0];for(f=0;f<d.length;f+=1)d[f]=this._trimAlignValue(e[f]),this._change(null,f);this._refreshValue()},_setOption:function(b,c){var d,e=0;a.isArray(this.options.values)&&(e=this.options.values.length),a.Widget.prototype._setOption.apply(this,arguments);switch(b){case"disabled":c?(this.handles.filter(".ui-state-focus").blur(),this.handles.removeClass("ui-state-hover"),this.handles.propAttr("disabled",!0),this.element.addClass("ui-disabled")):(this.handles.propAttr("disabled",!1),this.element.removeClass("ui-disabled"));break;case"orientation":this._detectOrientation(),this.element.removeClass("ui-slider-horizontal ui-slider-vertical").addClass("ui-slider-"+this.orientation),this._refreshValue();break;case"value":this._animateOff=!0,this._refreshValue(),this._change(null,0),this._animateOff=!1;break;case"values":this._animateOff=!0,this._refreshValue();for(d=0;d<e;d+=1)this._change(null,d);this._animateOff=!1}},_value:function(){var a=this.options.value;return a=this._trimAlignValue(a),a},_values:function(a){var b,c,d;if(arguments.length)return b=this.options.values[a],b=this._trimAlignValue(b),b;c=this.options.values.slice();for(d=0;d<c.length;d+=1)c[d]=this._trimAlignValue(c[d]);return c},_trimAlignValue:function(a){if(a<=this._valueMin())return this._valueMin();if(a>=this._valueMax())return this._valueMax();var b=this.options.step>0?this.options.step:1,c=(a-this._valueMin())%b,d=a-c;return Math.abs(c)*2>=b&&(d+=c>0?b:-b),parseFloat(d.toFixed(5))},_valueMin:function(){return this.options.min},_valueMax:function(){return this.options.max},_refreshValue:function(){var b=this.options.range,c=this.options,d=this,e=this._animateOff?!1:c.animate,f,g={},h,i,j,k;this.options.values&&this.options.values.length?this.handles.each(function(b,i){f=(d.values(b)-d._valueMin())/(d._valueMax()-d._valueMin())*100,g[d.orientation==="horizontal"?"left":"bottom"]=f+"%",a(this).stop(1,1)[e?"animate":"css"](g,c.animate),d.options.range===!0&&(d.orientation==="horizontal"?(b===0&&d.range.stop(1,1)[e?"animate":"css"]({left:f+"%"},c.animate),b===1&&d.range[e?"animate":"css"]({width:f-h+"%"},{queue:!1,duration:c.animate})):(b===0&&d.range.stop(1,1)[e?"animate":"css"]({bottom:f+"%"},c.animate),b===1&&d.range[e?"animate":"css"]({height:f-h+"%"},{queue:!1,duration:c.animate}))),h=f}):(i=this.value(),j=this._valueMin(),k=this._valueMax(),f=k!==j?(i-j)/(k-j)*100:0,g[d.orientation==="horizontal"?"left":"bottom"]=f+"%",this.handle.stop(1,1)[e?"animate":"css"](g,c.animate),b==="min"&&this.orientation==="horizontal"&&this.range.stop(1,1)[e?"animate":"css"]({width:f+"%"},c.animate),b==="max"&&this.orientation==="horizontal"&&this.range[e?"animate":"css"]({width:100-f+"%"},{queue:!1,duration:c.animate}),b==="min"&&this.orientation==="vertical"&&this.range.stop(1,1)[e?"animate":"css"]({height:f+"%"},c.animate),b==="max"&&this.orientation==="vertical"&&this.range[e?"animate":"css"]({height:100-f+"%"},{queue:!1,duration:c.animate}))}}),a.extend(a.ui.slider,{version:"1.8.22"})}(jQuery),function(a,b){function e(){return++c}function f(){return++d}var c=0,d=0;a.widget("ui.tabs",{options:{add:null,ajaxOptions:null,cache:!1,cookie:null,collapsible:!1,disable:null,disabled:[],enable:null,event:"click",fx:null,idPrefix:"ui-tabs-",load:null,panelTemplate:"<div></div>",remove:null,select:null,show:null,spinner:"<em>Loading&#8230;</em>",tabTemplate:"<li><a href='#{href}'><span>#{label}</span></a></li>"},_create:function(){this._tabify(!0)},_setOption:function(a,b){if(a=="selected"){if(this.options.collapsible&&b==this.options.selected)return;this.select(b)}else this.options[a]=b,this._tabify()},_tabId:function(a){return a.title&&a.title.replace(/\s/g,"_").replace(/[^\w\u00c0-\uFFFF-]/g,"")||this.options.idPrefix+e()},_sanitizeSelector:function(a){return a.replace(/:/g,"\\:")},_cookie:function(){var b=this.cookie||(this.cookie=this.options.cookie.name||"ui-tabs-"+f());return a.cookie.apply(null,[b].concat(a.makeArray(arguments)))},_ui:function(a,b){return{tab:a,panel:b,index:this.anchors.index(a)}},_cleanup:function(){this.lis.filter(".ui-state-processing").removeClass("ui-state-processing").find("span:data(label.tabs)").each(function(){var b=a(this);b.html(b.data("label.tabs")).removeData("label.tabs")})},_tabify:function(c){function m(b,c){b.css("display",""),!a.support.opacity&&c.opacity&&b[0].style.removeAttribute("filter")}var d=this,e=this.options,f=/^#.+/;this.list=this.element.find("ol,ul").eq(0),this.lis=a(" > li:has(a[href])",this.list),this.anchors=this.lis.map(function(){return a("a",this)[0]}),this.panels=a([]),this.anchors.each(function(b,c){var g=a(c).attr("href"),h=g.split("#")[0],i;h&&(h===location.toString().split("#")[0]||(i=a("base")[0])&&h===i.href)&&(g=c.hash,c.href=g);if(f.test(g))d.panels=d.panels.add(d.element.find(d._sanitizeSelector(g)));else if(g&&g!=="#"){a.data(c,"href.tabs",g),a.data(c,"load.tabs",g.replace(/#.*$/,""));var j=d._tabId(c);c.href="#"+j;var k=d.element.find("#"+j);k.length||(k=a(e.panelTemplate).attr("id",j).addClass("ui-tabs-panel ui-widget-content ui-corner-bottom").insertAfter(d.panels[b-1]||d.list),k.data("destroy.tabs",!0)),d.panels=d.panels.add(k)}else e.disabled.push(b)}),c?(this.element.addClass("ui-tabs ui-widget ui-widget-content ui-corner-all"),this.list.addClass("ui-tabs-nav ui-helper-reset ui-helper-clearfix ui-widget-header ui-corner-all"),this.lis.addClass("ui-state-default ui-corner-top"),this.panels.addClass("ui-tabs-panel ui-widget-content ui-corner-bottom"),e.selected===b?(location.hash&&this.anchors.each(function(a,b){if(b.hash==location.hash)return e.selected=a,!1}),typeof e.selected!="number"&&e.cookie&&(e.selected=parseInt(d._cookie(),10)),typeof e.selected!="number"&&this.lis.filter(".ui-tabs-selected").length&&(e.selected=this.lis.index(this.lis.filter(".ui-tabs-selected"))),e.selected=e.selected||(this.lis.length?0:-1)):e.selected===null&&(e.selected=-1),e.selected=e.selected>=0&&this.anchors[e.selected]||e.selected<0?e.selected:0,e.disabled=a.unique(e.disabled.concat(a.map(this.lis.filter(".ui-state-disabled"),function(a,b){return d.lis.index(a)}))).sort(),a.inArray(e.selected,e.disabled)!=-1&&e.disabled.splice(a.inArray(e.selected,e.disabled),1),this.panels.addClass("ui-tabs-hide"),this.lis.removeClass("ui-tabs-selected ui-state-active"),e.selected>=0&&this.anchors.length&&(d.element.find(d._sanitizeSelector(d.anchors[e.selected].hash)).removeClass("ui-tabs-hide"),this.lis.eq(e.selected).addClass("ui-tabs-selected ui-state-active"),d.element.queue("tabs",function(){d._trigger("show",null,d._ui(d.anchors[e.selected],d.element.find(d._sanitizeSelector(d.anchors[e.selected].hash))[0]))}),this.load(e.selected)),a(window).bind("unload",function(){d.lis.add(d.anchors).unbind(".tabs"),d.lis=d.anchors=d.panels=null})):e.selected=this.lis.index(this.lis.filter(".ui-tabs-selected")),this.element[e.collapsible?"addClass":"removeClass"]("ui-tabs-collapsible"),e.cookie&&this._cookie(e.selected,e.cookie);for(var g=0,h;h=this.lis[g];g++)a(h)[a.inArray(g,e.disabled)!=-1&&!a(h).hasClass("ui-tabs-selected")?"addClass":"removeClass"]("ui-state-disabled");e.cache===!1&&this.anchors.removeData("cache.tabs"),this.lis.add(this.anchors).unbind(".tabs");if(e.event!=="mouseover"){var i=function(a,b){b.is(":not(.ui-state-disabled)")&&b.addClass("ui-state-"+a)},j=function(a,b){b.removeClass("ui-state-"+a)};this.lis.bind("mouseover.tabs",function(){i("hover",a(this))}),this.lis.bind("mouseout.tabs",function(){j("hover",a(this))}),this.anchors.bind("focus.tabs",function(){i("focus",a(this).closest("li"))}),this.anchors.bind("blur.tabs",function(){j("focus",a(this).closest("li"))})}var k,l;e.fx&&(a.isArray(e.fx)?(k=e.fx[0],l=e.fx[1]):k=l=e.fx);var n=l?function(b,c){a(b).closest("li").addClass("ui-tabs-selected ui-state-active"),c.hide().removeClass("ui-tabs-hide").animate(l,l.duration||"normal",function(){m(c,l),d._trigger("show",null,d._ui(b,c[0]))})}:function(b,c){a(b).closest("li").addClass("ui-tabs-selected ui-state-active"),c.removeClass("ui-tabs-hide"),d._trigger("show",null,d._ui(b,c[0]))},o=k?function(a,b){b.animate(k,k.duration||"normal",function(){d.lis.removeClass("ui-tabs-selected ui-state-active"),b.addClass("ui-tabs-hide"),m(b,k),d.element.dequeue("tabs")})}:function(a,b,c){d.lis.removeClass("ui-tabs-selected ui-state-active"),b.addClass("ui-tabs-hide"),d.element.dequeue("tabs")};this.anchors.bind(e.event+".tabs",function(){var b=this,c=a(b).closest("li"),f=d.panels.filter(":not(.ui-tabs-hide)"),g=d.element.find(d._sanitizeSelector(b.hash));if(c.hasClass("ui-tabs-selected")&&!e.collapsible||c.hasClass("ui-state-disabled")||c.hasClass("ui-state-processing")||d.panels.filter(":animated").length||d._trigger("select",null,d._ui(this,g[0]))===!1)return this.blur(),!1;e.selected=d.anchors.index(this),d.abort();if(e.collapsible){if(c.hasClass("ui-tabs-selected"))return e.selected=-1,e.cookie&&d._cookie(e.selected,e.cookie),d.element.queue("tabs",function(){o(b,f)}).dequeue("tabs"),this.blur(),!1;if(!f.length)return e.cookie&&d._cookie(e.selected,e.cookie),d.element.queue("tabs",function(){n(b,g)}),d.load(d.anchors.index(this)),this.blur(),!1}e.cookie&&d._cookie(e.selected,e.cookie);if(g.length)f.length&&d.element.queue("tabs",function(){o(b,f)}),d.element.queue("tabs",function(){n(b,g)}),d.load(d.anchors.index(this));else throw"jQuery UI Tabs: Mismatching fragment identifier.";a.browser.msie&&this.blur()}),this.anchors.bind("click.tabs",function(){return!1})},_getIndex:function(a){return typeof a=="string"&&(a=this.anchors.index(this.anchors.filter("[href$='"+a+"']"))),a},destroy:function(){var b=this.options;return this.abort(),this.element.unbind(".tabs").removeClass("ui-tabs ui-widget ui-widget-content ui-corner-all ui-tabs-collapsible").removeData("tabs"),this.list.removeClass("ui-tabs-nav ui-helper-reset ui-helper-clearfix ui-widget-header ui-corner-all"),this.anchors.each(function(){var b=a.data(this,"href.tabs");b&&(this.href=b);var c=a(this).unbind(".tabs");a.each(["href","load","cache"],function(a,b){c.removeData(b+".tabs")})}),this.lis.unbind(".tabs").add(this.panels).each(function(){a.data(this,"destroy.tabs")?a(this).remove():a(this).removeClass(["ui-state-default","ui-corner-top","ui-tabs-selected","ui-state-active","ui-state-hover","ui-state-focus","ui-state-disabled","ui-tabs-panel","ui-widget-content","ui-corner-bottom","ui-tabs-hide"].join(" "))}),b.cookie&&this._cookie(null,b.cookie),this},add:function(c,d,e){e===b&&(e=this.anchors.length);var f=this,g=this.options,h=a(g.tabTemplate.replace(/#\{href\}/g,c).replace(/#\{label\}/g,d)),i=c.indexOf("#")?this._tabId(a("a",h)[0]):c.replace("#","");h.addClass("ui-state-default ui-corner-top").data("destroy.tabs",!0);var j=f.element.find("#"+i);return j.length||(j=a(g.panelTemplate).attr("id",i).data("destroy.tabs",!0)),j.addClass("ui-tabs-panel ui-widget-content ui-corner-bottom ui-tabs-hide"),e>=this.lis.length?(h.appendTo(this.list),j.appendTo(this.list[0].parentNode)):(h.insertBefore(this.lis[e]),j.insertBefore(this.panels[e])),g.disabled=a.map(g.disabled,function(a,b){return a>=e?++a:a}),this._tabify(),this.anchors.length==1&&(g.selected=0,h.addClass("ui-tabs-selected ui-state-active"),j.removeClass("ui-tabs-hide"),this.element.queue("tabs",function(){f._trigger("show",null,f._ui(f.anchors[0],f.panels[0]))}),this.load(0)),this._trigger("add",null,this._ui(this.anchors[e],this.panels[e])),this},remove:function(b){b=this._getIndex(b);var c=this.options,d=this.lis.eq(b).remove(),e=this.panels.eq(b).remove();return d.hasClass("ui-tabs-selected")&&this.anchors.length>1&&this.select(b+(b+1<this.anchors.length?1:-1)),c.disabled=a.map(a.grep(c.disabled,function(a,c){return a!=b}),function(a,c){return a>=b?--a:a}),this._tabify(),this._trigger("remove",null,this._ui(d.find("a")[0],e[0])),this},enable:function(b){b=this._getIndex(b);var c=this.options;if(a.inArray(b,c.disabled)==-1)return;return this.lis.eq(b).removeClass("ui-state-disabled"),c.disabled=a.grep(c.disabled,function(a,c){return a!=b}),this._trigger("enable",null,this._ui(this.anchors[b],this.panels[b])),this},disable:function(a){a=this._getIndex(a);var b=this,c=this.options;return a!=c.selected&&(this.lis.eq(a).addClass("ui-state-disabled"),c.disabled.push(a),c.disabled.sort(),this._trigger("disable",null,this._ui(this.anchors[a],this.panels[a]))),this},select:function(a){a=this._getIndex(a);if(a==-1)if(this.options.collapsible&&this.options.selected!=-1)a=this.options.selected;else return this;return this.anchors.eq(a).trigger(this.options.event+".tabs"),this},load:function(b){b=this._getIndex(b);var c=this,d=this.options,e=this.anchors.eq(b)[0],f=a.data(e,"load.tabs");this.abort();if(!f||this.element.queue("tabs").length!==0&&a.data(e,"cache.tabs")){this.element.dequeue("tabs");return}this.lis.eq(b).addClass("ui-state-processing");if(d.spinner){var g=a("span",e);g.data("label.tabs",g.html()).html(d.spinner)}return this.xhr=a.ajax(a.extend({},d.ajaxOptions,{url:f,success:function(f,g){c.element.find(c._sanitizeSelector(e.hash)).html(f),c._cleanup(),d.cache&&a.data(e,"cache.tabs",!0),c._trigger("load",null,c._ui(c.anchors[b],c.panels[b]));try{d.ajaxOptions.success(f,g)}catch(h){}},error:function(a,f,g){c._cleanup(),c._trigger("load",null,c._ui(c.anchors[b],c.panels[b]));try{d.ajaxOptions.error(a,f,b,e)}catch(g){}}})),c.element.dequeue("tabs"),this},abort:function(){return this.element.queue([]),this.panels.stop(!1,!0),this.element.queue("tabs",this.element.queue("tabs").splice(-2,2)),this.xhr&&(this.xhr.abort(),delete this.xhr),this._cleanup(),this},url:function(a,b){return this.anchors.eq(a).removeData("cache.tabs").data("load.tabs",b),this},length:function(){return this.anchors.length}}),a.extend(a.ui.tabs,{version:"1.8.22"}),a.extend(a.ui.tabs.prototype,{rotation:null,rotate:function(a,b){var c=this,d=this.options,e=c._rotate||(c._rotate=function(b){clearTimeout(c.rotation),c.rotation=setTimeout(function(){var a=d.selected;c.select(++a<c.anchors.length?a:0)},a),b&&b.stopPropagation()}),f=c._unrotate||(c._unrotate=b?function(a){e()}:function(a){a.clientX&&c.rotate(null)});return a?(this.element.bind("tabsshow",e),this.anchors.bind(d.event+".tabs",f),e()):(clearTimeout(c.rotation),this.element.unbind("tabsshow",e),this.anchors.unbind(d.event+".tabs",f),delete this._rotate,delete this._unrotate),this}})}(jQuery);// Spectrum Colorpicker v1.7.1
// https://github.com/bgrins/spectrum
// Author: Brian Grinstead
// License: MIT

(function (factory) {
    "use strict";

    if (typeof define === 'function' && define.amd) { // AMD
        define(['jquery'], factory);
    }
    else if (typeof exports == "object" && typeof module == "object") { // CommonJS
        module.exports = factory;
    }
    else { // Browser
        factory(jQuery);
    }
})(function($, undefined) {
    "use strict";

    var defaultOpts = {

        // Callbacks
        beforeShow: noop,
        move: noop,
        change: noop,
        show: noop,
        hide: noop,

        // Options
        color: false,
        flat: false,
        showInput: false,
        allowEmpty: false,
        showButtons: true,
        clickoutFiresChange: true,
        showInitial: false,
        showPalette: false,
        showPaletteOnly: false,
        hideAfterPaletteSelect: false,
        togglePaletteOnly: false,
        showSelectionPalette: true,
        localStorageKey: false,
        appendTo: "body",
        maxSelectionSize: 7,
        cancelText: "cancel",
        chooseText: "choose",
        togglePaletteMoreText: "more",
        togglePaletteLessText: "less",
        clearText: "Clear Color Selection",
        noColorSelectedText: "No Color Selected",
        preferredFormat: "hsl",
        className: "", // Deprecated - use containerClassName and replacerClassName instead.
        containerClassName: "",
        replacerClassName: "",
        showAlpha: false,
        theme: "sp-light",
        palette: [["#ffffff", "#000000", "#ff0000", "#ff8000", "#ffff00", "#008000", "#0000ff", "#4b0082", "#9400d3"]],
        selectionPalette: [],
        disabled: false,
        offset: null
    },
    spectrums = [],
    IE = !!/msie/i.exec( window.navigator.userAgent ),
    rgbaSupport = (function() {
        function contains( str, substr ) {
            return !!~('' + str).indexOf(substr);
        }

        var elem = document.createElement('div');
        var style = elem.style;
        style.cssText = 'background-color:rgba(0,0,0,.5)';
        return contains(style.backgroundColor, 'rgba') || contains(style.backgroundColor, 'hsla');
    })(),
    replaceInput = [
        "<div class='sp-replacer'>",
            "<div class='sp-preview'><div class='sp-preview-inner'></div></div>",
            "<div class='sp-dd'>&#9660;</div>",
        "</div>"
    ].join(''),
    markup = (function () {

        // IE does not support gradients with multiple stops, so we need to simulate
        //  that for the rainbow slider with 8 divs that each have a single gradient
        var gradientFix = "";
        if (IE) {
            for (var i = 1; i <= 6; i++) {
                gradientFix += "<div class='sp-" + i + "'></div>";
            }
        }

        return [
            "<div class='sp-container sp-hidden'>",
                "<div class='sp-palette-container'>",
                    "<div class='sp-palette sp-thumb sp-cf'></div>",
                    "<div class='sp-palette-button-container sp-cf'>",
                        "<button type='button' class='sp-palette-toggle'></button>",
                    "</div>",
                "</div>",
                "<div class='sp-picker-container'>",
                    "<div class='sp-top sp-cf'>",
                        "<div class='sp-fill'></div>",
                        "<div class='sp-top-inner'>",
                            "<div class='sp-color'>",
                                "<div class='sp-sat'>",
                                    "<div class='sp-val'>",
                                        "<div class='sp-dragger'></div>",
                                    "</div>",
                                "</div>",
                            "</div>",
                            "<div class='sp-clear sp-clear-display'>",
                            "</div>",
                            "<div class='sp-hue'>",
                                "<div class='sp-slider'></div>",
                                gradientFix,
                            "</div>",
                        "</div>",
                        "<div class='sp-alpha'><div class='sp-alpha-inner'><div class='sp-alpha-handle'></div></div></div>",
                    "</div>",
                    "<div class='sp-input-container sp-cf'>",
                        "<input class='sp-input' type='text' spellcheck='false'  />",
                    "</div>",
                    "<div class='sp-initial sp-thumb sp-cf'></div>",
                    "<div class='sp-button-container sp-cf'>",
                        "<a class='sp-cancel' href='#'></a>",
                        "<button type='button' class='sp-choose'></button>",
                    "</div>",
                "</div>",
            "</div>"
        ].join("");
    })();

    function paletteTemplate (p, color, className, opts) {
        var html = [];
        for (var i = 0; i < p.length; i++) {
            var current = p[i];
            if(current) {
                var tiny = tinycolor(current);
                var c = tiny.toHsl().l < 0.5 ? "sp-thumb-el sp-thumb-dark" : "sp-thumb-el sp-thumb-light";
                c += (tinycolor.equals(color, current)) ? " sp-thumb-active" : "";
                var formattedString = tiny.toString(opts.preferredFormat || "rgb");
                var swatchStyle = rgbaSupport ? ("background-color:" + tiny.toRgbString()) : "filter:" + tiny.toFilter();
                html.push('<span title="' + formattedString + '" data-color="' + tiny.toRgbString() + '" class="' + c + '"><span class="sp-thumb-inner" style="' + swatchStyle + ';" /></span>');
            } else {
                var cls = 'sp-clear-display';
                html.push($('<div />')
                    .append($('<span data-color="" style="background-color:transparent;" class="' + cls + '"></span>')
                        .attr('title', opts.noColorSelectedText)
                    )
                    .html()
                );
            }
        }
        return "<div class='sp-cf " + className + "'>" + html.join('') + "</div>";
    }

    function hideAll() {
        for (var i = 0; i < spectrums.length; i++) {
            if (spectrums[i]) {
                spectrums[i].hide();
            }
        }
    }

    function instanceOptions(o, callbackContext) {
        var opts = $.extend({}, defaultOpts, o);
        opts.callbacks = {
            'move': bind(opts.move, callbackContext),
            'change': bind(opts.change, callbackContext),
            'show': bind(opts.show, callbackContext),
            'hide': bind(opts.hide, callbackContext),
            'beforeShow': bind(opts.beforeShow, callbackContext)
        };

        return opts;
    }

    function spectrum(element, o) {

        var opts = instanceOptions(o, element),
            flat = opts.flat,
            showSelectionPalette = opts.showSelectionPalette,
            localStorageKey = opts.localStorageKey,
            theme = opts.theme,
            callbacks = opts.callbacks,
            resize = throttle(reflow, 10),
            visible = false,
            isDragging = false,
            dragWidth = 0,
            dragHeight = 0,
            dragHelperHeight = 0,
            slideHeight = 0,
            slideWidth = 0,
            alphaWidth = 0,
            alphaSlideHelperWidth = 0,
            slideHelperHeight = 0,
            currentHue = 0,
            currentSaturation = 0,
            currentValue = 0,
            currentAlpha = 1,
            palette = [],
            paletteArray = [],
            paletteLookup = {},
            selectionPalette = opts.selectionPalette.slice(0),
            maxSelectionSize = opts.maxSelectionSize,
            draggingClass = "sp-dragging",
            shiftMovementDirection = null;

        var doc = element.ownerDocument,
            body = doc.body,
            boundElement = $(element),
            disabled = false,
            container = $(markup, doc).addClass(theme),
            pickerContainer = container.find(".sp-picker-container"),
            dragger = container.find(".sp-color"),
            dragHelper = container.find(".sp-dragger"),
            slider = container.find(".sp-hue"),
            slideHelper = container.find(".sp-slider"),
            alphaSliderInner = container.find(".sp-alpha-inner"),
            alphaSlider = container.find(".sp-alpha"),
            alphaSlideHelper = container.find(".sp-alpha-handle"),
            textInput = container.find(".sp-input"),
            paletteContainer = container.find(".sp-palette"),
            initialColorContainer = container.find(".sp-initial"),
            cancelButton = container.find(".sp-cancel"),
            clearButton = container.find(".sp-clear"),
            chooseButton = container.find(".sp-choose"),
            toggleButton = container.find(".sp-palette-toggle"),
            isInput = boundElement.is("input"),
            isInputTypeColor = isInput && boundElement.attr("type") === "color" && inputTypeColorSupport(),
            shouldReplace = isInput && !flat,
            replacer = (shouldReplace) ? $(replaceInput).addClass(theme).addClass(opts.className).addClass(opts.replacerClassName) : $([]),
            offsetElement = (shouldReplace) ? replacer : boundElement,
            previewElement = replacer.find(".sp-preview-inner"),
            initialColor = opts.color || (isInput && boundElement.val()),
            colorOnShow = false,
            preferredFormat = opts.preferredFormat,
            currentPreferredFormat = preferredFormat,
            clickoutFiresChange = !opts.showButtons || opts.clickoutFiresChange,
            isEmpty = !initialColor,
            allowEmpty = opts.allowEmpty && !isInputTypeColor;

        function applyOptions() {

            if (opts.showPaletteOnly) {
                opts.showPalette = true;
            }

            toggleButton.text(opts.showPaletteOnly ? opts.togglePaletteMoreText : opts.togglePaletteLessText);

            if (opts.palette) {
                palette = opts.palette.slice(0);
                paletteArray = $.isArray(palette[0]) ? palette : [palette];
                paletteLookup = {};
                for (var i = 0; i < paletteArray.length; i++) {
                    for (var j = 0; j < paletteArray[i].length; j++) {
                        var rgb = tinycolor(paletteArray[i][j]).toRgbString();
                        paletteLookup[rgb] = true;
                    }
                }
            }

            container.toggleClass("sp-flat", flat);
            container.toggleClass("sp-input-disabled", !opts.showInput);
            container.toggleClass("sp-alpha-enabled", opts.showAlpha);
            container.toggleClass("sp-clear-enabled", allowEmpty);
            container.toggleClass("sp-buttons-disabled", !opts.showButtons);
            container.toggleClass("sp-palette-buttons-disabled", !opts.togglePaletteOnly);
            container.toggleClass("sp-palette-disabled", !opts.showPalette);
            container.toggleClass("sp-palette-only", opts.showPaletteOnly);
            container.toggleClass("sp-initial-disabled", !opts.showInitial);
            container.addClass(opts.className).addClass(opts.containerClassName);

            reflow();
        }

        function initialize() {

            if (IE) {
                container.find("*:not(input)").attr("unselectable", "on");
            }

            applyOptions();

            if (shouldReplace) {
                boundElement.after(replacer).hide();
            }

            if (!allowEmpty) {
                clearButton.hide();
            }

            if (flat) {
                boundElement.after(container).hide();
            }
            else {

                var appendTo = opts.appendTo === "parent" ? boundElement.parent() : $(opts.appendTo);
                if (appendTo.length !== 1) {
                    appendTo = $("body");
                }

                appendTo.append(container);
            }

            updateSelectionPaletteFromStorage();

            offsetElement.bind("click.spectrum touchstart.spectrum", function (e) {
                if (!disabled) {
                    toggle();
                }

                e.stopPropagation();

                if (!$(e.target).is("input")) {
                    e.preventDefault();
                }
            });

            if(boundElement.is(":disabled") || (opts.disabled === true)) {
                disable();
            }

            // Prevent clicks from bubbling up to document.  This would cause it to be hidden.
            container.click(stopPropagation);

            // Handle user typed input
            textInput.change(setFromTextInput);
            textInput.bind("paste", function () {
                setTimeout(setFromTextInput, 1);
            });
            textInput.keydown(function (e) { if (e.keyCode == 13) { setFromTextInput(); } });

            cancelButton.text(opts.cancelText);
            cancelButton.bind("click.spectrum", function (e) {
                e.stopPropagation();
                e.preventDefault();
                revert();
                hide();
            });

            clearButton.attr("title", opts.clearText);
            clearButton.bind("click.spectrum", function (e) {
                e.stopPropagation();
                e.preventDefault();
                isEmpty = true;
                move();

                if(flat) {
                    //for the flat style, this is a change event
                    updateOriginalInput(true);
                }
            });

            chooseButton.text(opts.chooseText);
            chooseButton.bind("click.spectrum", function (e) {
                e.stopPropagation();
                e.preventDefault();

                if (IE && textInput.is(":focus")) {
                    textInput.trigger('change');
                }

                if (isValid()) {
                    updateOriginalInput(true);
                    hide();
                }
            });

            toggleButton.text(opts.showPaletteOnly ? opts.togglePaletteMoreText : opts.togglePaletteLessText);
            toggleButton.bind("click.spectrum", function (e) {
                e.stopPropagation();
                e.preventDefault();

                opts.showPaletteOnly = !opts.showPaletteOnly;

                // To make sure the Picker area is drawn on the right, next to the
                // Palette area (and not below the palette), first move the Palette
                // to the left to make space for the picker, plus 5px extra.
                // The 'applyOptions' function puts the whole container back into place
                // and takes care of the button-text and the sp-palette-only CSS class.
                if (!opts.showPaletteOnly && !flat) {
                    container.css('left', '-=' + (pickerContainer.outerWidth(true) + 5));
                }
                applyOptions();
            });

            draggable(alphaSlider, function (dragX, dragY, e) {
                currentAlpha = (dragX / alphaWidth);
                isEmpty = false;
                if (e.shiftKey) {
                    currentAlpha = Math.round(currentAlpha * 10) / 10;
                }

                move();
            }, dragStart, dragStop);

            draggable(slider, function (dragX, dragY) {
                currentHue = parseFloat(dragY / slideHeight);
                isEmpty = false;
                if (!opts.showAlpha) {
                    currentAlpha = 1;
                }
                move();
            }, dragStart, dragStop);

            draggable(dragger, function (dragX, dragY, e) {

                // shift+drag should snap the movement to either the x or y axis.
                if (!e.shiftKey) {
                    shiftMovementDirection = null;
                }
                else if (!shiftMovementDirection) {
                    var oldDragX = currentSaturation * dragWidth;
                    var oldDragY = dragHeight - (currentValue * dragHeight);
                    var furtherFromX = Math.abs(dragX - oldDragX) > Math.abs(dragY - oldDragY);

                    shiftMovementDirection = furtherFromX ? "x" : "y";
                }

                var setSaturation = !shiftMovementDirection || shiftMovementDirection === "x";
                var setValue = !shiftMovementDirection || shiftMovementDirection === "y";

                if (setSaturation) {
                    currentSaturation = parseFloat(dragX / dragWidth);
                }
                if (setValue) {
                    currentValue = parseFloat((dragHeight - dragY) / dragHeight);
                }

                isEmpty = false;
                if (!opts.showAlpha) {
                    currentAlpha = 1;
                }

                move();

            }, dragStart, dragStop);

            if (!!initialColor) {
                set(initialColor);

                // In case color was black - update the preview UI and set the format
                // since the set function will not run (default color is black).
                updateUI();
                currentPreferredFormat = preferredFormat || tinycolor(initialColor).format;

                addColorToSelectionPalette(initialColor);
            }
            else {
                updateUI();
            }

            if (flat) {
                show();
            }

            function paletteElementClick(e) {
                if (e.data && e.data.ignore) {
                    set($(e.target).closest(".sp-thumb-el").data("color"));
                    move();
                }
                else {
                    set($(e.target).closest(".sp-thumb-el").data("color"));
                    move();
                    updateOriginalInput(true);
                    if (opts.hideAfterPaletteSelect) {
                      hide();
                    }
                }

                return false;
            }

            var paletteEvent = IE ? "mousedown.spectrum" : "click.spectrum touchstart.spectrum";
            paletteContainer.delegate(".sp-thumb-el", paletteEvent, paletteElementClick);
            initialColorContainer.delegate(".sp-thumb-el:nth-child(1)", paletteEvent, { ignore: true }, paletteElementClick);
        }

        function updateSelectionPaletteFromStorage() {

            if (localStorageKey && window.localStorage) {

                // Migrate old palettes over to new format.  May want to remove this eventually.
                try {
                    var oldPalette = window.localStorage[localStorageKey].split(",#");
                    if (oldPalette.length > 1) {
                        delete window.localStorage[localStorageKey];
                        $.each(oldPalette, function(i, c) {
                             addColorToSelectionPalette(c);
                        });
                    }
                }
                catch(e) { }

                try {
                    selectionPalette = window.localStorage[localStorageKey].split(";");
                }
                catch (e) { }
            }
        }

        function addColorToSelectionPalette(color) {
            if (showSelectionPalette) {
                var rgb = tinycolor(color).toRgbString();
                if (!paletteLookup[rgb] && $.inArray(rgb, selectionPalette) === -1) {
                    selectionPalette.push(rgb);
                    while(selectionPalette.length > maxSelectionSize) {
                        selectionPalette.shift();
                    }
                }

                if (localStorageKey && window.localStorage) {
                    try {
                        window.localStorage[localStorageKey] = selectionPalette.join(";");
                    }
                    catch(e) { }
                }
            }
        }

        function getUniqueSelectionPalette() {
            var unique = [];
            if (opts.showPalette) {
                for (var i = 0; i < selectionPalette.length; i++) {
                    var rgb = tinycolor(selectionPalette[i]).toRgbString();

                    if (!paletteLookup[rgb]) {
                        unique.push(selectionPalette[i]);
                    }
                }
            }

            return unique.reverse().slice(0, opts.maxSelectionSize);
        }

        function drawPalette() {

            var currentColor = get();

            var html = $.map(paletteArray, function (palette, i) {
                return paletteTemplate(palette, currentColor, "sp-palette-row sp-palette-row-" + i, opts);
            });

            updateSelectionPaletteFromStorage();

            if (selectionPalette) {
                html.push(paletteTemplate(getUniqueSelectionPalette(), currentColor, "sp-palette-row sp-palette-row-selection", opts));
            }

            paletteContainer.html(html.join(""));
        }

        function drawInitial() {
            if (opts.showInitial) {
                var initial = colorOnShow;
                var current = get();
                initialColorContainer.html(paletteTemplate([initial, current], current, "sp-palette-row-initial", opts));
            }
        }

        function dragStart() {
            if (dragHeight <= 0 || dragWidth <= 0 || slideHeight <= 0) {
                reflow();
            }
            isDragging = true;
            container.addClass(draggingClass);
            shiftMovementDirection = null;
            boundElement.trigger('dragstart.spectrum', [ get() ]);
        }

        function dragStop() {
            isDragging = false;
            container.removeClass(draggingClass);
            boundElement.trigger('dragstop.spectrum', [ get() ]);
        }

        function setFromTextInput() {

            var value = textInput.val();

            if ((value === null || value === "") && allowEmpty) {
                set(null);
                updateOriginalInput(true);
            }
            else {
                var tiny = tinycolor(value);
                if (tiny.isValid()) {
                    set(tiny);
                    updateOriginalInput(true);
                }
                else {
                    textInput.addClass("sp-validation-error");
                }
            }
        }

        function toggle() {
            if (visible) {
                hide();
            }
            else {
                show();
            }
        }

        function show() {
            var event = $.Event('beforeShow.spectrum');

            if (visible) {
                reflow();
                return;
            }

            boundElement.trigger(event, [ get() ]);

            if (callbacks.beforeShow(get()) === false || event.isDefaultPrevented()) {
                return;
            }

            hideAll();
            visible = true;

            $(doc).bind("keydown.spectrum", onkeydown);
            $(doc).bind("click.spectrum", clickout);
            $(window).bind("resize.spectrum", resize);
            replacer.addClass("sp-active");
            container.removeClass("sp-hidden");

            reflow();
            updateUI();

            colorOnShow = get();

            drawInitial();
            callbacks.show(colorOnShow);
            boundElement.trigger('show.spectrum', [ colorOnShow ]);
        }

        function onkeydown(e) {
            // Close on ESC
            if (e.keyCode === 27) {
                hide();
            }
        }

        function clickout(e) {
            // Return on right click.
            if (e.button == 2) { return; }

            // If a drag event was happening during the mouseup, don't hide
            // on click.
            if (isDragging) { return; }

            if (clickoutFiresChange) {
                updateOriginalInput(true);
            }
            else {
                revert();
            }
            hide();
        }

        function hide() {
            // Return if hiding is unnecessary
            if (!visible || flat) { return; }
            visible = false;

            $(doc).unbind("keydown.spectrum", onkeydown);
            $(doc).unbind("click.spectrum", clickout);
            $(window).unbind("resize.spectrum", resize);

            replacer.removeClass("sp-active");
            container.addClass("sp-hidden");

            callbacks.hide(get());
            boundElement.trigger('hide.spectrum', [ get() ]);
        }

        function revert() {
            set(colorOnShow, true);
        }

        function set(color, ignoreFormatChange) {
            if (tinycolor.equals(color, get())) {
                // Update UI just in case a validation error needs
                // to be cleared.
                updateUI();
                return;
            }

            var newColor, newHsv;
            if (!color && allowEmpty) {
                isEmpty = true;
            } else {
                isEmpty = false;
                newColor = tinycolor(color);
                newHsv = newColor.toHsv();

                currentHue = (newHsv.h % 360) / 360;
                currentSaturation = newHsv.s;
                currentValue = newHsv.v;
                currentAlpha = newHsv.a;
            }
            updateUI();

            if (newColor && newColor.isValid() && !ignoreFormatChange) {
                currentPreferredFormat = preferredFormat || newColor.getFormat();
            }
        }

        function get(opts) {
            opts = opts || { };

            if (allowEmpty && isEmpty) {
                return null;
            }

            return tinycolor.fromRatio({
                h: currentHue,
                s: currentSaturation,
                v: currentValue,
                a: Math.round(currentAlpha * 100) / 100
            }, { format: opts.format || currentPreferredFormat });
        }

        function isValid() {
            return !textInput.hasClass("sp-validation-error");
        }

        function move() {
            updateUI();

            callbacks.move(get());
            boundElement.trigger('move.spectrum', [ get() ]);
        }

        function updateUI() {

            textInput.removeClass("sp-validation-error");

            updateHelperLocations();

            // Update dragger background color (gradients take care of saturation and value).
            var flatColor = tinycolor.fromRatio({ h: currentHue, s: 1, v: 1 });
            dragger.css("background-color", flatColor.toHexString());

            // Get a format that alpha will be included in (hex and names ignore alpha)
            var format = currentPreferredFormat;
            if (currentAlpha < 1 && !(currentAlpha === 0 && format === "name")) {
                if (format === "hex" || format === "hex3" || format === "hex6" || format === "name") {
                    format = "rgb";
                }
            }

            var realColor = get({ format: format }),
                displayColor = '';

             //reset background info for preview element
            previewElement.removeClass("sp-clear-display");
            previewElement.css('background-color', 'transparent');

            if (!realColor && allowEmpty) {
                // Update the replaced elements background with icon indicating no color selection
                previewElement.addClass("sp-clear-display");
            }
            else {
                var realHex = realColor.toHexString(),
                    realRgb = realColor.toRgbString();

                // Update the replaced elements background color (with actual selected color)
                if (rgbaSupport || realColor.alpha === 1) {
                    previewElement.css("background-color", realRgb);
                }
                else {
                    previewElement.css("background-color", "transparent");
                    previewElement.css("filter", realColor.toFilter());
                }

                if (opts.showAlpha) {
                    var rgb = realColor.toRgb();
                    rgb.a = 0;
                    var realAlpha = tinycolor(rgb).toRgbString();
                    var gradient = "linear-gradient(left, " + realAlpha + ", " + realHex + ")";

                    if (IE) {
                        alphaSliderInner.css("filter", tinycolor(realAlpha).toFilter({ gradientType: 1 }, realHex));
                    }
                    else {
                        alphaSliderInner.css("background", "-webkit-" + gradient);
                        alphaSliderInner.css("background", "-moz-" + gradient);
                        alphaSliderInner.css("background", "-ms-" + gradient);
                        // Use current syntax gradient on unprefixed property.
                        alphaSliderInner.css("background",
                            "linear-gradient(to right, " + realAlpha + ", " + realHex + ")");
                    }
                }

                displayColor = realColor.toString(format);
            }

            // Update the text entry input as it changes happen
            if (opts.showInput) {
                textInput.val(displayColor);
            }

            if (opts.showPalette) {
                drawPalette();
            }

            drawInitial();
        }

        function updateHelperLocations() {
            var s = currentSaturation;
            var v = currentValue;

            if(allowEmpty && isEmpty) {
                //if selected color is empty, hide the helpers
                alphaSlideHelper.hide();
                slideHelper.hide();
                dragHelper.hide();
            }
            else {
                //make sure helpers are visible
                alphaSlideHelper.show();
                slideHelper.show();
                dragHelper.show();

                // Where to show the little circle in that displays your current selected color
                var dragX = s * dragWidth;
                var dragY = dragHeight - (v * dragHeight);
                dragX = Math.max(
                    -dragHelperHeight,
                    Math.min(dragWidth - dragHelperHeight, dragX - dragHelperHeight)
                );
                dragY = Math.max(
                    -dragHelperHeight,
                    Math.min(dragHeight - dragHelperHeight, dragY - dragHelperHeight)
                );
                dragHelper.css({
                    "top": dragY + "px",
                    "left": dragX + "px"
                });

                var alphaX = currentAlpha * alphaWidth;
                alphaSlideHelper.css({
                    "left": (alphaX - (alphaSlideHelperWidth / 2)) + "px"
                });

                // Where to show the bar that displays your current selected hue
                var slideY = (currentHue) * slideHeight;
                slideHelper.css({
                    "top": (slideY - slideHelperHeight) + "px"
                });
            }
        }

        function updateOriginalInput(fireCallback) {
            var color = get(),
                displayColor = '',
                hasChanged = !tinycolor.equals(color, colorOnShow);

            if (color) {
                displayColor = color.toString(currentPreferredFormat);
                // Update the selection palette with the current color
                addColorToSelectionPalette(color);
            }

            if (isInput) {
                boundElement.val(displayColor);
            }

            if (fireCallback && hasChanged) {
                callbacks.change(color);
                boundElement.trigger('change', [ color ]);
            }
        }

        function reflow() {
            dragWidth = dragger.width();
            dragHeight = dragger.height();
            dragHelperHeight = dragHelper.height();
            slideWidth = slider.width();
            slideHeight = slider.height();
            slideHelperHeight = slideHelper.height();
            alphaWidth = alphaSlider.width();
            alphaSlideHelperWidth = alphaSlideHelper.width();

            if (!flat) {
                container.css("position", "absolute");
                if (opts.offset) {
                    container.offset(opts.offset);
                } else {
                    container.offset(getOffset(container, offsetElement));
                }
            }

            updateHelperLocations();

            if (opts.showPalette) {
                drawPalette();
            }

            boundElement.trigger('reflow.spectrum');
        }

        function destroy() {
            boundElement.show();
            offsetElement.unbind("click.spectrum touchstart.spectrum");
            container.remove();
            replacer.remove();
            spectrums[spect.id] = null;
        }

        function option(optionName, optionValue) {
            if (optionName === undefined) {
                return $.extend({}, opts);
            }
            if (optionValue === undefined) {
                return opts[optionName];
            }

            opts[optionName] = optionValue;
            applyOptions();
        }

        function enable() {
            disabled = false;
            boundElement.attr("disabled", false);
            offsetElement.removeClass("sp-disabled");
        }

        function disable() {
            hide();
            disabled = true;
            boundElement.attr("disabled", true);
            offsetElement.addClass("sp-disabled");
        }

        function setOffset(coord) {
            opts.offset = coord;
            reflow();
        }

        initialize();

        var spect = {
            show: show,
            hide: hide,
            toggle: toggle,
            reflow: reflow,
            option: option,
            enable: enable,
            disable: disable,
            offset: setOffset,
            set: function (c) {
                set(c);
                updateOriginalInput();
            },
            get: get,
            destroy: destroy,
            container: container
        };

        spect.id = spectrums.push(spect) - 1;

        return spect;
    }

    /**
    * checkOffset - get the offset below/above and left/right element depending on screen position
    * Thanks https://github.com/jquery/jquery-ui/blob/master/ui/jquery.ui.datepicker.js
    */
    function getOffset(picker, input) {
        var extraY = 0;
        var dpWidth = picker.outerWidth();
        var dpHeight = picker.outerHeight();
        var inputHeight = input.outerHeight();
        var doc = picker[0].ownerDocument;
        var docElem = doc.documentElement;
        var viewWidth = docElem.clientWidth + $(doc).scrollLeft();
        var viewHeight = docElem.clientHeight + $(doc).scrollTop();
        var offset = input.offset();
        offset.top += inputHeight;

        offset.left -=
            Math.min(offset.left, (offset.left + dpWidth > viewWidth && viewWidth > dpWidth) ?
            Math.abs(offset.left + dpWidth - viewWidth) : 0);

        offset.top -=
            Math.min(offset.top, ((offset.top + dpHeight > viewHeight && viewHeight > dpHeight) ?
            Math.abs(dpHeight + inputHeight - extraY) : extraY));

        return offset;
    }

    /**
    * noop - do nothing
    */
    function noop() {

    }

    /**
    * stopPropagation - makes the code only doing this a little easier to read in line
    */
    function stopPropagation(e) {
        e.stopPropagation();
    }

    /**
    * Create a function bound to a given object
    * Thanks to underscore.js
    */
    function bind(func, obj) {
        var slice = Array.prototype.slice;
        var args = slice.call(arguments, 2);
        return function () {
            return func.apply(obj, args.concat(slice.call(arguments)));
        };
    }

    /**
    * Lightweight drag helper.  Handles containment within the element, so that
    * when dragging, the x is within [0,element.width] and y is within [0,element.height]
    */
    function draggable(element, onmove, onstart, onstop) {
        onmove = onmove || function () { };
        onstart = onstart || function () { };
        onstop = onstop || function () { };
        var doc = document;
        var dragging = false;
        var offset = {};
        var maxHeight = 0;
        var maxWidth = 0;
        var hasTouch = ('ontouchstart' in window);

        var duringDragEvents = {};
        duringDragEvents["selectstart"] = prevent;
        duringDragEvents["dragstart"] = prevent;
        duringDragEvents["touchmove mousemove"] = move;
        duringDragEvents["touchend mouseup"] = stop;

        function prevent(e) {
            if (e.stopPropagation) {
                e.stopPropagation();
            }
            if (e.preventDefault) {
                e.preventDefault();
            }
            e.returnValue = false;
        }

        function move(e) {
            if (dragging) {
                // Mouseup happened outside of window
                if (IE && doc.documentMode < 9 && !e.button) {
                    return stop();
                }

                var t0 = e.originalEvent && e.originalEvent.touches && e.originalEvent.touches[0];
                var pageX = t0 && t0.pageX || e.pageX;
                var pageY = t0 && t0.pageY || e.pageY;

                var dragX = Math.max(0, Math.min(pageX - offset.left, maxWidth));
                var dragY = Math.max(0, Math.min(pageY - offset.top, maxHeight));

                if (hasTouch) {
                    // Stop scrolling in iOS
                    prevent(e);
                }

                onmove.apply(element, [dragX, dragY, e]);
            }
        }

        function start(e) {
            var rightclick = (e.which) ? (e.which == 3) : (e.button == 2);

            if (!rightclick && !dragging) {
                if (onstart.apply(element, arguments) !== false) {
                    dragging = true;
                    maxHeight = $(element).height();
                    maxWidth = $(element).width();
                    offset = $(element).offset();

                    $(doc).bind(duringDragEvents);
                    $(doc.body).addClass("sp-dragging");

                    move(e);

                    prevent(e);
                }
            }
        }

        function stop() {
            if (dragging) {
                $(doc).unbind(duringDragEvents);
                $(doc.body).removeClass("sp-dragging");

                // Wait a tick before notifying observers to allow the click event
                // to fire in Chrome.
                setTimeout(function() {
                    onstop.apply(element, arguments);
                }, 0);
            }
            dragging = false;
        }

        $(element).bind("touchstart mousedown", start);
    }

    function throttle(func, wait, debounce) {
        var timeout;
        return function () {
            var context = this, args = arguments;
            var throttler = function () {
                timeout = null;
                func.apply(context, args);
            };
            if (debounce) clearTimeout(timeout);
            if (debounce || !timeout) timeout = setTimeout(throttler, wait);
        };
    }

    function inputTypeColorSupport() {
        return $.fn.spectrum.inputTypeColorSupport();
    }

    /**
    * Define a jQuery plugin
    */
    var dataID = "spectrum.id";
    $.fn.spectrum = function (opts, extra) {

        if (typeof opts == "string") {

            var returnValue = this;
            var args = Array.prototype.slice.call( arguments, 1 );

            this.each(function () {
                var spect = spectrums[$(this).data(dataID)];
                if (spect) {
                    var method = spect[opts];
                    if (!method) {
                        throw new Error( "Spectrum: no such method: '" + opts + "'" );
                    }

                    if (opts == "get") {
                        returnValue = spect.get();
                    }
                    else if (opts == "container") {
                        returnValue = spect.container;
                    }
                    else if (opts == "option") {
                        returnValue = spect.option.apply(spect, args);
                    }
                    else if (opts == "destroy") {
                        spect.destroy();
                        $(this).removeData(dataID);
                    }
                    else {
                        method.apply(spect, args);
                    }
                }
            });

            return returnValue;
        }

        // Initializing a new instance of spectrum
        return this.spectrum("destroy").each(function () {
            var options = $.extend({}, opts, $(this).data());
            var spect = spectrum(this, options);
            $(this).data(dataID, spect.id);
        });
    };

    $.fn.spectrum.load = true;
    $.fn.spectrum.loadOpts = {};
    $.fn.spectrum.draggable = draggable;
    $.fn.spectrum.defaults = defaultOpts;
    $.fn.spectrum.inputTypeColorSupport = function inputTypeColorSupport() {
        if (typeof inputTypeColorSupport._cachedResult === "undefined") {
            var colorInput = $("<input type='color'/>")[0]; // if color element is supported, value will default to not null
            inputTypeColorSupport._cachedResult = colorInput.type === "color" && colorInput.value !== "";
        }
        return inputTypeColorSupport._cachedResult;
    };

    $.spectrum = { };
    $.spectrum.localization = { };
    $.spectrum.palettes = { };

    $.fn.spectrum.processNativeColorInputs = function () {
        var colorInputs = $("input[type=color]");
        if (colorInputs.length && !inputTypeColorSupport()) {
            colorInputs.spectrum({
                preferredFormat: "hex6"
            });
        }
    };

    // TinyColor v1.1.2
    // https://github.com/bgrins/TinyColor
    // Brian Grinstead, MIT License

    (function() {

    var trimLeft = /^[\s,#]+/,
        trimRight = /\s+$/,
        tinyCounter = 0,
        math = Math,
        mathRound = math.round,
        mathMin = math.min,
        mathMax = math.max,
        mathRandom = math.random;

    var tinycolor = function(color, opts) {

        color = (color) ? color : '';
        opts = opts || { };

        // If input is already a tinycolor, return itself
        if (color instanceof tinycolor) {
           return color;
        }
        // If we are called as a function, call using new instead
        if (!(this instanceof tinycolor)) {
            return new tinycolor(color, opts);
        }

        var rgb = inputToRGB(color);
        this._originalInput = color,
        this._r = rgb.r,
        this._g = rgb.g,
        this._b = rgb.b,
        this._a = rgb.a,
        this._roundA = mathRound(100*this._a) / 100,
        this._format = opts.format || rgb.format;
        this._gradientType = opts.gradientType;

        // Don't let the range of [0,255] come back in [0,1].
        // Potentially lose a little bit of precision here, but will fix issues where
        // .5 gets interpreted as half of the total, instead of half of 1
        // If it was supposed to be 128, this was already taken care of by `inputToRgb`
        if (this._r < 1) { this._r = mathRound(this._r); }
        if (this._g < 1) { this._g = mathRound(this._g); }
        if (this._b < 1) { this._b = mathRound(this._b); }

        this._ok = rgb.ok;
        this._tc_id = tinyCounter++;
    };

    tinycolor.prototype = {
        isDark: function() {
            return this.getBrightness() < 128;
        },
        isLight: function() {
            return !this.isDark();
        },
        isValid: function() {
            return this._ok;
        },
        getOriginalInput: function() {
          return this._originalInput;
        },
        getFormat: function() {
            return this._format;
        },
        getAlpha: function() {
            return this._a;
        },
        getBrightness: function() {
            var rgb = this.toRgb();
            return (rgb.r * 299 + rgb.g * 587 + rgb.b * 114) / 1000;
        },
        setAlpha: function(value) {
            this._a = boundAlpha(value);
            this._roundA = mathRound(100*this._a) / 100;
            return this;
        },
        toHsv: function() {
            var hsv = rgbToHsv(this._r, this._g, this._b);
            return { h: hsv.h * 360, s: hsv.s, v: hsv.v, a: this._a };
        },
        toHsvString: function() {
            var hsv = rgbToHsv(this._r, this._g, this._b);
            var h = mathRound(hsv.h * 360), s = mathRound(hsv.s * 100), v = mathRound(hsv.v * 100);
            return (this._a == 1) ?
              "hsv("  + h + ", " + s + "%, " + v + "%)" :
              "hsva(" + h + ", " + s + "%, " + v + "%, "+ this._roundA + ")";
        },
        toHsl: function() {
            var hsl = rgbToHsl(this._r, this._g, this._b);
            return { h: hsl.h * 360, s: hsl.s, l: hsl.l, a: this._a };
        },
        toHslString: function() {
            var hsl = rgbToHsl(this._r, this._g, this._b);
            var h = mathRound(hsl.h * 360), s = mathRound(hsl.s * 100), l = mathRound(hsl.l * 100);
            return (this._a == 1) ?
              "hsl("  + h + ", " + s + "%, " + l + "%)" :
              "hsla(" + h + ", " + s + "%, " + l + "%, "+ this._roundA + ")";
        },
        toHex: function(allow3Char) {
            return rgbToHex(this._r, this._g, this._b, allow3Char);
        },
        toHexString: function(allow3Char) {
            return '#' + this.toHex(allow3Char);
        },
        toHex8: function() {
            return rgbaToHex(this._r, this._g, this._b, this._a);
        },
        toHex8String: function() {
            return '#' + this.toHex8();
        },
        toRgb: function() {
            return { r: mathRound(this._r), g: mathRound(this._g), b: mathRound(this._b), a: this._a };
        },
        toRgbString: function() {
            return (this._a == 1) ?
              "rgb("  + mathRound(this._r) + ", " + mathRound(this._g) + ", " + mathRound(this._b) + ")" :
              "rgba(" + mathRound(this._r) + ", " + mathRound(this._g) + ", " + mathRound(this._b) + ", " + this._roundA + ")";
        },
        toPercentageRgb: function() {
            return { r: mathRound(bound01(this._r, 255) * 100) + "%", g: mathRound(bound01(this._g, 255) * 100) + "%", b: mathRound(bound01(this._b, 255) * 100) + "%", a: this._a };
        },
        toPercentageRgbString: function() {
            return (this._a == 1) ?
              "rgb("  + mathRound(bound01(this._r, 255) * 100) + "%, " + mathRound(bound01(this._g, 255) * 100) + "%, " + mathRound(bound01(this._b, 255) * 100) + "%)" :
              "rgba(" + mathRound(bound01(this._r, 255) * 100) + "%, " + mathRound(bound01(this._g, 255) * 100) + "%, " + mathRound(bound01(this._b, 255) * 100) + "%, " + this._roundA + ")";
        },
        toName: function() {
            if (this._a === 0) {
                return "transparent";
            }

            if (this._a < 1) {
                return false;
            }

            return hexNames[rgbToHex(this._r, this._g, this._b, true)] || false;
        },
        toFilter: function(secondColor) {
            var hex8String = '#' + rgbaToHex(this._r, this._g, this._b, this._a);
            var secondHex8String = hex8String;
            var gradientType = this._gradientType ? "GradientType = 1, " : "";

            if (secondColor) {
                var s = tinycolor(secondColor);
                secondHex8String = s.toHex8String();
            }

            return "progid:DXImageTransform.Microsoft.gradient("+gradientType+"startColorstr="+hex8String+",endColorstr="+secondHex8String+")";
        },
        toString: function(format) {
            var formatSet = !!format;
            format = format || this._format;

            var formattedString = false;
            var hasAlpha = this._a < 1 && this._a >= 0;
            var needsAlphaFormat = !formatSet && hasAlpha && (format === "hex" || format === "hex6" || format === "hex3" || format === "name");

            if (needsAlphaFormat) {
                // Special case for "transparent", all other non-alpha formats
                // will return rgba when there is transparency.
                if (format === "name" && this._a === 0) {
                    return this.toName();
                }
                return this.toRgbString();
            }
            if (format === "rgb") {
                formattedString = this.toRgbString();
            }
            if (format === "prgb") {
                formattedString = this.toPercentageRgbString();
            }
            if (format === "hex" || format === "hex6") {
                formattedString = this.toHexString();
            }
            if (format === "hex3") {
                formattedString = this.toHexString(true);
            }
            if (format === "hex8") {
                formattedString = this.toHex8String();
            }
            if (format === "name") {
                formattedString = this.toName();
            }
            if (format === "hsl") {
                formattedString = this.toHslString();
            }
            if (format === "hsv") {
                formattedString = this.toHsvString();
            }

            return formattedString || this.toHexString();
        },

        _applyModification: function(fn, args) {
            var color = fn.apply(null, [this].concat([].slice.call(args)));
            this._r = color._r;
            this._g = color._g;
            this._b = color._b;
            this.setAlpha(color._a);
            return this;
        },
        lighten: function() {
            return this._applyModification(lighten, arguments);
        },
        brighten: function() {
            return this._applyModification(brighten, arguments);
        },
        darken: function() {
            return this._applyModification(darken, arguments);
        },
        desaturate: function() {
            return this._applyModification(desaturate, arguments);
        },
        saturate: function() {
            return this._applyModification(saturate, arguments);
        },
        greyscale: function() {
            return this._applyModification(greyscale, arguments);
        },
        spin: function() {
            return this._applyModification(spin, arguments);
        },

        _applyCombination: function(fn, args) {
            return fn.apply(null, [this].concat([].slice.call(args)));
        },
        analogous: function() {
            return this._applyCombination(analogous, arguments);
        },
        complement: function() {
            return this._applyCombination(complement, arguments);
        },
        monochromatic: function() {
            return this._applyCombination(monochromatic, arguments);
        },
        splitcomplement: function() {
            return this._applyCombination(splitcomplement, arguments);
        },
        triad: function() {
            return this._applyCombination(triad, arguments);
        },
        tetrad: function() {
            return this._applyCombination(tetrad, arguments);
        }
    };

    // If input is an object, force 1 into "1.0" to handle ratios properly
    // String input requires "1.0" as input, so 1 will be treated as 1
    tinycolor.fromRatio = function(color, opts) {
        if (typeof color == "object") {
            var newColor = {};
            for (var i in color) {
                if (color.hasOwnProperty(i)) {
                    if (i === "a") {
                        newColor[i] = color[i];
                    }
                    else {
                        newColor[i] = convertToPercentage(color[i]);
                    }
                }
            }
            color = newColor;
        }

        return tinycolor(color, opts);
    };

    // Given a string or object, convert that input to RGB
    // Possible string inputs:
    //
    //     "red"
    //     "#f00" or "f00"
    //     "#ff0000" or "ff0000"
    //     "#ff000000" or "ff000000"
    //     "rgb 255 0 0" or "rgb (255, 0, 0)"
    //     "rgb 1.0 0 0" or "rgb (1, 0, 0)"
    //     "rgba (255, 0, 0, 1)" or "rgba 255, 0, 0, 1"
    //     "rgba (1.0, 0, 0, 1)" or "rgba 1.0, 0, 0, 1"
    //     "hsl(0, 100%, 50%)" or "hsl 0 100% 50%"
    //     "hsla(0, 100%, 50%, 1)" or "hsla 0 100% 50%, 1"
    //     "hsv(0, 100%, 100%)" or "hsv 0 100% 100%"
    //
    function inputToRGB(color) {

        var rgb = { r: 0, g: 0, b: 0 };
        var a = 1;
        var ok = false;
        var format = false;

        if (typeof color == "string") {
            color = stringInputToObject(color);
        }

        if (typeof color == "object") {
            if (color.hasOwnProperty("r") && color.hasOwnProperty("g") && color.hasOwnProperty("b")) {
                rgb = rgbToRgb(color.r, color.g, color.b);
                ok = true;
                format = String(color.r).substr(-1) === "%" ? "prgb" : "rgb";
            }
            else if (color.hasOwnProperty("h") && color.hasOwnProperty("s") && color.hasOwnProperty("v")) {
                color.s = convertToPercentage(color.s);
                color.v = convertToPercentage(color.v);
                rgb = hsvToRgb(color.h, color.s, color.v);
                ok = true;
                format = "hsv";
            }
            else if (color.hasOwnProperty("h") && color.hasOwnProperty("s") && color.hasOwnProperty("l")) {
                color.s = convertToPercentage(color.s);
                color.l = convertToPercentage(color.l);
                rgb = hslToRgb(color.h, color.s, color.l);
                ok = true;
                format = "hsl";
            }

            if (color.hasOwnProperty("a")) {
                a = color.a;
            }
        }

        a = boundAlpha(a);

        return {
            ok: ok,
            format: color.format || format,
            r: mathMin(255, mathMax(rgb.r, 0)),
            g: mathMin(255, mathMax(rgb.g, 0)),
            b: mathMin(255, mathMax(rgb.b, 0)),
            a: a
        };
    }


    // Conversion Functions
    // --------------------

    // `rgbToHsl`, `rgbToHsv`, `hslToRgb`, `hsvToRgb` modified from:
    // <http://mjijackson.com/2008/02/rgb-to-hsl-and-rgb-to-hsv-color-model-conversion-algorithms-in-javascript>

    // `rgbToRgb`
    // Handle bounds / percentage checking to conform to CSS color spec
    // <http://www.w3.org/TR/css3-color/>
    // *Assumes:* r, g, b in [0, 255] or [0, 1]
    // *Returns:* { r, g, b } in [0, 255]
    function rgbToRgb(r, g, b){
        return {
            r: bound01(r, 255) * 255,
            g: bound01(g, 255) * 255,
            b: bound01(b, 255) * 255
        };
    }

    // `rgbToHsl`
    // Converts an RGB color value to HSL.
    // *Assumes:* r, g, and b are contained in [0, 255] or [0, 1]
    // *Returns:* { h, s, l } in [0,1]
    function rgbToHsl(r, g, b) {

        r = bound01(r, 255);
        g = bound01(g, 255);
        b = bound01(b, 255);

        var max = mathMax(r, g, b), min = mathMin(r, g, b);
        var h, s, l = (max + min) / 2;

        if(max == min) {
            h = s = 0; // achromatic
        }
        else {
            var d = max - min;
            s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
            switch(max) {
                case r: h = (g - b) / d + (g < b ? 6 : 0); break;
                case g: h = (b - r) / d + 2; break;
                case b: h = (r - g) / d + 4; break;
            }

            h /= 6;
        }

        return { h: h, s: s, l: l };
    }

    // `hslToRgb`
    // Converts an HSL color value to RGB.
    // *Assumes:* h is contained in [0, 1] or [0, 360] and s and l are contained [0, 1] or [0, 100]
    // *Returns:* { r, g, b } in the set [0, 255]
    function hslToRgb(h, s, l) {
        var r, g, b;

        h = bound01(h, 360);
        s = bound01(s, 100);
        l = bound01(l, 100);

        function hue2rgb(p, q, t) {
            if(t < 0) t += 1;
            if(t > 1) t -= 1;
            if(t < 1/6) return p + (q - p) * 6 * t;
            if(t < 1/2) return q;
            if(t < 2/3) return p + (q - p) * (2/3 - t) * 6;
            return p;
        }

        if(s === 0) {
            r = g = b = l; // achromatic
        }
        else {
            var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
            var p = 2 * l - q;
            r = hue2rgb(p, q, h + 1/3);
            g = hue2rgb(p, q, h);
            b = hue2rgb(p, q, h - 1/3);
        }

        return { r: r * 255, g: g * 255, b: b * 255 };
    }

    // `rgbToHsv`
    // Converts an RGB color value to HSV
    // *Assumes:* r, g, and b are contained in the set [0, 255] or [0, 1]
    // *Returns:* { h, s, v } in [0,1]
    function rgbToHsv(r, g, b) {

        r = bound01(r, 255);
        g = bound01(g, 255);
        b = bound01(b, 255);

        var max = mathMax(r, g, b), min = mathMin(r, g, b);
        var h, s, v = max;

        var d = max - min;
        s = max === 0 ? 0 : d / max;

        if(max == min) {
            h = 0; // achromatic
        }
        else {
            switch(max) {
                case r: h = (g - b) / d + (g < b ? 6 : 0); break;
                case g: h = (b - r) / d + 2; break;
                case b: h = (r - g) / d + 4; break;
            }
            h /= 6;
        }
        return { h: h, s: s, v: v };
    }

    // `hsvToRgb`
    // Converts an HSV color value to RGB.
    // *Assumes:* h is contained in [0, 1] or [0, 360] and s and v are contained in [0, 1] or [0, 100]
    // *Returns:* { r, g, b } in the set [0, 255]
     function hsvToRgb(h, s, v) {

        h = bound01(h, 360) * 6;
        s = bound01(s, 100);
        v = bound01(v, 100);

        var i = math.floor(h),
            f = h - i,
            p = v * (1 - s),
            q = v * (1 - f * s),
            t = v * (1 - (1 - f) * s),
            mod = i % 6,
            r = [v, q, p, p, t, v][mod],
            g = [t, v, v, q, p, p][mod],
            b = [p, p, t, v, v, q][mod];

        return { r: r * 255, g: g * 255, b: b * 255 };
    }

    // `rgbToHex`
    // Converts an RGB color to hex
    // Assumes r, g, and b are contained in the set [0, 255]
    // Returns a 3 or 6 character hex
    function rgbToHex(r, g, b, allow3Char) {

        var hex = [
            pad2(mathRound(r).toString(16)),
            pad2(mathRound(g).toString(16)),
            pad2(mathRound(b).toString(16))
        ];

        // Return a 3 character hex if possible
        if (allow3Char && hex[0].charAt(0) == hex[0].charAt(1) && hex[1].charAt(0) == hex[1].charAt(1) && hex[2].charAt(0) == hex[2].charAt(1)) {
            return hex[0].charAt(0) + hex[1].charAt(0) + hex[2].charAt(0);
        }

        return hex.join("");
    }
        // `rgbaToHex`
        // Converts an RGBA color plus alpha transparency to hex
        // Assumes r, g, b and a are contained in the set [0, 255]
        // Returns an 8 character hex
        function rgbaToHex(r, g, b, a) {

            var hex = [
                pad2(convertDecimalToHex(a)),
                pad2(mathRound(r).toString(16)),
                pad2(mathRound(g).toString(16)),
                pad2(mathRound(b).toString(16))
            ];

            return hex.join("");
        }

    // `equals`
    // Can be called with any tinycolor input
    tinycolor.equals = function (color1, color2) {
        if (!color1 || !color2) { return false; }
        return tinycolor(color1).toRgbString() == tinycolor(color2).toRgbString();
    };
    tinycolor.random = function() {
        return tinycolor.fromRatio({
            r: mathRandom(),
            g: mathRandom(),
            b: mathRandom()
        });
    };


    // Modification Functions
    // ----------------------
    // Thanks to less.js for some of the basics here
    // <https://github.com/cloudhead/less.js/blob/master/lib/less/functions.js>

    function desaturate(color, amount) {
        amount = (amount === 0) ? 0 : (amount || 10);
        var hsl = tinycolor(color).toHsl();
        hsl.s -= amount / 100;
        hsl.s = clamp01(hsl.s);
        return tinycolor(hsl);
    }

    function saturate(color, amount) {
        amount = (amount === 0) ? 0 : (amount || 10);
        var hsl = tinycolor(color).toHsl();
        hsl.s += amount / 100;
        hsl.s = clamp01(hsl.s);
        return tinycolor(hsl);
    }

    function greyscale(color) {
        return tinycolor(color).desaturate(100);
    }

    function lighten (color, amount) {
        amount = (amount === 0) ? 0 : (amount || 10);
        var hsl = tinycolor(color).toHsl();
        hsl.l += amount / 100;
        hsl.l = clamp01(hsl.l);
        return tinycolor(hsl);
    }

    function brighten(color, amount) {
        amount = (amount === 0) ? 0 : (amount || 10);
        var rgb = tinycolor(color).toRgb();
        rgb.r = mathMax(0, mathMin(255, rgb.r - mathRound(255 * - (amount / 100))));
        rgb.g = mathMax(0, mathMin(255, rgb.g - mathRound(255 * - (amount / 100))));
        rgb.b = mathMax(0, mathMin(255, rgb.b - mathRound(255 * - (amount / 100))));
        return tinycolor(rgb);
    }

    function darken (color, amount) {
        amount = (amount === 0) ? 0 : (amount || 10);
        var hsl = tinycolor(color).toHsl();
        hsl.l -= amount / 100;
        hsl.l = clamp01(hsl.l);
        return tinycolor(hsl);
    }

    // Spin takes a positive or negative amount within [-360, 360] indicating the change of hue.
    // Values outside of this range will be wrapped into this range.
    function spin(color, amount) {
        var hsl = tinycolor(color).toHsl();
        var hue = (mathRound(hsl.h) + amount) % 360;
        hsl.h = hue < 0 ? 360 + hue : hue;
        return tinycolor(hsl);
    }

    // Combination Functions
    // ---------------------
    // Thanks to jQuery xColor for some of the ideas behind these
    // <https://github.com/infusion/jQuery-xcolor/blob/master/jquery.xcolor.js>

    function complement(color) {
        var hsl = tinycolor(color).toHsl();
        hsl.h = (hsl.h + 180) % 360;
        return tinycolor(hsl);
    }

    function triad(color) {
        var hsl = tinycolor(color).toHsl();
        var h = hsl.h;
        return [
            tinycolor(color),
            tinycolor({ h: (h + 120) % 360, s: hsl.s, l: hsl.l }),
            tinycolor({ h: (h + 240) % 360, s: hsl.s, l: hsl.l })
        ];
    }

    function tetrad(color) {
        var hsl = tinycolor(color).toHsl();
        var h = hsl.h;
        return [
            tinycolor(color),
            tinycolor({ h: (h + 90) % 360, s: hsl.s, l: hsl.l }),
            tinycolor({ h: (h + 180) % 360, s: hsl.s, l: hsl.l }),
            tinycolor({ h: (h + 270) % 360, s: hsl.s, l: hsl.l })
        ];
    }

    function splitcomplement(color) {
        var hsl = tinycolor(color).toHsl();
        var h = hsl.h;
        return [
            tinycolor(color),
            tinycolor({ h: (h + 72) % 360, s: hsl.s, l: hsl.l}),
            tinycolor({ h: (h + 216) % 360, s: hsl.s, l: hsl.l})
        ];
    }

    function analogous(color, results, slices) {
        results = results || 6;
        slices = slices || 30;

        var hsl = tinycolor(color).toHsl();
        var part = 360 / slices;
        var ret = [tinycolor(color)];

        for (hsl.h = ((hsl.h - (part * results >> 1)) + 720) % 360; --results; ) {
            hsl.h = (hsl.h + part) % 360;
            ret.push(tinycolor(hsl));
        }
        return ret;
    }

    function monochromatic(color, results) {
        results = results || 6;
        var hsv = tinycolor(color).toHsv();
        var h = hsv.h, s = hsv.s, v = hsv.v;
        var ret = [];
        var modification = 1 / results;

        while (results--) {
            ret.push(tinycolor({ h: h, s: s, v: v}));
            v = (v + modification) % 1;
        }

        return ret;
    }

    // Utility Functions
    // ---------------------

    tinycolor.mix = function(color1, color2, amount) {
        amount = (amount === 0) ? 0 : (amount || 50);

        var rgb1 = tinycolor(color1).toRgb();
        var rgb2 = tinycolor(color2).toRgb();

        var p = amount / 100;
        var w = p * 2 - 1;
        var a = rgb2.a - rgb1.a;

        var w1;

        if (w * a == -1) {
            w1 = w;
        } else {
            w1 = (w + a) / (1 + w * a);
        }

        w1 = (w1 + 1) / 2;

        var w2 = 1 - w1;

        var rgba = {
            r: rgb2.r * w1 + rgb1.r * w2,
            g: rgb2.g * w1 + rgb1.g * w2,
            b: rgb2.b * w1 + rgb1.b * w2,
            a: rgb2.a * p  + rgb1.a * (1 - p)
        };

        return tinycolor(rgba);
    };


    // Readability Functions
    // ---------------------
    // <http://www.w3.org/TR/AERT#color-contrast>

    // `readability`
    // Analyze the 2 colors and returns an object with the following properties:
    //    `brightness`: difference in brightness between the two colors
    //    `color`: difference in color/hue between the two colors
    tinycolor.readability = function(color1, color2) {
        var c1 = tinycolor(color1);
        var c2 = tinycolor(color2);
        var rgb1 = c1.toRgb();
        var rgb2 = c2.toRgb();
        var brightnessA = c1.getBrightness();
        var brightnessB = c2.getBrightness();
        var colorDiff = (
            Math.max(rgb1.r, rgb2.r) - Math.min(rgb1.r, rgb2.r) +
            Math.max(rgb1.g, rgb2.g) - Math.min(rgb1.g, rgb2.g) +
            Math.max(rgb1.b, rgb2.b) - Math.min(rgb1.b, rgb2.b)
        );

        return {
            brightness: Math.abs(brightnessA - brightnessB),
            color: colorDiff
        };
    };

    // `readable`
    // http://www.w3.org/TR/AERT#color-contrast
    // Ensure that foreground and background color combinations provide sufficient contrast.
    // *Example*
    //    tinycolor.isReadable("#000", "#111") => false
    tinycolor.isReadable = function(color1, color2) {
        var readability = tinycolor.readability(color1, color2);
        return readability.brightness > 125 && readability.color > 500;
    };

    // `mostReadable`
    // Given a base color and a list of possible foreground or background
    // colors for that base, returns the most readable color.
    // *Example*
    //    tinycolor.mostReadable("#123", ["#fff", "#000"]) => "#000"
    tinycolor.mostReadable = function(baseColor, colorList) {
        var bestColor = null;
        var bestScore = 0;
        var bestIsReadable = false;
        for (var i=0; i < colorList.length; i++) {

            // We normalize both around the "acceptable" breaking point,
            // but rank brightness constrast higher than hue.

            var readability = tinycolor.readability(baseColor, colorList[i]);
            var readable = readability.brightness > 125 && readability.color > 500;
            var score = 3 * (readability.brightness / 125) + (readability.color / 500);

            if ((readable && ! bestIsReadable) ||
                (readable && bestIsReadable && score > bestScore) ||
                ((! readable) && (! bestIsReadable) && score > bestScore)) {
                bestIsReadable = readable;
                bestScore = score;
                bestColor = tinycolor(colorList[i]);
            }
        }
        return bestColor;
    };


    // Big List of Colors
    // ------------------
    // <http://www.w3.org/TR/css3-color/#svg-color>
    var names = tinycolor.names = {
        aliceblue: "f0f8ff",
        antiquewhite: "faebd7",
        aqua: "0ff",
        aquamarine: "7fffd4",
        azure: "f0ffff",
        beige: "f5f5dc",
        bisque: "ffe4c4",
        black: "000",
        blanchedalmond: "ffebcd",
        blue: "00f",
        blueviolet: "8a2be2",
        brown: "a52a2a",
        burlywood: "deb887",
        burntsienna: "ea7e5d",
        cadetblue: "5f9ea0",
        chartreuse: "7fff00",
        chocolate: "d2691e",
        coral: "ff7f50",
        cornflowerblue: "6495ed",
        cornsilk: "fff8dc",
        crimson: "dc143c",
        cyan: "0ff",
        darkblue: "00008b",
        darkcyan: "008b8b",
        darkgoldenrod: "b8860b",
        darkgray: "a9a9a9",
        darkgreen: "006400",
        darkgrey: "a9a9a9",
        darkkhaki: "bdb76b",
        darkmagenta: "8b008b",
        darkolivegreen: "556b2f",
        darkorange: "ff8c00",
        darkorchid: "9932cc",
        darkred: "8b0000",
        darksalmon: "e9967a",
        darkseagreen: "8fbc8f",
        darkslateblue: "483d8b",
        darkslategray: "2f4f4f",
        darkslategrey: "2f4f4f",
        darkturquoise: "00ced1",
        darkviolet: "9400d3",
        deeppink: "ff1493",
        deepskyblue: "00bfff",
        dimgray: "696969",
        dimgrey: "696969",
        dodgerblue: "1e90ff",
        firebrick: "b22222",
        floralwhite: "fffaf0",
        forestgreen: "228b22",
        fuchsia: "f0f",
        gainsboro: "dcdcdc",
        ghostwhite: "f8f8ff",
        gold: "ffd700",
        goldenrod: "daa520",
        gray: "808080",
        green: "008000",
        greenyellow: "adff2f",
        grey: "808080",
        honeydew: "f0fff0",
        hotpink: "ff69b4",
        indianred: "cd5c5c",
        indigo: "4b0082",
        ivory: "fffff0",
        khaki: "f0e68c",
        lavender: "e6e6fa",
        lavenderblush: "fff0f5",
        lawngreen: "7cfc00",
        lemonchiffon: "fffacd",
        lightblue: "add8e6",
        lightcoral: "f08080",
        lightcyan: "e0ffff",
        lightgoldenrodyellow: "fafad2",
        lightgray: "d3d3d3",
        lightgreen: "90ee90",
        lightgrey: "d3d3d3",
        lightpink: "ffb6c1",
        lightsalmon: "ffa07a",
        lightseagreen: "20b2aa",
        lightskyblue: "87cefa",
        lightslategray: "789",
        lightslategrey: "789",
        lightsteelblue: "b0c4de",
        lightyellow: "ffffe0",
        lime: "0f0",
        limegreen: "32cd32",
        linen: "faf0e6",
        magenta: "f0f",
        maroon: "800000",
        mediumaquamarine: "66cdaa",
        mediumblue: "0000cd",
        mediumorchid: "ba55d3",
        mediumpurple: "9370db",
        mediumseagreen: "3cb371",
        mediumslateblue: "7b68ee",
        mediumspringgreen: "00fa9a",
        mediumturquoise: "48d1cc",
        mediumvioletred: "c71585",
        midnightblue: "191970",
        mintcream: "f5fffa",
        mistyrose: "ffe4e1",
        moccasin: "ffe4b5",
        navajowhite: "ffdead",
        navy: "000080",
        oldlace: "fdf5e6",
        olive: "808000",
        olivedrab: "6b8e23",
        orange: "ffa500",
        orangered: "ff4500",
        orchid: "da70d6",
        palegoldenrod: "eee8aa",
        palegreen: "98fb98",
        paleturquoise: "afeeee",
        palevioletred: "db7093",
        papayawhip: "ffefd5",
        peachpuff: "ffdab9",
        peru: "cd853f",
        pink: "ffc0cb",
        plum: "dda0dd",
        powderblue: "b0e0e6",
        purple: "800080",
        rebeccapurple: "663399",
        red: "f00",
        rosybrown: "bc8f8f",
        royalblue: "4169e1",
        saddlebrown: "8b4513",
        salmon: "fa8072",
        sandybrown: "f4a460",
        seagreen: "2e8b57",
        seashell: "fff5ee",
        sienna: "a0522d",
        silver: "c0c0c0",
        skyblue: "87ceeb",
        slateblue: "6a5acd",
        slategray: "708090",
        slategrey: "708090",
        snow: "fffafa",
        springgreen: "00ff7f",
        steelblue: "4682b4",
        tan: "d2b48c",
        teal: "008080",
        thistle: "d8bfd8",
        tomato: "ff6347",
        turquoise: "40e0d0",
        violet: "ee82ee",
        wheat: "f5deb3",
        white: "fff",
        whitesmoke: "f5f5f5",
        yellow: "ff0",
        yellowgreen: "9acd32"
    };

    // Make it easy to access colors via `hexNames[hex]`
    var hexNames = tinycolor.hexNames = flip(names);


    // Utilities
    // ---------

    // `{ 'name1': 'val1' }` becomes `{ 'val1': 'name1' }`
    function flip(o) {
        var flipped = { };
        for (var i in o) {
            if (o.hasOwnProperty(i)) {
                flipped[o[i]] = i;
            }
        }
        return flipped;
    }

    // Return a valid alpha value [0,1] with all invalid values being set to 1
    function boundAlpha(a) {
        a = parseFloat(a);

        if (isNaN(a) || a < 0 || a > 1) {
            a = 1;
        }

        return a;
    }

    // Take input from [0, n] and return it as [0, 1]
    function bound01(n, max) {
        if (isOnePointZero(n)) { n = "100%"; }

        var processPercent = isPercentage(n);
        n = mathMin(max, mathMax(0, parseFloat(n)));

        // Automatically convert percentage into number
        if (processPercent) {
            n = parseInt(n * max, 10) / 100;
        }

        // Handle floating point rounding errors
        if ((math.abs(n - max) < 0.000001)) {
            return 1;
        }

        // Convert into [0, 1] range if it isn't already
        return (n % max) / parseFloat(max);
    }

    // Force a number between 0 and 1
    function clamp01(val) {
        return mathMin(1, mathMax(0, val));
    }

    // Parse a base-16 hex value into a base-10 integer
    function parseIntFromHex(val) {
        return parseInt(val, 16);
    }

    // Need to handle 1.0 as 100%, since once it is a number, there is no difference between it and 1
    // <http://stackoverflow.com/questions/7422072/javascript-how-to-detect-number-as-a-decimal-including-1-0>
    function isOnePointZero(n) {
        return typeof n == "string" && n.indexOf('.') != -1 && parseFloat(n) === 1;
    }

    // Check to see if string passed in is a percentage
    function isPercentage(n) {
        return typeof n === "string" && n.indexOf('%') != -1;
    }

    // Force a hex value to have 2 characters
    function pad2(c) {
        return c.length == 1 ? '0' + c : '' + c;
    }

    // Replace a decimal with it's percentage value
    function convertToPercentage(n) {
        if (n <= 1) {
            n = (n * 100) + "%";
        }

        return n;
    }

    // Converts a decimal to a hex value
    function convertDecimalToHex(d) {
        return Math.round(parseFloat(d) * 255).toString(16);
    }
    // Converts a hex value to a decimal
    function convertHexToDecimal(h) {
        return (parseIntFromHex(h) / 255);
    }

    var matchers = (function() {

        // <http://www.w3.org/TR/css3-values/#integers>
        var CSS_INTEGER = "[-\\+]?\\d+%?";

        // <http://www.w3.org/TR/css3-values/#number-value>
        var CSS_NUMBER = "[-\\+]?\\d*\\.\\d+%?";

        // Allow positive/negative integer/number.  Don't capture the either/or, just the entire outcome.
        var CSS_UNIT = "(?:" + CSS_NUMBER + ")|(?:" + CSS_INTEGER + ")";

        // Actual matching.
        // Parentheses and commas are optional, but not required.
        // Whitespace can take the place of commas or opening paren
        var PERMISSIVE_MATCH3 = "[\\s|\\(]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")\\s*\\)?";
        var PERMISSIVE_MATCH4 = "[\\s|\\(]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")[,|\\s]+(" + CSS_UNIT + ")\\s*\\)?";

        return {
            rgb: new RegExp("rgb" + PERMISSIVE_MATCH3),
            rgba: new RegExp("rgba" + PERMISSIVE_MATCH4),
            hsl: new RegExp("hsl" + PERMISSIVE_MATCH3),
            hsla: new RegExp("hsla" + PERMISSIVE_MATCH4),
            hsv: new RegExp("hsv" + PERMISSIVE_MATCH3),
            hsva: new RegExp("hsva" + PERMISSIVE_MATCH4),
            hex3: /^([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,
            hex6: /^([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,
            hex8: /^([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/
        };
    })();

    // `stringInputToObject`
    // Permissive string parsing.  Take in a number of formats, and output an object
    // based on detected format.  Returns `{ r, g, b }` or `{ h, s, l }` or `{ h, s, v}`
    function stringInputToObject(color) {

        color = color.replace(trimLeft,'').replace(trimRight, '').toLowerCase();
        var named = false;
        if (names[color]) {
            color = names[color];
            named = true;
        }
        else if (color == 'transparent') {
            return { r: 0, g: 0, b: 0, a: 0, format: "name" };
        }

        // Try to match string input using regular expressions.
        // Keep most of the number bounding out of this function - don't worry about [0,1] or [0,100] or [0,360]
        // Just return an object and let the conversion functions handle that.
        // This way the result will be the same whether the tinycolor is initialized with string or object.
        var match;
        if ((match = matchers.rgb.exec(color))) {
            return { r: match[1], g: match[2], b: match[3] };
        }
        if ((match = matchers.rgba.exec(color))) {
            return { r: match[1], g: match[2], b: match[3], a: match[4] };
        }
        if ((match = matchers.hsl.exec(color))) {
            return { h: match[1], s: match[2], l: match[3] };
        }
        if ((match = matchers.hsla.exec(color))) {
            return { h: match[1], s: match[2], l: match[3], a: match[4] };
        }
        if ((match = matchers.hsv.exec(color))) {
            return { h: match[1], s: match[2], v: match[3] };
        }
        if ((match = matchers.hsva.exec(color))) {
            return { h: match[1], s: match[2], v: match[3], a: match[4] };
        }
        if ((match = matchers.hex8.exec(color))) {
            return {
                a: convertHexToDecimal(match[1]),
                r: parseIntFromHex(match[2]),
                g: parseIntFromHex(match[3]),
                b: parseIntFromHex(match[4]),
                format: named ? "name" : "hex8"
            };
        }
        if ((match = matchers.hex6.exec(color))) {
            return {
                r: parseIntFromHex(match[1]),
                g: parseIntFromHex(match[2]),
                b: parseIntFromHex(match[3]),
                format: named ? "name" : "hex"
            };
        }
        if ((match = matchers.hex3.exec(color))) {
            return {
                r: parseIntFromHex(match[1] + '' + match[1]),
                g: parseIntFromHex(match[2] + '' + match[2]),
                b: parseIntFromHex(match[3] + '' + match[3]),
                format: named ? "name" : "hex"
            };
        }

        return false;
    }

    window.tinycolor = tinycolor;
    })();

    $(function () {
        if ($.fn.spectrum.load) {
            $.fn.spectrum.processNativeColorInputs();
        }
    });

});
// glMatrix v0.9.5
glMatrixArrayType=typeof Float32Array!="undefined"?Float32Array:typeof WebGLFloatArray!="undefined"?WebGLFloatArray:Array;var vec3={};vec3.create=function(a){var b=new glMatrixArrayType(3);if(a){b[0]=a[0];b[1]=a[1];b[2]=a[2]}return b};vec3.set=function(a,b){b[0]=a[0];b[1]=a[1];b[2]=a[2];return b};vec3.add=function(a,b,c){if(!c||a==c){a[0]+=b[0];a[1]+=b[1];a[2]+=b[2];return a}c[0]=a[0]+b[0];c[1]=a[1]+b[1];c[2]=a[2]+b[2];return c};
vec3.subtract=function(a,b,c){if(!c||a==c){a[0]-=b[0];a[1]-=b[1];a[2]-=b[2];return a}c[0]=a[0]-b[0];c[1]=a[1]-b[1];c[2]=a[2]-b[2];return c};vec3.negate=function(a,b){b||(b=a);b[0]=-a[0];b[1]=-a[1];b[2]=-a[2];return b};vec3.scale=function(a,b,c){if(!c||a==c){a[0]*=b;a[1]*=b;a[2]*=b;return a}c[0]=a[0]*b;c[1]=a[1]*b;c[2]=a[2]*b;return c};
vec3.normalize=function(a,b){b||(b=a);var c=a[0],d=a[1],e=a[2],g=Math.sqrt(c*c+d*d+e*e);if(g){if(g==1){b[0]=c;b[1]=d;b[2]=e;return b}}else{b[0]=0;b[1]=0;b[2]=0;return b}g=1/g;b[0]=c*g;b[1]=d*g;b[2]=e*g;return b};vec3.cross=function(a,b,c){c||(c=a);var d=a[0],e=a[1];a=a[2];var g=b[0],f=b[1];b=b[2];c[0]=e*b-a*f;c[1]=a*g-d*b;c[2]=d*f-e*g;return c};vec3.length=function(a){var b=a[0],c=a[1];a=a[2];return Math.sqrt(b*b+c*c+a*a)};vec3.dot=function(a,b){return a[0]*b[0]+a[1]*b[1]+a[2]*b[2]};
vec3.direction=function(a,b,c){c||(c=a);var d=a[0]-b[0],e=a[1]-b[1];a=a[2]-b[2];b=Math.sqrt(d*d+e*e+a*a);if(!b){c[0]=0;c[1]=0;c[2]=0;return c}b=1/b;c[0]=d*b;c[1]=e*b;c[2]=a*b;return c};vec3.lerp=function(a,b,c,d){d||(d=a);d[0]=a[0]+c*(b[0]-a[0]);d[1]=a[1]+c*(b[1]-a[1]);d[2]=a[2]+c*(b[2]-a[2]);return d};vec3.str=function(a){return"["+a[0]+", "+a[1]+", "+a[2]+"]"};var mat3={};
mat3.create=function(a){var b=new glMatrixArrayType(9);if(a){b[0]=a[0];b[1]=a[1];b[2]=a[2];b[3]=a[3];b[4]=a[4];b[5]=a[5];b[6]=a[6];b[7]=a[7];b[8]=a[8];b[9]=a[9]}return b};mat3.set=function(a,b){b[0]=a[0];b[1]=a[1];b[2]=a[2];b[3]=a[3];b[4]=a[4];b[5]=a[5];b[6]=a[6];b[7]=a[7];b[8]=a[8];return b};mat3.identity=function(a){a[0]=1;a[1]=0;a[2]=0;a[3]=0;a[4]=1;a[5]=0;a[6]=0;a[7]=0;a[8]=1;return a};
mat3.transpose=function(a,b){if(!b||a==b){var c=a[1],d=a[2],e=a[5];a[1]=a[3];a[2]=a[6];a[3]=c;a[5]=a[7];a[6]=d;a[7]=e;return a}b[0]=a[0];b[1]=a[3];b[2]=a[6];b[3]=a[1];b[4]=a[4];b[5]=a[7];b[6]=a[2];b[7]=a[5];b[8]=a[8];return b};mat3.toMat4=function(a,b){b||(b=mat4.create());b[0]=a[0];b[1]=a[1];b[2]=a[2];b[3]=0;b[4]=a[3];b[5]=a[4];b[6]=a[5];b[7]=0;b[8]=a[6];b[9]=a[7];b[10]=a[8];b[11]=0;b[12]=0;b[13]=0;b[14]=0;b[15]=1;return b};
mat3.str=function(a){return"["+a[0]+", "+a[1]+", "+a[2]+", "+a[3]+", "+a[4]+", "+a[5]+", "+a[6]+", "+a[7]+", "+a[8]+"]"};var mat4={};mat4.create=function(a){var b=new glMatrixArrayType(16);if(a){b[0]=a[0];b[1]=a[1];b[2]=a[2];b[3]=a[3];b[4]=a[4];b[5]=a[5];b[6]=a[6];b[7]=a[7];b[8]=a[8];b[9]=a[9];b[10]=a[10];b[11]=a[11];b[12]=a[12];b[13]=a[13];b[14]=a[14];b[15]=a[15]}return b};
mat4.set=function(a,b){b[0]=a[0];b[1]=a[1];b[2]=a[2];b[3]=a[3];b[4]=a[4];b[5]=a[5];b[6]=a[6];b[7]=a[7];b[8]=a[8];b[9]=a[9];b[10]=a[10];b[11]=a[11];b[12]=a[12];b[13]=a[13];b[14]=a[14];b[15]=a[15];return b};mat4.identity=function(a){a[0]=1;a[1]=0;a[2]=0;a[3]=0;a[4]=0;a[5]=1;a[6]=0;a[7]=0;a[8]=0;a[9]=0;a[10]=1;a[11]=0;a[12]=0;a[13]=0;a[14]=0;a[15]=1;return a};
mat4.transpose=function(a,b){if(!b||a==b){var c=a[1],d=a[2],e=a[3],g=a[6],f=a[7],h=a[11];a[1]=a[4];a[2]=a[8];a[3]=a[12];a[4]=c;a[6]=a[9];a[7]=a[13];a[8]=d;a[9]=g;a[11]=a[14];a[12]=e;a[13]=f;a[14]=h;return a}b[0]=a[0];b[1]=a[4];b[2]=a[8];b[3]=a[12];b[4]=a[1];b[5]=a[5];b[6]=a[9];b[7]=a[13];b[8]=a[2];b[9]=a[6];b[10]=a[10];b[11]=a[14];b[12]=a[3];b[13]=a[7];b[14]=a[11];b[15]=a[15];return b};
mat4.determinant=function(a){var b=a[0],c=a[1],d=a[2],e=a[3],g=a[4],f=a[5],h=a[6],i=a[7],j=a[8],k=a[9],l=a[10],o=a[11],m=a[12],n=a[13],p=a[14];a=a[15];return m*k*h*e-j*n*h*e-m*f*l*e+g*n*l*e+j*f*p*e-g*k*p*e-m*k*d*i+j*n*d*i+m*c*l*i-b*n*l*i-j*c*p*i+b*k*p*i+m*f*d*o-g*n*d*o-m*c*h*o+b*n*h*o+g*c*p*o-b*f*p*o-j*f*d*a+g*k*d*a+j*c*h*a-b*k*h*a-g*c*l*a+b*f*l*a};
mat4.inverse=function(a,b){b||(b=a);var c=a[0],d=a[1],e=a[2],g=a[3],f=a[4],h=a[5],i=a[6],j=a[7],k=a[8],l=a[9],o=a[10],m=a[11],n=a[12],p=a[13],r=a[14],s=a[15],A=c*h-d*f,B=c*i-e*f,t=c*j-g*f,u=d*i-e*h,v=d*j-g*h,w=e*j-g*i,x=k*p-l*n,y=k*r-o*n,z=k*s-m*n,C=l*r-o*p,D=l*s-m*p,E=o*s-m*r,q=1/(A*E-B*D+t*C+u*z-v*y+w*x);b[0]=(h*E-i*D+j*C)*q;b[1]=(-d*E+e*D-g*C)*q;b[2]=(p*w-r*v+s*u)*q;b[3]=(-l*w+o*v-m*u)*q;b[4]=(-f*E+i*z-j*y)*q;b[5]=(c*E-e*z+g*y)*q;b[6]=(-n*w+r*t-s*B)*q;b[7]=(k*w-o*t+m*B)*q;b[8]=(f*D-h*z+j*x)*q;
b[9]=(-c*D+d*z-g*x)*q;b[10]=(n*v-p*t+s*A)*q;b[11]=(-k*v+l*t-m*A)*q;b[12]=(-f*C+h*y-i*x)*q;b[13]=(c*C-d*y+e*x)*q;b[14]=(-n*u+p*B-r*A)*q;b[15]=(k*u-l*B+o*A)*q;return b};mat4.toRotationMat=function(a,b){b||(b=mat4.create());b[0]=a[0];b[1]=a[1];b[2]=a[2];b[3]=a[3];b[4]=a[4];b[5]=a[5];b[6]=a[6];b[7]=a[7];b[8]=a[8];b[9]=a[9];b[10]=a[10];b[11]=a[11];b[12]=0;b[13]=0;b[14]=0;b[15]=1;return b};
mat4.toMat3=function(a,b){b||(b=mat3.create());b[0]=a[0];b[1]=a[1];b[2]=a[2];b[3]=a[4];b[4]=a[5];b[5]=a[6];b[6]=a[8];b[7]=a[9];b[8]=a[10];return b};mat4.toInverseMat3=function(a,b){var c=a[0],d=a[1],e=a[2],g=a[4],f=a[5],h=a[6],i=a[8],j=a[9],k=a[10],l=k*f-h*j,o=-k*g+h*i,m=j*g-f*i,n=c*l+d*o+e*m;if(!n)return null;n=1/n;b||(b=mat3.create());b[0]=l*n;b[1]=(-k*d+e*j)*n;b[2]=(h*d-e*f)*n;b[3]=o*n;b[4]=(k*c-e*i)*n;b[5]=(-h*c+e*g)*n;b[6]=m*n;b[7]=(-j*c+d*i)*n;b[8]=(f*c-d*g)*n;return b};
mat4.multiply=function(a,b,c){c||(c=a);var d=a[0],e=a[1],g=a[2],f=a[3],h=a[4],i=a[5],j=a[6],k=a[7],l=a[8],o=a[9],m=a[10],n=a[11],p=a[12],r=a[13],s=a[14];a=a[15];var A=b[0],B=b[1],t=b[2],u=b[3],v=b[4],w=b[5],x=b[6],y=b[7],z=b[8],C=b[9],D=b[10],E=b[11],q=b[12],F=b[13],G=b[14];b=b[15];c[0]=A*d+B*h+t*l+u*p;c[1]=A*e+B*i+t*o+u*r;c[2]=A*g+B*j+t*m+u*s;c[3]=A*f+B*k+t*n+u*a;c[4]=v*d+w*h+x*l+y*p;c[5]=v*e+w*i+x*o+y*r;c[6]=v*g+w*j+x*m+y*s;c[7]=v*f+w*k+x*n+y*a;c[8]=z*d+C*h+D*l+E*p;c[9]=z*e+C*i+D*o+E*r;c[10]=z*
g+C*j+D*m+E*s;c[11]=z*f+C*k+D*n+E*a;c[12]=q*d+F*h+G*l+b*p;c[13]=q*e+F*i+G*o+b*r;c[14]=q*g+F*j+G*m+b*s;c[15]=q*f+F*k+G*n+b*a;return c};mat4.multiplyVec3=function(a,b,c){c||(c=b);var d=b[0],e=b[1];b=b[2];c[0]=a[0]*d+a[4]*e+a[8]*b+a[12];c[1]=a[1]*d+a[5]*e+a[9]*b+a[13];c[2]=a[2]*d+a[6]*e+a[10]*b+a[14];return c};
mat4.multiplyVec4=function(a,b,c){c||(c=b);var d=b[0],e=b[1],g=b[2];b=b[3];c[0]=a[0]*d+a[4]*e+a[8]*g+a[12]*b;c[1]=a[1]*d+a[5]*e+a[9]*g+a[13]*b;c[2]=a[2]*d+a[6]*e+a[10]*g+a[14]*b;c[3]=a[3]*d+a[7]*e+a[11]*g+a[15]*b;return c};
mat4.translate=function(a,b,c){var d=b[0],e=b[1];b=b[2];if(!c||a==c){a[12]=a[0]*d+a[4]*e+a[8]*b+a[12];a[13]=a[1]*d+a[5]*e+a[9]*b+a[13];a[14]=a[2]*d+a[6]*e+a[10]*b+a[14];a[15]=a[3]*d+a[7]*e+a[11]*b+a[15];return a}var g=a[0],f=a[1],h=a[2],i=a[3],j=a[4],k=a[5],l=a[6],o=a[7],m=a[8],n=a[9],p=a[10],r=a[11];c[0]=g;c[1]=f;c[2]=h;c[3]=i;c[4]=j;c[5]=k;c[6]=l;c[7]=o;c[8]=m;c[9]=n;c[10]=p;c[11]=r;c[12]=g*d+j*e+m*b+a[12];c[13]=f*d+k*e+n*b+a[13];c[14]=h*d+l*e+p*b+a[14];c[15]=i*d+o*e+r*b+a[15];return c};
mat4.scale=function(a,b,c){var d=b[0],e=b[1];b=b[2];if(!c||a==c){a[0]*=d;a[1]*=d;a[2]*=d;a[3]*=d;a[4]*=e;a[5]*=e;a[6]*=e;a[7]*=e;a[8]*=b;a[9]*=b;a[10]*=b;a[11]*=b;return a}c[0]=a[0]*d;c[1]=a[1]*d;c[2]=a[2]*d;c[3]=a[3]*d;c[4]=a[4]*e;c[5]=a[5]*e;c[6]=a[6]*e;c[7]=a[7]*e;c[8]=a[8]*b;c[9]=a[9]*b;c[10]=a[10]*b;c[11]=a[11]*b;c[12]=a[12];c[13]=a[13];c[14]=a[14];c[15]=a[15];return c};
mat4.rotate=function(a,b,c,d){var e=c[0],g=c[1];c=c[2];var f=Math.sqrt(e*e+g*g+c*c);if(!f)return null;if(f!=1){f=1/f;e*=f;g*=f;c*=f}var h=Math.sin(b),i=Math.cos(b),j=1-i;b=a[0];f=a[1];var k=a[2],l=a[3],o=a[4],m=a[5],n=a[6],p=a[7],r=a[8],s=a[9],A=a[10],B=a[11],t=e*e*j+i,u=g*e*j+c*h,v=c*e*j-g*h,w=e*g*j-c*h,x=g*g*j+i,y=c*g*j+e*h,z=e*c*j+g*h;e=g*c*j-e*h;g=c*c*j+i;if(d){if(a!=d){d[12]=a[12];d[13]=a[13];d[14]=a[14];d[15]=a[15]}}else d=a;d[0]=b*t+o*u+r*v;d[1]=f*t+m*u+s*v;d[2]=k*t+n*u+A*v;d[3]=l*t+p*u+B*
v;d[4]=b*w+o*x+r*y;d[5]=f*w+m*x+s*y;d[6]=k*w+n*x+A*y;d[7]=l*w+p*x+B*y;d[8]=b*z+o*e+r*g;d[9]=f*z+m*e+s*g;d[10]=k*z+n*e+A*g;d[11]=l*z+p*e+B*g;return d};mat4.rotateX=function(a,b,c){var d=Math.sin(b);b=Math.cos(b);var e=a[4],g=a[5],f=a[6],h=a[7],i=a[8],j=a[9],k=a[10],l=a[11];if(c){if(a!=c){c[0]=a[0];c[1]=a[1];c[2]=a[2];c[3]=a[3];c[12]=a[12];c[13]=a[13];c[14]=a[14];c[15]=a[15]}}else c=a;c[4]=e*b+i*d;c[5]=g*b+j*d;c[6]=f*b+k*d;c[7]=h*b+l*d;c[8]=e*-d+i*b;c[9]=g*-d+j*b;c[10]=f*-d+k*b;c[11]=h*-d+l*b;return c};
mat4.rotateY=function(a,b,c){var d=Math.sin(b);b=Math.cos(b);var e=a[0],g=a[1],f=a[2],h=a[3],i=a[8],j=a[9],k=a[10],l=a[11];if(c){if(a!=c){c[4]=a[4];c[5]=a[5];c[6]=a[6];c[7]=a[7];c[12]=a[12];c[13]=a[13];c[14]=a[14];c[15]=a[15]}}else c=a;c[0]=e*b+i*-d;c[1]=g*b+j*-d;c[2]=f*b+k*-d;c[3]=h*b+l*-d;c[8]=e*d+i*b;c[9]=g*d+j*b;c[10]=f*d+k*b;c[11]=h*d+l*b;return c};
mat4.rotateZ=function(a,b,c){var d=Math.sin(b);b=Math.cos(b);var e=a[0],g=a[1],f=a[2],h=a[3],i=a[4],j=a[5],k=a[6],l=a[7];if(c){if(a!=c){c[8]=a[8];c[9]=a[9];c[10]=a[10];c[11]=a[11];c[12]=a[12];c[13]=a[13];c[14]=a[14];c[15]=a[15]}}else c=a;c[0]=e*b+i*d;c[1]=g*b+j*d;c[2]=f*b+k*d;c[3]=h*b+l*d;c[4]=e*-d+i*b;c[5]=g*-d+j*b;c[6]=f*-d+k*b;c[7]=h*-d+l*b;return c};
mat4.frustum=function(a,b,c,d,e,g,f){f||(f=mat4.create());var h=b-a,i=d-c,j=g-e;f[0]=e*2/h;f[1]=0;f[2]=0;f[3]=0;f[4]=0;f[5]=e*2/i;f[6]=0;f[7]=0;f[8]=(b+a)/h;f[9]=(d+c)/i;f[10]=-(g+e)/j;f[11]=-1;f[12]=0;f[13]=0;f[14]=-(g*e*2)/j;f[15]=0;return f};mat4.perspective=function(a,b,c,d,e){a=c*Math.tan(a*Math.PI/360);b=a*b;return mat4.frustum(-b,b,-a,a,c,d,e)};
mat4.ortho=function(a,b,c,d,e,g,f){f||(f=mat4.create());var h=b-a,i=d-c,j=g-e;f[0]=2/h;f[1]=0;f[2]=0;f[3]=0;f[4]=0;f[5]=2/i;f[6]=0;f[7]=0;f[8]=0;f[9]=0;f[10]=-2/j;f[11]=0;f[12]=-(a+b)/h;f[13]=-(d+c)/i;f[14]=-(g+e)/j;f[15]=1;return f};
mat4.lookAt=function(a,b,c,d){d||(d=mat4.create());var e=a[0],g=a[1];a=a[2];var f=c[0],h=c[1],i=c[2];c=b[1];var j=b[2];if(e==b[0]&&g==c&&a==j)return mat4.identity(d);var k,l,o,m;c=e-b[0];j=g-b[1];b=a-b[2];m=1/Math.sqrt(c*c+j*j+b*b);c*=m;j*=m;b*=m;k=h*b-i*j;i=i*c-f*b;f=f*j-h*c;if(m=Math.sqrt(k*k+i*i+f*f)){m=1/m;k*=m;i*=m;f*=m}else f=i=k=0;h=j*f-b*i;l=b*k-c*f;o=c*i-j*k;if(m=Math.sqrt(h*h+l*l+o*o)){m=1/m;h*=m;l*=m;o*=m}else o=l=h=0;d[0]=k;d[1]=h;d[2]=c;d[3]=0;d[4]=i;d[5]=l;d[6]=j;d[7]=0;d[8]=f;d[9]=
o;d[10]=b;d[11]=0;d[12]=-(k*e+i*g+f*a);d[13]=-(h*e+l*g+o*a);d[14]=-(c*e+j*g+b*a);d[15]=1;return d};mat4.str=function(a){return"["+a[0]+", "+a[1]+", "+a[2]+", "+a[3]+", "+a[4]+", "+a[5]+", "+a[6]+", "+a[7]+", "+a[8]+", "+a[9]+", "+a[10]+", "+a[11]+", "+a[12]+", "+a[13]+", "+a[14]+", "+a[15]+"]"};quat4={};quat4.create=function(a){var b=new glMatrixArrayType(4);if(a){b[0]=a[0];b[1]=a[1];b[2]=a[2];b[3]=a[3]}return b};quat4.set=function(a,b){b[0]=a[0];b[1]=a[1];b[2]=a[2];b[3]=a[3];return b};
quat4.calculateW=function(a,b){var c=a[0],d=a[1],e=a[2];if(!b||a==b){a[3]=-Math.sqrt(Math.abs(1-c*c-d*d-e*e));return a}b[0]=c;b[1]=d;b[2]=e;b[3]=-Math.sqrt(Math.abs(1-c*c-d*d-e*e));return b};quat4.inverse=function(a,b){if(!b||a==b){a[0]*=1;a[1]*=1;a[2]*=1;return a}b[0]=-a[0];b[1]=-a[1];b[2]=-a[2];b[3]=a[3];return b};quat4.length=function(a){var b=a[0],c=a[1],d=a[2];a=a[3];return Math.sqrt(b*b+c*c+d*d+a*a)};
quat4.normalize=function(a,b){b||(b=a);var c=a[0],d=a[1],e=a[2],g=a[3],f=Math.sqrt(c*c+d*d+e*e+g*g);if(f==0){b[0]=0;b[1]=0;b[2]=0;b[3]=0;return b}f=1/f;b[0]=c*f;b[1]=d*f;b[2]=e*f;b[3]=g*f;return b};quat4.multiply=function(a,b,c){c||(c=a);var d=a[0],e=a[1],g=a[2];a=a[3];var f=b[0],h=b[1],i=b[2];b=b[3];c[0]=d*b+a*f+e*i-g*h;c[1]=e*b+a*h+g*f-d*i;c[2]=g*b+a*i+d*h-e*f;c[3]=a*b-d*f-e*h-g*i;return c};
quat4.multiplyVec3=function(a,b,c){c||(c=b);var d=b[0],e=b[1],g=b[2];b=a[0];var f=a[1],h=a[2];a=a[3];var i=a*d+f*g-h*e,j=a*e+h*d-b*g,k=a*g+b*e-f*d;d=-b*d-f*e-h*g;c[0]=i*a+d*-b+j*-h-k*-f;c[1]=j*a+d*-f+k*-b-i*-h;c[2]=k*a+d*-h+i*-f-j*-b;return c};quat4.toMat3=function(a,b){b||(b=mat3.create());var c=a[0],d=a[1],e=a[2],g=a[3],f=c+c,h=d+d,i=e+e,j=c*f,k=c*h;c=c*i;var l=d*h;d=d*i;e=e*i;f=g*f;h=g*h;g=g*i;b[0]=1-(l+e);b[1]=k-g;b[2]=c+h;b[3]=k+g;b[4]=1-(j+e);b[5]=d-f;b[6]=c-h;b[7]=d+f;b[8]=1-(j+l);return b};
quat4.toMat4=function(a,b){b||(b=mat4.create());var c=a[0],d=a[1],e=a[2],g=a[3],f=c+c,h=d+d,i=e+e,j=c*f,k=c*h;c=c*i;var l=d*h;d=d*i;e=e*i;f=g*f;h=g*h;g=g*i;b[0]=1-(l+e);b[1]=k-g;b[2]=c+h;b[3]=0;b[4]=k+g;b[5]=1-(j+e);b[6]=d-f;b[7]=0;b[8]=c-h;b[9]=d+f;b[10]=1-(j+l);b[11]=0;b[12]=0;b[13]=0;b[14]=0;b[15]=1;return b};quat4.slerp=function(a,b,c,d){d||(d=a);var e=c;if(a[0]*b[0]+a[1]*b[1]+a[2]*b[2]+a[3]*b[3]<0)e=-1*c;d[0]=1-c*a[0]+e*b[0];d[1]=1-c*a[1]+e*b[1];d[2]=1-c*a[2]+e*b[2];d[3]=1-c*a[3]+e*b[3];return d};
quat4.str=function(a){return"["+a[0]+", "+a[1]+", "+a[2]+", "+a[3]+"]"};
/*
 * Copyright 2010, Google Inc.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *     * Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above
 * copyright notice, this list of conditions and the following disclaimer
 * in the documentation and/or other materials provided with the
 * distribution.
 *     * Neither the name of Google Inc. nor the names of its
 * contributors may be used to endorse or promote products derived from
 * this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */


/**
 * @fileoverview This file contains functions every webgl program will need
 * a version of one way or another.
 *
 * Instead of setting up a context manually it is recommended to
 * use. This will check for success or failure. On failure it
 * will attempt to present an approriate message to the user.
 *
 *       gl = WebGLUtils.setupWebGL(canvas);
 *
 * For animated WebGL apps use of setTimeout or setInterval are
 * discouraged. It is recommended you structure your rendering
 * loop like this.
 *
 *       function render() {
 *         window.requestAnimFrame(render, canvas);
 *
 *         // do rendering
 *         ...
 *       }
 *       render();
 *
 * This will call your rendering function up to the refresh rate
 * of your display but will stop rendering if your app is not
 * visible.
 */

WebGLUtils = function() {

/**
 * Creates the HTLM for a failure message
 * @param {string} canvasContainerId id of container of th
 *        canvas.
 * @return {string} The html.
 */
var makeFailHTML = function(msg) {
  return '' +
    '<table style="background-color: #8CE; width: 100%; height: 100%;"><tr>' +
    '<td align="center">' +
    '<div style="display: table-cell; vertical-align: middle;">' +
    '<div style="">' + msg + '</div>' +
    '</div>' +
    '</td></tr></table>';
};

/**
 * Mesasge for getting a webgl browser
 * @type {string}
 */
var GET_A_WEBGL_BROWSER = '' +
  'This page requires a browser that supports WebGL.<br/>' +
  '<a href="http://get.webgl.org">Click here to upgrade your browser.</a>';

/**
 * Mesasge for need better hardware
 * @type {string}
 */
var OTHER_PROBLEM = '' +
  "It doesn't appear your computer can support WebGL.<br/>" +
  '<a href="http://get.webgl.org/troubleshooting/">Click here for more information.</a>';

/**
 * Creates a webgl context. If creation fails it will
 * change the contents of the container of the <canvas>
 * tag to an error message with the correct links for WebGL.
 * @param {Element} canvas. The canvas element to create a
 *     context from.
 * @param {WebGLContextCreationAttirbutes} opt_attribs Any
 *     creation attributes you want to pass in.
 * @param {function:(msg)} opt_onError An function to call
 *     if there is an error during creation.
 * @return {WebGLRenderingContext} The created context.
 */
var setupWebGL = function(canvas, opt_attribs, opt_onError) {
  function handleCreationError(msg) {
    var container = canvas.parentNode;
    if (container) {
      var str = window.WebGLRenderingContext ?
           OTHER_PROBLEM :
           GET_A_WEBGL_BROWSER;
      if (msg) {
        str += "<br/><br/>Status: " + msg;
      }
      container.innerHTML = makeFailHTML(str);
    }
  };

  opt_onError = opt_onError || handleCreationError;

  if (canvas.addEventListener) {
    canvas.addEventListener("webglcontextcreationerror", function(event) {
          opt_onError(event.statusMessage);
        }, false);
  }
  var context = create3DContext(canvas, opt_attribs);
  if (!context) {
    if (!window.WebGLRenderingContext) {
      opt_onError("");
    }
  }
  return context;
};

/**
 * Creates a webgl context.
 * @param {!Canvas} canvas The canvas tag to get context
 *     from. If one is not passed in one will be created.
 * @return {!WebGLContext} The created context.
 */
var create3DContext = function(canvas, opt_attribs) {
  var names = ["webgl", "experimental-webgl", "webkit-3d", "moz-webgl"];
  var context = null;
  for (var ii = 0; ii < names.length; ++ii) {
    try {
      context = canvas.getContext(names[ii], opt_attribs);
    } catch(e) {}
    if (context) {
      break;
    }
  }
  return context;
}

return {
  create3DContext: create3DContext,
  setupWebGL: setupWebGL
};
}();

/**
 * Provides requestAnimationFrame in a cross browser way.
 */
window.requestAnimFrame = (function() {
  return window.requestAnimationFrame ||
         window.webkitRequestAnimationFrame ||
         window.mozRequestAnimationFrame ||
         window.oRequestAnimationFrame ||
         window.msRequestAnimationFrame ||
         function(/* function FrameRequestCallback */ callback, /* DOMElement Element */ element) {
           window.setTimeout(callback, 1000/60);
         };
})();

/* Blob.js
 * A Blob implementation.
 * 2013-06-20
 * 
 * By Eli Grey, http://eligrey.com
 * By Devin Samarin, https://github.com/eboyjr
 * License: X11/MIT
 *   See LICENSE.md
 */

/*global self, unescape */
/*jslint bitwise: true, regexp: true, confusion: true, es5: true, vars: true, white: true,
  plusplus: true */

/*! @source http://purl.eligrey.com/github/Blob.js/blob/master/Blob.js */

if (typeof Blob !== "function" || typeof URL === "undefined")
if (typeof Blob === "function" && typeof webkitURL !== "undefined") var URL = webkitURL;
else var Blob = (function (view) {
	"use strict";

	var BlobBuilder = view.BlobBuilder || view.WebKitBlobBuilder || view.MozBlobBuilder || view.MSBlobBuilder || (function(view) {
		var
			  get_class = function(object) {
				return Object.prototype.toString.call(object).match(/^\[object\s(.*)\]$/)[1];
			}
			, FakeBlobBuilder = function BlobBuilder() {
				this.data = [];
			}
			, FakeBlob = function Blob(data, type, encoding) {
				this.data = data;
				this.size = data.length;
				this.type = type;
				this.encoding = encoding;
			}
			, FBB_proto = FakeBlobBuilder.prototype
			, FB_proto = FakeBlob.prototype
			, FileReaderSync = view.FileReaderSync
			, FileException = function(type) {
				this.code = this[this.name = type];
			}
			, file_ex_codes = (
				  "NOT_FOUND_ERR SECURITY_ERR ABORT_ERR NOT_READABLE_ERR ENCODING_ERR "
				+ "NO_MODIFICATION_ALLOWED_ERR INVALID_STATE_ERR SYNTAX_ERR"
			).split(" ")
			, file_ex_code = file_ex_codes.length
			, real_URL = view.URL || view.webkitURL || view
			, real_create_object_URL = real_URL.createObjectURL
			, real_revoke_object_URL = real_URL.revokeObjectURL
			, URL = real_URL
			, btoa = view.btoa
			, atob = view.atob
			, can_apply_typed_arrays = false
			, can_apply_typed_arrays_test = function(pass) {
				can_apply_typed_arrays = !pass;
			}
			
			, ArrayBuffer = view.ArrayBuffer
			, Uint8Array = view.Uint8Array
		;
		FakeBlob.fake = FB_proto.fake = true;
		while (file_ex_code--) {
			FileException.prototype[file_ex_codes[file_ex_code]] = file_ex_code + 1;
		}
		try {
			if (Uint8Array) {
				can_apply_typed_arrays_test.apply(0, new Uint8Array(1));
			}
		} catch (ex) {}
		if (!real_URL.createObjectURL) {
			URL = view.URL = {};
		}
		URL.createObjectURL = function(blob) {
			var
				  type = blob.type
				, data_URI_header
			;
			if (type === null) {
				type = "application/octet-stream";
			}
			if (blob instanceof FakeBlob) {
				data_URI_header = "data:" + type;
				if (blob.encoding === "base64") {
					return data_URI_header + ";base64," + blob.data;
				} else if (blob.encoding === "URI") {
					return data_URI_header + "," + decodeURIComponent(blob.data);
				} if (btoa) {
					return data_URI_header + ";base64," + btoa(blob.data);
				} else {
					return data_URI_header + "," + encodeURIComponent(blob.data);
				}
			} else if (real_create_object_URL) {
				return real_create_object_URL.call(real_URL, blob);
			}
		};
		URL.revokeObjectURL = function(object_URL) {
			if (object_URL.substring(0, 5) !== "data:" && real_revoke_object_URL) {
				real_revoke_object_URL.call(real_URL, object_URL);
			}
		};
		FBB_proto.append = function(data/*, endings*/) {
			var bb = this.data;
			// decode data to a binary string
			if (Uint8Array && (data instanceof ArrayBuffer || data instanceof Uint8Array)) {
				if (can_apply_typed_arrays) {
					bb.push(String.fromCharCode.apply(String, new Uint8Array(data)));
				} else {
					var
						  str = ""
						, buf = new Uint8Array(data)
						, i = 0
						, buf_len = buf.length
					;
					for (; i < buf_len; i++) {
						str += String.fromCharCode(buf[i]);
					}
				}
			} else if (get_class(data) === "Blob" || get_class(data) === "File") {
				if (FileReaderSync) {
					var fr = new FileReaderSync;
					bb.push(fr.readAsBinaryString(data));
				} else {
					// async FileReader won't work as BlobBuilder is sync
					throw new FileException("NOT_READABLE_ERR");
				}
			} else if (data instanceof FakeBlob) {
				if (data.encoding === "base64" && atob) {
					bb.push(atob(data.data));
				} else if (data.encoding === "URI") {
					bb.push(decodeURIComponent(data.data));
				} else if (data.encoding === "raw") {
					bb.push(data.data);
				}
			} else {
				if (typeof data !== "string") {
					data += ""; // convert unsupported types to strings
				}
				// decode UTF-16 to binary string
				bb.push(unescape(encodeURIComponent(data)));
			}
		};
		FBB_proto.getBlob = function(type) {
			if (!arguments.length) {
				type = null;
			}
			return new FakeBlob(this.data.join(""), type, "raw");
		};
		FBB_proto.toString = function() {
			return "[object BlobBuilder]";
		};
		FB_proto.slice = function(start, end, type) {
			var args = arguments.length;
			if (args < 3) {
				type = null;
			}
			return new FakeBlob(
				  this.data.slice(start, args > 1 ? end : this.data.length)
				, type
				, this.encoding
			);
		};
		FB_proto.toString = function() {
			return "[object Blob]";
		};
		return FakeBlobBuilder;
	}(view));

	return function Blob(blobParts, options) {
		var type = options ? (options.type || "") : "";
		var builder = new BlobBuilder();
		if (blobParts) {
			for (var i = 0, len = blobParts.length; i < len; i++) {
				builder.append(blobParts[i]);
			}
		}
		return builder.getBlob(type);
	};
}(self));
/* canvas-toBlob.js
 * A canvas.toBlob() implementation.
 * 2011-07-13
 * 
 * By Eli Grey, http://eligrey.com and Devin Samarin, https://github.com/eboyjr
 * License: X11/MIT
 *   See LICENSE.md
 */

/*global self */
/*jslint bitwise: true, regexp: true, confusion: true, es5: true, vars: true, white: true,
  plusplus: true */

/*! @source http://purl.eligrey.com/github/canvas-toBlob.js/blob/master/canvas-toBlob.js */

(function(view) {
"use strict";
var
	  Uint8Array = view.Uint8Array
	, HTMLCanvasElement = view.HTMLCanvasElement
	, is_base64_regex = /\s*;\s*base64\s*(?:;|$)/i
	, base64_ranks
	, decode_base64 = function(base64) {
		var
			  len = base64.length
			, buffer = new Uint8Array(len / 4 * 3 | 0)
			, i = 0
			, outptr = 0
			, last = [0, 0]
			, state = 0
			, save = 0
			, rank
			, code
			, undef
		;
		while (len--) {
			code = base64.charCodeAt(i++);
			rank = base64_ranks[code-43];
			if (rank !== 255 && rank !== undef) {
				last[1] = last[0];
				last[0] = code;
				save = (save << 6) | rank;
				state++;
				if (state === 4) {
					buffer[outptr++] = save >>> 16;
					if (last[1] !== 61 /* padding character */) {
						buffer[outptr++] = save >>> 8;
					}
					if (last[0] !== 61 /* padding character */) {
						buffer[outptr++] = save;
					}
					state = 0;
				}
			}
		}
		// 2/3 chance there's going to be some null bytes at the end, but that
		// doesn't really matter with most image formats.
		// If it somehow matters for you, truncate the buffer up outptr.
		return buffer.buffer;
	}
;
if (Uint8Array) {
	base64_ranks = new Uint8Array([
		  62, -1, -1, -1, 63, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, -1
		, -1, -1,  0, -1, -1, -1,  0,  1,  2,  3,  4,  5,  6,  7,  8,  9
		, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25
		, -1, -1, -1, -1, -1, -1, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35
		, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51
	]);
}
if (HTMLCanvasElement && !HTMLCanvasElement.prototype.toBlob) {
	HTMLCanvasElement.prototype.toBlob = function(callback, type /*, ...args*/) {
		  if (!type) {
			type = "image/png";
		} if (this.mozGetAsFile) {
			callback(this.mozGetAsFile("canvas", type));
			return;
		}
		var
			  args = Array.prototype.slice.call(arguments, 1)
			, dataURI = this.toDataURL.apply(this, args)
			, header_end = dataURI.indexOf(",")
			, data = dataURI.substring(header_end + 1)
			, is_base64 = is_base64_regex.test(dataURI.substring(0, header_end))
			, blob
		;
		if (Blob.fake) {
			// no reason to decode a data: URI that's just going to become a data URI again
			blob = new Blob
			if (is_base64) {
				blob.encoding = "base64";
			} else {
				blob.encoding = "URI";
			}
			blob.data = data;
			blob.size = data.length;
		} else if (Uint8Array) {
			if (is_base64) {
				blob = new Blob([decode_base64(data)], {type: type});
			} else {
				blob = new Blob([decodeURIComponent(data)], {type: type});
			}
		}
		callback(blob);
	};
}
}(self));
/* FileSaver.js
 * A saveAs() FileSaver implementation.
 * 2013-01-23
 * 
 * By Eli Grey, http://eligrey.com
 * License: X11/MIT
 *   See LICENSE.md
 */

/*global self */
/*jslint bitwise: true, regexp: true, confusion: true, es5: true, vars: true, white: true,
  plusplus: true */

/*! @source http://purl.eligrey.com/github/FileSaver.js/blob/master/FileSaver.js */

var saveAs = saveAs
  || (navigator.msSaveBlob && navigator.msSaveBlob.bind(navigator))
  || (function(view) {
	"use strict";
	var
		  doc = view.document
		  // only get URL when necessary in case BlobBuilder.js hasn't overridden it yet
		, get_URL = function() {
			return view.URL || view.webkitURL || view;
		}
		, URL = view.URL || view.webkitURL || view
		, save_link = doc.createElementNS("http://www.w3.org/1999/xhtml", "a")
		, can_use_save_link = "download" in save_link
		, click = function(node) {
			var event = doc.createEvent("MouseEvents");
			event.initMouseEvent(
				"click", true, false, view, 0, 0, 0, 0, 0
				, false, false, false, false, 0, null
			);
			node.dispatchEvent(event);
		}
		, webkit_req_fs = view.webkitRequestFileSystem
		, req_fs = view.requestFileSystem || webkit_req_fs || view.mozRequestFileSystem
		, throw_outside = function (ex) {
			(view.setImmediate || view.setTimeout)(function() {
				throw ex;
			}, 0);
		}
		, force_saveable_type = "application/octet-stream"
		, fs_min_size = 0
		, deletion_queue = []
		, process_deletion_queue = function() {
			var i = deletion_queue.length;
			while (i--) {
				var file = deletion_queue[i];
				if (typeof file === "string") { // file is an object URL
					URL.revokeObjectURL(file);
				} else { // file is a File
					file.remove();
				}
			}
			deletion_queue.length = 0; // clear queue
		}
		, dispatch = function(filesaver, event_types, event) {
			event_types = [].concat(event_types);
			var i = event_types.length;
			while (i--) {
				var listener = filesaver["on" + event_types[i]];
				if (typeof listener === "function") {
					try {
						listener.call(filesaver, event || filesaver);
					} catch (ex) {
						throw_outside(ex);
					}
				}
			}
		}
		, FileSaver = function(blob, name) {
			// First try a.download, then web filesystem, then object URLs
			var
				  filesaver = this
				, type = blob.type
				, blob_changed = false
				, object_url
				, target_view
				, get_object_url = function() {
					var object_url = get_URL().createObjectURL(blob);
					deletion_queue.push(object_url);
					return object_url;
				}
				, dispatch_all = function() {
					dispatch(filesaver, "writestart progress write writeend".split(" "));
				}
				// on any filesys errors revert to saving with object URLs
				, fs_error = function() {
					// don't create more object URLs than needed
					if (blob_changed || !object_url) {
						object_url = get_object_url(blob);
					}
					if (target_view) {
						target_view.location.href = object_url;
					}
					filesaver.readyState = filesaver.DONE;
					dispatch_all();
				}
				, abortable = function(func) {
					return function() {
						if (filesaver.readyState !== filesaver.DONE) {
							return func.apply(this, arguments);
						}
					};
				}
				, create_if_not_found = {create: true, exclusive: false}
				, slice
			;
			filesaver.readyState = filesaver.INIT;
			if (!name) {
				name = "download";
			}
			if (can_use_save_link) {
				object_url = get_object_url(blob);
				save_link.href = object_url;
				save_link.download = name;
				click(save_link);
				filesaver.readyState = filesaver.DONE;
				dispatch_all();
				return;
			}
			// Object and web filesystem URLs have a problem saving in Google Chrome when
			// viewed in a tab, so I force save with application/octet-stream
			// http://code.google.com/p/chromium/issues/detail?id=91158
			if (view.chrome && type && type !== force_saveable_type) {
				slice = blob.slice || blob.webkitSlice;
				blob = slice.call(blob, 0, blob.size, force_saveable_type);
				blob_changed = true;
			}
			// Since I can't be sure that the guessed media type will trigger a download
			// in WebKit, I append .download to the filename.
			// https://bugs.webkit.org/show_bug.cgi?id=65440
			if (webkit_req_fs && name !== "download") {
				name += ".download";
			}
			if (type === force_saveable_type || webkit_req_fs) {
				target_view = view;
			} else {
				target_view = view.open();
			}
			if (!req_fs) {
				fs_error();
				return;
			}
			fs_min_size += blob.size;
			req_fs(view.TEMPORARY, fs_min_size, abortable(function(fs) {
				fs.root.getDirectory("saved", create_if_not_found, abortable(function(dir) {
					var save = function() {
						dir.getFile(name, create_if_not_found, abortable(function(file) {
							file.createWriter(abortable(function(writer) {
								writer.onwriteend = function(event) {
									target_view.location.href = file.toURL();
									deletion_queue.push(file);
									filesaver.readyState = filesaver.DONE;
									dispatch(filesaver, "writeend", event);
								};
								writer.onerror = function() {
									var error = writer.error;
									if (error.code !== error.ABORT_ERR) {
										fs_error();
									}
								};
								"writestart progress write abort".split(" ").forEach(function(event) {
									writer["on" + event] = filesaver["on" + event];
								});
								writer.write(blob);
								filesaver.abort = function() {
									writer.abort();
									filesaver.readyState = filesaver.DONE;
								};
								filesaver.readyState = filesaver.WRITING;
							}), fs_error);
						}), fs_error);
					};
					dir.getFile(name, {create: false}, abortable(function(file) {
						// delete file if it already exists
						file.remove();
						save();
					}), abortable(function(ex) {
						if (ex.code === ex.NOT_FOUND_ERR) {
							save();
						} else {
							fs_error();
						}
					}));
				}), fs_error);
			}), fs_error);
		}
		, FS_proto = FileSaver.prototype
		, saveAs = function(blob, name) {
			return new FileSaver(blob, name);
		}
	;
	FS_proto.abort = function() {
		var filesaver = this;
		filesaver.readyState = filesaver.DONE;
		dispatch(filesaver, "abort");
	};
	FS_proto.readyState = FS_proto.INIT = 0;
	FS_proto.WRITING = 1;
	FS_proto.DONE = 2;
	
	FS_proto.error =
	FS_proto.onwritestart =
	FS_proto.onprogress =
	FS_proto.onwrite =
	FS_proto.onabort =
	FS_proto.onerror =
	FS_proto.onwriteend =
		null;
	
	view.addEventListener("unload", process_deletion_queue, false);
	return saveAs;
}(self));
var bson = (function(){

  var pkgmap        = {},
      global        = {},
      nativeRequire = typeof require != 'undefined' && require,
      lib, ties, main, async;

  function exports(){ return main(); };

  exports.main     = exports;
  exports.module   = module;
  exports.packages = pkgmap;
  exports.pkg      = pkg;
  exports.require  = function require(uri){
    return pkgmap.main.index.require(uri);
  };


  ties             = {};

  aliases          = {};


  return exports;

function join() {
  return normalize(Array.prototype.join.call(arguments, "/"));
};

function normalize(path) {
  var ret = [], parts = path.split('/'), cur, prev;

  var i = 0, l = parts.length-1;
  for (; i <= l; i++) {
    cur = parts[i];

    if (cur === "." && prev !== undefined) continue;

    if (cur === ".." && ret.length && prev !== ".." && prev !== "." && prev !== undefined) {
      ret.pop();
      prev = ret.slice(-1)[0];
    } else {
      if (prev === ".") ret.pop();
      ret.push(cur);
      prev = cur;
    }
  }

  return ret.join("/");
};

function dirname(path) {
  return path && path.substr(0, path.lastIndexOf("/")) || ".";
};

function findModule(workingModule, uri){
  var moduleId      = join(dirname(workingModule.id), /\.\/$/.test(uri) ? (uri + 'index') : uri ).replace(/\.js$/, ''),
      moduleIndexId = join(moduleId, 'index'),
      pkg           = workingModule.pkg,
      module;

  var i = pkg.modules.length,
      id;

  while(i-->0){
    id = pkg.modules[i].id;

    if(id==moduleId || id == moduleIndexId){
      module = pkg.modules[i];
      break;
    }
  }

  return module;
}

function newRequire(callingModule){
  function require(uri){
    var module, pkg;

    if(/^\./.test(uri)){
      module = findModule(callingModule, uri);
    } else if ( ties && ties.hasOwnProperty( uri ) ) {
      return ties[uri];
    } else if ( aliases && aliases.hasOwnProperty( uri ) ) {
      return require(aliases[uri]);
    } else {
      pkg = pkgmap[uri];

      if(!pkg && nativeRequire){
        try {
          pkg = nativeRequire(uri);
        } catch (nativeRequireError) {}

        if(pkg) return pkg;
      }

      if(!pkg){
        throw new Error('Cannot find module "'+uri+'" @[module: '+callingModule.id+' package: '+callingModule.pkg.name+']');
      }

      module = pkg.index;
    }

    if(!module){
      throw new Error('Cannot find module "'+uri+'" @[module: '+callingModule.id+' package: '+callingModule.pkg.name+']');
    }

    module.parent = callingModule;
    return module.call();
  };


  return require;
}


function module(parent, id, wrapper){
  var mod    = { pkg: parent, id: id, wrapper: wrapper },
      cached = false;

  mod.exports = {};
  mod.require = newRequire(mod);

  mod.call = function(){
    if(cached) {
      return mod.exports;
    }

    cached = true;

    global.require = mod.require;

    mod.wrapper(mod, mod.exports, global, global.require);
    return mod.exports;
  };

  if(parent.mainModuleId == mod.id){
    parent.index = mod;
    parent.parents.length === 0 && ( main = mod.call );
  }

  parent.modules.push(mod);
}

function pkg(/* [ parentId ...], wrapper */){
  var wrapper = arguments[ arguments.length - 1 ],
      parents = Array.prototype.slice.call(arguments, 0, arguments.length - 1),
      ctx     = wrapper(parents);


  pkgmap[ctx.name] = ctx;

  arguments.length == 1 && ( pkgmap.main = ctx );

  return function(modules){
    var id;
    for(id in modules){
      module(ctx, id, modules[id]);
    }
  };
}


}(this));

bson.pkg(function(parents){

  return {
    'name'         : 'bson',
    'mainModuleId' : 'bson',
    'modules'      : [],
    'parents'      : parents
  };

})({ 'binary': function(module, exports, global, require, undefined){
  /**
 * Module dependencies.
 */
if(typeof window === 'undefined') { 
  var Buffer = require('buffer').Buffer; // TODO just use global Buffer
}

// Binary default subtype
var BSON_BINARY_SUBTYPE_DEFAULT = 0;

/**
 * @ignore
 * @api private
 */
var writeStringToArray = function(data) {
  // Create a buffer
  var buffer = typeof Uint8Array != 'undefined' ? new Uint8Array(new ArrayBuffer(data.length)) : new Array(data.length);
  // Write the content to the buffer
  for(var i = 0; i < data.length; i++) {
    buffer[i] = data.charCodeAt(i);
  }  
  // Write the string to the buffer
  return buffer;
}

/**
 * Convert Array ot Uint8Array to Binary String
 *
 * @ignore
 * @api private
 */
var convertArraytoUtf8BinaryString = function(byteArray, startIndex, endIndex) {
  var result = "";
  for(var i = startIndex; i < endIndex; i++) {
   result = result + String.fromCharCode(byteArray[i]);
  }
  return result;  
};

/**
 * A class representation of the BSON Binary type.
 * 
 * Sub types
 *  - **BSON.BSON_BINARY_SUBTYPE_DEFAULT**, default BSON type.
 *  - **BSON.BSON_BINARY_SUBTYPE_FUNCTION**, BSON function type.
 *  - **BSON.BSON_BINARY_SUBTYPE_BYTE_ARRAY**, BSON byte array type.
 *  - **BSON.BSON_BINARY_SUBTYPE_UUID**, BSON uuid type.
 *  - **BSON.BSON_BINARY_SUBTYPE_MD5**, BSON md5 type.
 *  - **BSON.BSON_BINARY_SUBTYPE_USER_DEFINED**, BSON user defined type.
 *
 * @class Represents the Binary BSON type.
 * @param {Buffer} buffer a buffer object containing the binary data.
 * @param {Number} [subType] the option binary type.
 * @return {Grid}
 */
function Binary(buffer, subType) {
  if(!(this instanceof Binary)) return new Binary(buffer, subType);
  
  this._bsontype = 'Binary';

  if(buffer instanceof Number) {
    this.sub_type = buffer;
    this.position = 0;
  } else {    
    this.sub_type = subType == null ? BSON_BINARY_SUBTYPE_DEFAULT : subType;
    this.position = 0;
  }

  if(buffer != null && !(buffer instanceof Number)) {
    // Only accept Buffer, Uint8Array or Arrays
    if(typeof buffer == 'string') {
      // Different ways of writing the length of the string for the different types
      if(typeof Buffer != 'undefined') {
        this.buffer = new Buffer(buffer);
      } else if(typeof Uint8Array != 'undefined' || (Object.prototype.toString.call(buffer) == '[object Array]')) {
        this.buffer = writeStringToArray(buffer);
      } else {
        throw new Error("only String, Buffer, Uint8Array or Array accepted");
      }
    } else {
      this.buffer = buffer;      
    }
    this.position = buffer.length;
  } else {
    if(typeof Buffer != 'undefined') {
      this.buffer =  new Buffer(Binary.BUFFER_SIZE);      
    } else if(typeof Uint8Array != 'undefined'){
      this.buffer = new Uint8Array(new ArrayBuffer(Binary.BUFFER_SIZE));
    } else {
      this.buffer = new Array(Binary.BUFFER_SIZE);
    }
    // Set position to start of buffer
    this.position = 0;
  }
};

/**
 * Updates this binary with byte_value.
 *
 * @param {Character} byte_value a single byte we wish to write.
 * @api public
 */
Binary.prototype.put = function put(byte_value) {
  // If it's a string and a has more than one character throw an error
  if(byte_value['length'] != null && typeof byte_value != 'number' && byte_value.length != 1) throw new Error("only accepts single character String, Uint8Array or Array");
  if(typeof byte_value != 'number' && byte_value < 0 || byte_value > 255) throw new Error("only accepts number in a valid unsigned byte range 0-255");
  
  // Decode the byte value once
  var decoded_byte = null;
  if(typeof byte_value == 'string') {
    decoded_byte = byte_value.charCodeAt(0);      
  } else if(byte_value['length'] != null) {
    decoded_byte = byte_value[0];
  } else {
    decoded_byte = byte_value;
  }
  
  if(this.buffer.length > this.position) {
    this.buffer[this.position++] = decoded_byte;
  } else {
    if(typeof Buffer != 'undefined' && Buffer.isBuffer(this.buffer)) {    
      // Create additional overflow buffer
      var buffer = new Buffer(Binary.BUFFER_SIZE + this.buffer.length);
      // Combine the two buffers together
      this.buffer.copy(buffer, 0, 0, this.buffer.length);
      this.buffer = buffer;
      this.buffer[this.position++] = decoded_byte;
    } else {
      var buffer = null;
      // Create a new buffer (typed or normal array)
      if(Object.prototype.toString.call(this.buffer) == '[object Uint8Array]') {
        buffer = new Uint8Array(new ArrayBuffer(Binary.BUFFER_SIZE + this.buffer.length));
      } else {
        buffer = new Array(Binary.BUFFER_SIZE + this.buffer.length);
      }      
      
      // We need to copy all the content to the new array
      for(var i = 0; i < this.buffer.length; i++) {
        buffer[i] = this.buffer[i];
      }
      
      // Reassign the buffer
      this.buffer = buffer;
      // Write the byte
      this.buffer[this.position++] = decoded_byte;
    }
  }
};

/**
 * Writes a buffer or string to the binary.
 *
 * @param {Buffer|String} string a string or buffer to be written to the Binary BSON object.
 * @param {Number} offset specify the binary of where to write the content.
 * @api public
 */
Binary.prototype.write = function write(string, offset) {
  offset = typeof offset == 'number' ? offset : this.position;

  // If the buffer is to small let's extend the buffer
  if(this.buffer.length < offset + string.length) {
    var buffer = null;
    // If we are in node.js
    if(typeof Buffer != 'undefined' && Buffer.isBuffer(this.buffer)) {      
      buffer = new Buffer(this.buffer.length + string.length);
      this.buffer.copy(buffer, 0, 0, this.buffer.length);      
    } else if(Object.prototype.toString.call(this.buffer) == '[object Uint8Array]') {
      // Create a new buffer
      buffer = new Uint8Array(new ArrayBuffer(this.buffer.length + string.length))
      // Copy the content
      for(var i = 0; i < this.position; i++) {
        buffer[i] = this.buffer[i];
      }
    }
    
    // Assign the new buffer
    this.buffer = buffer;
  }

  if(typeof Buffer != 'undefined' && Buffer.isBuffer(string) && Buffer.isBuffer(this.buffer)) {
    string.copy(this.buffer, offset, 0, string.length);
    this.position = (offset + string.length) > this.position ? (offset + string.length) : this.position;
    // offset = string.length
  } else if(typeof Buffer != 'undefined' && typeof string == 'string' && Buffer.isBuffer(this.buffer)) {
    this.buffer.write(string, 'binary', offset);
    this.position = (offset + string.length) > this.position ? (offset + string.length) : this.position;
    // offset = string.length;
  } else if(Object.prototype.toString.call(string) == '[object Uint8Array]' 
    || Object.prototype.toString.call(string) == '[object Array]' && typeof string != 'string') {      
    for(var i = 0; i < string.length; i++) {
      this.buffer[offset++] = string[i];
    }    

    this.position = offset > this.position ? offset : this.position;
  } else if(typeof string == 'string') {
    for(var i = 0; i < string.length; i++) {
      this.buffer[offset++] = string.charCodeAt(i);
    }

    this.position = offset > this.position ? offset : this.position;
  }
};

/**
 * Reads **length** bytes starting at **position**.
 *
 * @param {Number} position read from the given position in the Binary.
 * @param {Number} length the number of bytes to read.
 * @return {Buffer}
 * @api public
 */
Binary.prototype.read = function read(position, length) {
  length = length && length > 0
    ? length
    : this.position;
  
  // Let's return the data based on the type we have
  if(this.buffer['slice']) {
    return this.buffer.slice(position, position + length);
  } else {
    // Create a buffer to keep the result
    var buffer = typeof Uint8Array != 'undefined' ? new Uint8Array(new ArrayBuffer(length)) : new Array(length);
    for(var i = 0; i < length; i++) {
      buffer[i] = this.buffer[position++];
    }
  }
  // Return the buffer
  return buffer;
};

/**
 * Returns the value of this binary as a string.
 *
 * @return {String}
 * @api public
 */
Binary.prototype.value = function value(asRaw) {
  asRaw = asRaw == null ? false : asRaw;  
  
  // If it's a node.js buffer object
  if(typeof Buffer != 'undefined' && Buffer.isBuffer(this.buffer)) {
    return asRaw ? this.buffer.slice(0, this.position) : this.buffer.toString('binary', 0, this.position);
  } else {
    if(asRaw) {
      // we support the slice command use it
      if(this.buffer['slice'] != null) {
        return this.buffer.slice(0, this.position);
      } else {
        // Create a new buffer to copy content to
        var newBuffer = Object.prototype.toString.call(this.buffer) == '[object Uint8Array]' ? new Uint8Array(new ArrayBuffer(this.position)) : new Array(this.position);
        // Copy content
        for(var i = 0; i < this.position; i++) {
          newBuffer[i] = this.buffer[i];
        }
        // Return the buffer
        return newBuffer;
      }
    } else {
      return convertArraytoUtf8BinaryString(this.buffer, 0, this.position);
    }
  }
};

/**
 * Length.
 *
 * @return {Number} the length of the binary.
 * @api public
 */
Binary.prototype.length = function length() {
  return this.position;
};

/**
 * @ignore
 * @api private
 */
Binary.prototype.toJSON = function() {
  return this.buffer != null ? this.buffer.toString('base64') : '';
}

/**
 * @ignore
 * @api private
 */
Binary.prototype.toString = function(format) {
  return this.buffer != null ? this.buffer.slice(0, this.position).toString(format) : '';
}

Binary.BUFFER_SIZE = 256;

/**
 * Default BSON type
 *  
 * @classconstant SUBTYPE_DEFAULT
 **/
Binary.SUBTYPE_DEFAULT = 0;
/**
 * Function BSON type
 *  
 * @classconstant SUBTYPE_DEFAULT
 **/
Binary.SUBTYPE_FUNCTION = 1;
/**
 * Byte Array BSON type
 *  
 * @classconstant SUBTYPE_DEFAULT
 **/
Binary.SUBTYPE_BYTE_ARRAY = 2;
/**
 * OLD UUID BSON type
 *  
 * @classconstant SUBTYPE_DEFAULT
 **/
Binary.SUBTYPE_UUID_OLD = 3;
/**
 * UUID BSON type
 *  
 * @classconstant SUBTYPE_DEFAULT
 **/
Binary.SUBTYPE_UUID = 4;
/**
 * MD5 BSON type
 *  
 * @classconstant SUBTYPE_DEFAULT
 **/
Binary.SUBTYPE_MD5 = 5;
/**
 * User BSON type
 *  
 * @classconstant SUBTYPE_DEFAULT
 **/
Binary.SUBTYPE_USER_DEFINED = 128;

/**
 * Expose.
 */
exports.Binary = Binary;


}, 



'binary_parser': function(module, exports, global, require, undefined){
  /**
 * Binary Parser.
 * Jonas Raoni Soares Silva
 * http://jsfromhell.com/classes/binary-parser [v1.0]
 */
var chr = String.fromCharCode;

var maxBits = [];
for (var i = 0; i < 64; i++) {
	maxBits[i] = Math.pow(2, i);
}

function BinaryParser (bigEndian, allowExceptions) {
  if(!(this instanceof BinaryParser)) return new BinaryParser(bigEndian, allowExceptions);
  
	this.bigEndian = bigEndian;
	this.allowExceptions = allowExceptions;
};

BinaryParser.warn = function warn (msg) {
	if (this.allowExceptions) {
		throw new Error(msg);
  }

	return 1;
};

BinaryParser.decodeFloat = function decodeFloat (data, precisionBits, exponentBits) {
	var b = new this.Buffer(this.bigEndian, data);

	b.checkBuffer(precisionBits + exponentBits + 1);

	var bias = maxBits[exponentBits - 1] - 1
    , signal = b.readBits(precisionBits + exponentBits, 1)
    , exponent = b.readBits(precisionBits, exponentBits)
    , significand = 0
    , divisor = 2
    , curByte = b.buffer.length + (-precisionBits >> 3) - 1;

	do {
		for (var byteValue = b.buffer[ ++curByte ], startBit = precisionBits % 8 || 8, mask = 1 << startBit; mask >>= 1; ( byteValue & mask ) && ( significand += 1 / divisor ), divisor *= 2 );
	} while (precisionBits -= startBit);

	return exponent == ( bias << 1 ) + 1 ? significand ? NaN : signal ? -Infinity : +Infinity : ( 1 + signal * -2 ) * ( exponent || significand ? !exponent ? Math.pow( 2, -bias + 1 ) * significand : Math.pow( 2, exponent - bias ) * ( 1 + significand ) : 0 );
};

BinaryParser.decodeInt = function decodeInt (data, bits, signed, forceBigEndian) {
  var b = new this.Buffer(this.bigEndian || forceBigEndian, data)
      , x = b.readBits(0, bits)
      , max = maxBits[bits]; //max = Math.pow( 2, bits );
  
  return signed && x >= max / 2
      ? x - max
      : x;
};

BinaryParser.encodeFloat = function encodeFloat (data, precisionBits, exponentBits) {
	var bias = maxBits[exponentBits - 1] - 1
    , minExp = -bias + 1
    , maxExp = bias
    , minUnnormExp = minExp - precisionBits
    , n = parseFloat(data)
    , status = isNaN(n) || n == -Infinity || n == +Infinity ? n : 0
    ,	exp = 0
    , len = 2 * bias + 1 + precisionBits + 3
    , bin = new Array(len)
    , signal = (n = status !== 0 ? 0 : n) < 0
    , intPart = Math.floor(n = Math.abs(n))
    , floatPart = n - intPart
    , lastBit
    , rounded
    , result
    , i
    , j;

	for (i = len; i; bin[--i] = 0);

	for (i = bias + 2; intPart && i; bin[--i] = intPart % 2, intPart = Math.floor(intPart / 2));

	for (i = bias + 1; floatPart > 0 && i; (bin[++i] = ((floatPart *= 2) >= 1) - 0 ) && --floatPart);

	for (i = -1; ++i < len && !bin[i];);

	if (bin[(lastBit = precisionBits - 1 + (i = (exp = bias + 1 - i) >= minExp && exp <= maxExp ? i + 1 : bias + 1 - (exp = minExp - 1))) + 1]) {
		if (!(rounded = bin[lastBit])) {
			for (j = lastBit + 2; !rounded && j < len; rounded = bin[j++]);
		}

		for (j = lastBit + 1; rounded && --j >= 0; (bin[j] = !bin[j] - 0) && (rounded = 0));
	}

	for (i = i - 2 < 0 ? -1 : i - 3; ++i < len && !bin[i];);

	if ((exp = bias + 1 - i) >= minExp && exp <= maxExp) {
		++i;
  } else if (exp < minExp) {
		exp != bias + 1 - len && exp < minUnnormExp && this.warn("encodeFloat::float underflow");
		i = bias + 1 - (exp = minExp - 1);
	}

	if (intPart || status !== 0) {
		this.warn(intPart ? "encodeFloat::float overflow" : "encodeFloat::" + status);
		exp = maxExp + 1;
		i = bias + 2;

		if (status == -Infinity) {
			signal = 1;
    } else if (isNaN(status)) {
			bin[i] = 1;
    }
	}

	for (n = Math.abs(exp + bias), j = exponentBits + 1, result = ""; --j; result = (n % 2) + result, n = n >>= 1);

	for (n = 0, j = 0, i = (result = (signal ? "1" : "0") + result + bin.slice(i, i + precisionBits).join("")).length, r = []; i; j = (j + 1) % 8) {
		n += (1 << j) * result.charAt(--i);
		if (j == 7) {
			r[r.length] = String.fromCharCode(n);
			n = 0;
		}
	}

	r[r.length] = n
    ? String.fromCharCode(n)
    : "";

	return (this.bigEndian ? r.reverse() : r).join("");
};

BinaryParser.encodeInt = function encodeInt (data, bits, signed, forceBigEndian) {
	var max = maxBits[bits];

  if (data >= max || data < -(max / 2)) {
    this.warn("encodeInt::overflow");
    data = 0;
  }

	if (data < 0) {
    data += max;
  }

	for (var r = []; data; r[r.length] = String.fromCharCode(data % 256), data = Math.floor(data / 256));

	for (bits = -(-bits >> 3) - r.length; bits--; r[r.length] = "\0");

  return ((this.bigEndian || forceBigEndian) ? r.reverse() : r).join("");
};

BinaryParser.toSmall    = function( data ){ return this.decodeInt( data,  8, true  ); };
BinaryParser.fromSmall  = function( data ){ return this.encodeInt( data,  8, true  ); };
BinaryParser.toByte     = function( data ){ return this.decodeInt( data,  8, false ); };
BinaryParser.fromByte   = function( data ){ return this.encodeInt( data,  8, false ); };
BinaryParser.toShort    = function( data ){ return this.decodeInt( data, 16, true  ); };
BinaryParser.fromShort  = function( data ){ return this.encodeInt( data, 16, true  ); };
BinaryParser.toWord     = function( data ){ return this.decodeInt( data, 16, false ); };
BinaryParser.fromWord   = function( data ){ return this.encodeInt( data, 16, false ); };
BinaryParser.toInt      = function( data ){ return this.decodeInt( data, 32, true  ); };
BinaryParser.fromInt    = function( data ){ return this.encodeInt( data, 32, true  ); };
BinaryParser.toLong     = function( data ){ return this.decodeInt( data, 64, true  ); };
BinaryParser.fromLong   = function( data ){ return this.encodeInt( data, 64, true  ); };
BinaryParser.toDWord    = function( data ){ return this.decodeInt( data, 32, false ); };
BinaryParser.fromDWord  = function( data ){ return this.encodeInt( data, 32, false ); };
BinaryParser.toQWord    = function( data ){ return this.decodeInt( data, 64, true ); };
BinaryParser.fromQWord  = function( data ){ return this.encodeInt( data, 64, true ); };
BinaryParser.toFloat    = function( data ){ return this.decodeFloat( data, 23, 8   ); };
BinaryParser.fromFloat  = function( data ){ return this.encodeFloat( data, 23, 8   ); };
BinaryParser.toDouble   = function( data ){ return this.decodeFloat( data, 52, 11  ); };
BinaryParser.fromDouble = function( data ){ return this.encodeFloat( data, 52, 11  ); };

// Factor out the encode so it can be shared by add_header and push_int32
BinaryParser.encode_int32 = function encode_int32 (number, asArray) {
  var a, b, c, d, unsigned;
  unsigned = (number < 0) ? (number + 0x100000000) : number;
  a = Math.floor(unsigned / 0xffffff);
  unsigned &= 0xffffff;
  b = Math.floor(unsigned / 0xffff);
  unsigned &= 0xffff;
  c = Math.floor(unsigned / 0xff);
  unsigned &= 0xff;
  d = Math.floor(unsigned);
  return asArray ? [chr(a), chr(b), chr(c), chr(d)] : chr(a) + chr(b) + chr(c) + chr(d);
};

BinaryParser.encode_int64 = function encode_int64 (number) {
  var a, b, c, d, e, f, g, h, unsigned;
  unsigned = (number < 0) ? (number + 0x10000000000000000) : number;
  a = Math.floor(unsigned / 0xffffffffffffff);
  unsigned &= 0xffffffffffffff;
  b = Math.floor(unsigned / 0xffffffffffff);
  unsigned &= 0xffffffffffff;
  c = Math.floor(unsigned / 0xffffffffff);
  unsigned &= 0xffffffffff;
  d = Math.floor(unsigned / 0xffffffff);
  unsigned &= 0xffffffff;
  e = Math.floor(unsigned / 0xffffff);
  unsigned &= 0xffffff;
  f = Math.floor(unsigned / 0xffff);
  unsigned &= 0xffff;
  g = Math.floor(unsigned / 0xff);
  unsigned &= 0xff;
  h = Math.floor(unsigned);
  return chr(a) + chr(b) + chr(c) + chr(d) + chr(e) + chr(f) + chr(g) + chr(h);
};

/**
 * UTF8 methods
 */

// Take a raw binary string and return a utf8 string
BinaryParser.decode_utf8 = function decode_utf8 (binaryStr) {
  var len = binaryStr.length
    , decoded = ''
    , i = 0
    , c = 0
    , c1 = 0
    , c2 = 0
    , c3;

  while (i < len) {
    c = binaryStr.charCodeAt(i);
    if (c < 128) {
      decoded += String.fromCharCode(c);
      i++;
    } else if ((c > 191) && (c < 224)) {
	    c2 = binaryStr.charCodeAt(i+1);
      decoded += String.fromCharCode(((c & 31) << 6) | (c2 & 63));
      i += 2;
    } else {
	    c2 = binaryStr.charCodeAt(i+1);
	    c3 = binaryStr.charCodeAt(i+2);
      decoded += String.fromCharCode(((c & 15) << 12) | ((c2 & 63) << 6) | (c3 & 63));
      i += 3;
    }
  }

  return decoded;
};

// Encode a cstring
BinaryParser.encode_cstring = function encode_cstring (s) {
  return unescape(encodeURIComponent(s)) + BinaryParser.fromByte(0);
};

// Take a utf8 string and return a binary string
BinaryParser.encode_utf8 = function encode_utf8 (s) {
  var a = ""
    , c;

  for (var n = 0, len = s.length; n < len; n++) {
    c = s.charCodeAt(n);

    if (c < 128) {
	    a += String.fromCharCode(c);
    } else if ((c > 127) && (c < 2048)) {
	    a += String.fromCharCode((c>>6) | 192) ;
	    a += String.fromCharCode((c&63) | 128);
    } else {
      a += String.fromCharCode((c>>12) | 224);
      a += String.fromCharCode(((c>>6) & 63) | 128);
      a += String.fromCharCode((c&63) | 128);
    }
  }

  return a;
};

BinaryParser.hprint = function hprint (s) {
  var number;

  for (var i = 0, len = s.length; i < len; i++) {
    if (s.charCodeAt(i) < 32) {
      number = s.charCodeAt(i) <= 15
        ? "0" + s.charCodeAt(i).toString(16)
        : s.charCodeAt(i).toString(16);        
      process.stdout.write(number + " ")
    } else {
      number = s.charCodeAt(i) <= 15
        ? "0" + s.charCodeAt(i).toString(16)
        : s.charCodeAt(i).toString(16);
        process.stdout.write(number + " ")
    }
  }
  
  process.stdout.write("\n\n");
};

BinaryParser.ilprint = function hprint (s) {
  var number;

  for (var i = 0, len = s.length; i < len; i++) {
    if (s.charCodeAt(i) < 32) {
      number = s.charCodeAt(i) <= 15
        ? "0" + s.charCodeAt(i).toString(10)
        : s.charCodeAt(i).toString(10);

      require('util').debug(number+' : ');
    } else {
      number = s.charCodeAt(i) <= 15
        ? "0" + s.charCodeAt(i).toString(10)
        : s.charCodeAt(i).toString(10);
      require('util').debug(number+' : '+ s.charAt(i));
    }
  }
};

BinaryParser.hlprint = function hprint (s) {
  var number;

  for (var i = 0, len = s.length; i < len; i++) {
    if (s.charCodeAt(i) < 32) {
      number = s.charCodeAt(i) <= 15
        ? "0" + s.charCodeAt(i).toString(16)
        : s.charCodeAt(i).toString(16);
      require('util').debug(number+' : ');
    } else {
      number = s.charCodeAt(i) <= 15
        ? "0" + s.charCodeAt(i).toString(16)
        : s.charCodeAt(i).toString(16);
      require('util').debug(number+' : '+ s.charAt(i));
    }
  }
};

/**
 * BinaryParser buffer constructor.
 */
function BinaryParserBuffer (bigEndian, buffer) {
  this.bigEndian = bigEndian || 0;
  this.buffer = [];
  this.setBuffer(buffer);
};

BinaryParserBuffer.prototype.setBuffer = function setBuffer (data) {
  var l, i, b;

	if (data) {
    i = l = data.length;
    b = this.buffer = new Array(l);
		for (; i; b[l - i] = data.charCodeAt(--i));
		this.bigEndian && b.reverse();
	}
};

BinaryParserBuffer.prototype.hasNeededBits = function hasNeededBits (neededBits) {
	return this.buffer.length >= -(-neededBits >> 3);
};

BinaryParserBuffer.prototype.checkBuffer = function checkBuffer (neededBits) {
	if (!this.hasNeededBits(neededBits)) {
		throw new Error("checkBuffer::missing bytes");
  }
};

BinaryParserBuffer.prototype.readBits = function readBits (start, length) {
	//shl fix: Henri Torgemane ~1996 (compressed by Jonas Raoni)

	function shl (a, b) {
		for (; b--; a = ((a %= 0x7fffffff + 1) & 0x40000000) == 0x40000000 ? a * 2 : (a - 0x40000000) * 2 + 0x7fffffff + 1);
		return a;
	}

	if (start < 0 || length <= 0) {
		return 0;
  }

	this.checkBuffer(start + length);

  var offsetLeft
    , offsetRight = start % 8
    , curByte = this.buffer.length - ( start >> 3 ) - 1
    , lastByte = this.buffer.length + ( -( start + length ) >> 3 )
    , diff = curByte - lastByte
    , sum = ((this.buffer[ curByte ] >> offsetRight) & ((1 << (diff ? 8 - offsetRight : length)) - 1)) + (diff && (offsetLeft = (start + length) % 8) ? (this.buffer[lastByte++] & ((1 << offsetLeft) - 1)) << (diff-- << 3) - offsetRight : 0);

	for(; diff; sum += shl(this.buffer[lastByte++], (diff-- << 3) - offsetRight));

	return sum;
};

/**
 * Expose.
 */
BinaryParser.Buffer = BinaryParserBuffer;

exports.BinaryParser = BinaryParser;

}, 



'bson': function(module, exports, global, require, undefined){
  var Long = require('./long').Long
  , Double = require('./double').Double
  , Timestamp = require('./timestamp').Timestamp
  , ObjectID = require('./objectid').ObjectID
  , Symbol = require('./symbol').Symbol
  , Code = require('./code').Code
  , MinKey = require('./min_key').MinKey
  , MaxKey = require('./max_key').MaxKey
  , DBRef = require('./db_ref').DBRef
  , Binary = require('./binary').Binary
  , BinaryParser = require('./binary_parser').BinaryParser
  , writeIEEE754 = require('./float_parser').writeIEEE754
  , readIEEE754 = require('./float_parser').readIEEE754

// To ensure that 0.4 of node works correctly
var isDate = function isDate(d) {
  return typeof d === 'object' && Object.prototype.toString.call(d) === '[object Date]';
}

/**
 * Create a new BSON instance
 *
 * @class Represents the BSON Parser
 * @return {BSON} instance of BSON Parser.
 */
function BSON () {};

/**
 * @ignore
 * @api private
 */
// BSON MAX VALUES
BSON.BSON_INT32_MAX = 0x7FFFFFFF;
BSON.BSON_INT32_MIN = -0x80000000;

BSON.BSON_INT64_MAX = Math.pow(2, 63) - 1;
BSON.BSON_INT64_MIN = -Math.pow(2, 63);

// JS MAX PRECISE VALUES
BSON.JS_INT_MAX = 0x20000000000000;  // Any integer up to 2^53 can be precisely represented by a double.
BSON.JS_INT_MIN = -0x20000000000000;  // Any integer down to -2^53 can be precisely represented by a double.

// Internal long versions
var JS_INT_MAX_LONG = Long.fromNumber(0x20000000000000);  // Any integer up to 2^53 can be precisely represented by a double.
var JS_INT_MIN_LONG = Long.fromNumber(-0x20000000000000);  // Any integer down to -2^53 can be precisely represented by a double.

/**
 * Number BSON Type
 *
 * @classconstant BSON_DATA_NUMBER
 **/
BSON.BSON_DATA_NUMBER = 1;
/**
 * String BSON Type
 *
 * @classconstant BSON_DATA_STRING
 **/
BSON.BSON_DATA_STRING = 2;
/**
 * Object BSON Type
 *
 * @classconstant BSON_DATA_OBJECT
 **/
BSON.BSON_DATA_OBJECT = 3;
/**
 * Array BSON Type
 *
 * @classconstant BSON_DATA_ARRAY
 **/
BSON.BSON_DATA_ARRAY = 4;
/**
 * Binary BSON Type
 *
 * @classconstant BSON_DATA_BINARY
 **/
BSON.BSON_DATA_BINARY = 5;
/**
 * ObjectID BSON Type
 *
 * @classconstant BSON_DATA_OID
 **/
BSON.BSON_DATA_OID = 7;
/**
 * Boolean BSON Type
 *
 * @classconstant BSON_DATA_BOOLEAN
 **/
BSON.BSON_DATA_BOOLEAN = 8;
/**
 * Date BSON Type
 *
 * @classconstant BSON_DATA_DATE
 **/
BSON.BSON_DATA_DATE = 9;
/**
 * null BSON Type
 *
 * @classconstant BSON_DATA_NULL
 **/
BSON.BSON_DATA_NULL = 10;
/**
 * RegExp BSON Type
 *
 * @classconstant BSON_DATA_REGEXP
 **/
BSON.BSON_DATA_REGEXP = 11;
/**
 * Code BSON Type
 *
 * @classconstant BSON_DATA_CODE
 **/
BSON.BSON_DATA_CODE = 13;
/**
 * Symbol BSON Type
 *
 * @classconstant BSON_DATA_SYMBOL
 **/
BSON.BSON_DATA_SYMBOL = 14;
/**
 * Code with Scope BSON Type
 *
 * @classconstant BSON_DATA_CODE_W_SCOPE
 **/
BSON.BSON_DATA_CODE_W_SCOPE = 15;
/**
 * 32 bit Integer BSON Type
 *
 * @classconstant BSON_DATA_INT
 **/
BSON.BSON_DATA_INT = 16;
/**
 * Timestamp BSON Type
 *
 * @classconstant BSON_DATA_TIMESTAMP
 **/
BSON.BSON_DATA_TIMESTAMP = 17;
/**
 * Long BSON Type
 *
 * @classconstant BSON_DATA_LONG
 **/
BSON.BSON_DATA_LONG = 18;
/**
 * MinKey BSON Type
 *
 * @classconstant BSON_DATA_MIN_KEY
 **/
BSON.BSON_DATA_MIN_KEY = 0xff;
/**
 * MaxKey BSON Type
 *
 * @classconstant BSON_DATA_MAX_KEY
 **/
BSON.BSON_DATA_MAX_KEY = 0x7f;

/**
 * Binary Default Type
 *
 * @classconstant BSON_BINARY_SUBTYPE_DEFAULT
 **/
BSON.BSON_BINARY_SUBTYPE_DEFAULT = 0;
/**
 * Binary Function Type
 *
 * @classconstant BSON_BINARY_SUBTYPE_FUNCTION
 **/
BSON.BSON_BINARY_SUBTYPE_FUNCTION = 1;
/**
 * Binary Byte Array Type
 *
 * @classconstant BSON_BINARY_SUBTYPE_BYTE_ARRAY
 **/
BSON.BSON_BINARY_SUBTYPE_BYTE_ARRAY = 2;
/**
 * Binary UUID Type
 *
 * @classconstant BSON_BINARY_SUBTYPE_UUID
 **/
BSON.BSON_BINARY_SUBTYPE_UUID = 3;
/**
 * Binary MD5 Type
 *
 * @classconstant BSON_BINARY_SUBTYPE_MD5
 **/
BSON.BSON_BINARY_SUBTYPE_MD5 = 4;
/**
 * Binary User Defined Type
 *
 * @classconstant BSON_BINARY_SUBTYPE_USER_DEFINED
 **/
BSON.BSON_BINARY_SUBTYPE_USER_DEFINED = 128;

/**
 * Calculate the bson size for a passed in Javascript object.
 *
 * @param {Object} object the Javascript object to calculate the BSON byte size for.
 * @param {Boolean} [serializeFunctions] serialize all functions in the object **(default:false)**.
 * @return {Number} returns the number of bytes the BSON object will take up.
 * @api public
 */
BSON.calculateObjectSize = function calculateObjectSize(object, serializeFunctions) {
  var totalLength = (4 + 1);

  if(Array.isArray(object)) {
    for(var i = 0; i < object.length; i++) {
      totalLength += calculateElement(i.toString(), object[i], serializeFunctions)
    }
  } else {
		// If we have toBSON defined, override the current object
		if(object.toBSON) {
			object = object.toBSON();
		}

		// Calculate size
    for(var key in object) {
      totalLength += calculateElement(key, object[key], serializeFunctions)
    }
  }

  return totalLength;
}

/**
 * @ignore
 * @api private
 */
function calculateElement(name, value, serializeFunctions) {
  var isBuffer = typeof Buffer !== 'undefined';

  switch(typeof value) {
    case 'string':
      return 1 + (!isBuffer ? numberOfBytes(name) : Buffer.byteLength(name, 'utf8')) + 1 + 4 + (!isBuffer ? numberOfBytes(value) : Buffer.byteLength(value, 'utf8')) + 1;
    case 'number':
      if(Math.floor(value) === value && value >= BSON.JS_INT_MIN && value <= BSON.JS_INT_MAX) {
        if(value >= BSON.BSON_INT32_MIN && value <= BSON.BSON_INT32_MAX) { // 32 bit
          return (name != null ? ((!isBuffer ? numberOfBytes(name) : Buffer.byteLength(name, 'utf8')) + 1) : 0) + (4 + 1);
        } else {
          return (name != null ? ((!isBuffer ? numberOfBytes(name) : Buffer.byteLength(name, 'utf8')) + 1) : 0) + (8 + 1);
        }
      } else {  // 64 bit
        return (name != null ? ((!isBuffer ? numberOfBytes(name) : Buffer.byteLength(name, 'utf8')) + 1) : 0) + (8 + 1);
      }
    case 'undefined':
      return (name != null ? ((!isBuffer ? numberOfBytes(name) : Buffer.byteLength(name, 'utf8')) + 1) : 0) + (1);
    case 'boolean':
      return (name != null ? ((!isBuffer ? numberOfBytes(name) : Buffer.byteLength(name, 'utf8')) + 1) : 0) + (1 + 1);
    case 'object':
      if(value == null || value instanceof MinKey || value instanceof MaxKey || value['_bsontype'] == 'MinKey' || value['_bsontype'] == 'MaxKey') {
        return (name != null ? ((!isBuffer ? numberOfBytes(name) : Buffer.byteLength(name, 'utf8')) + 1) : 0) + (1);
      } else if(value instanceof ObjectID || value['_bsontype'] == 'ObjectID') {
        return (name != null ? ((!isBuffer ? numberOfBytes(name) : Buffer.byteLength(name, 'utf8')) + 1) : 0) + (12 + 1);
      } else if(value instanceof Date || isDate(value)) {
        return (name != null ? ((!isBuffer ? numberOfBytes(name) : Buffer.byteLength(name, 'utf8')) + 1) : 0) + (8 + 1);
      } else if(typeof Buffer !== 'undefined' && Buffer.isBuffer(value)) {
        return (name != null ? ((!isBuffer ? numberOfBytes(name) : Buffer.byteLength(name, 'utf8')) + 1) : 0) + (1 + 4 + 1) + value.length;
      } else if(value instanceof Long || value instanceof Double || value instanceof Timestamp
          || value['_bsontype'] == 'Long' || value['_bsontype'] == 'Double' || value['_bsontype'] == 'Timestamp') {
        return (name != null ? ((!isBuffer ? numberOfBytes(name) : Buffer.byteLength(name, 'utf8')) + 1) : 0) + (8 + 1);
      } else if(value instanceof Code || value['_bsontype'] == 'Code') {
        // Calculate size depending on the availability of a scope
        if(value.scope != null && Object.keys(value.scope).length > 0) {
          return (name != null ? ((!isBuffer ? numberOfBytes(name) : Buffer.byteLength(name, 'utf8')) + 1) : 0) + 1 + 4 + 4 + (!isBuffer ? numberOfBytes(value.code.toString()) : Buffer.byteLength(value.code.toString(), 'utf8')) + 1 + BSON.calculateObjectSize(value.scope, serializeFunctions);
        } else {
          return (name != null ? ((!isBuffer ? numberOfBytes(name) : Buffer.byteLength(name, 'utf8')) + 1) : 0) + 1 + 4 + (!isBuffer ? numberOfBytes(value.code.toString()) : Buffer.byteLength(value.code.toString(), 'utf8')) + 1;
        }
      } else if(value instanceof Binary || value['_bsontype'] == 'Binary') {
        // Check what kind of subtype we have
        if(value.sub_type == Binary.SUBTYPE_BYTE_ARRAY) {
          return (name != null ? ((!isBuffer ? numberOfBytes(name) : Buffer.byteLength(name, 'utf8')) + 1) : 0) + (value.position + 1 + 4 + 1 + 4);
        } else {
          return (name != null ? ((!isBuffer ? numberOfBytes(name) : Buffer.byteLength(name, 'utf8')) + 1) : 0) + (value.position + 1 + 4 + 1);
        }
      } else if(value instanceof Symbol || value['_bsontype'] == 'Symbol') {
        return (name != null ? ((!isBuffer ? numberOfBytes(name) : Buffer.byteLength(name, 'utf8')) + 1) : 0) + ((!isBuffer ? numberOfBytes(value.value) : Buffer.byteLength(value.value, 'utf8')) + 4 + 1 + 1);
      } else if(value instanceof DBRef || value['_bsontype'] == 'DBRef') {
        // Set up correct object for serialization
        var ordered_values = {
            '$ref': value.namespace
          , '$id' : value.oid
        };

        // Add db reference if it exists
        if(null != value.db) {
          ordered_values['$db'] = value.db;
        }

        return (name != null ? ((!isBuffer ? numberOfBytes(name) : Buffer.byteLength(name, 'utf8')) + 1) : 0) + 1 + BSON.calculateObjectSize(ordered_values, serializeFunctions);
      } else if(value instanceof RegExp || Object.prototype.toString.call(value) === '[object RegExp]') {
          return (name != null ? ((!isBuffer ? numberOfBytes(name) : Buffer.byteLength(name, 'utf8')) + 1) : 0) + 1 + (!isBuffer ? numberOfBytes(value.source) : Buffer.byteLength(value.source, 'utf8')) + 1
            + (value.global ? 1 : 0) + (value.ignoreCase ? 1 : 0) + (value.multiline ? 1 : 0) + 1
      } else {
        return (name != null ? ((!isBuffer ? numberOfBytes(name) : Buffer.byteLength(name, 'utf8')) + 1) : 0) + BSON.calculateObjectSize(value, serializeFunctions) + 1;
      }
    case 'function':
      // WTF for 0.4.X where typeof /someregexp/ === 'function'
      if(value instanceof RegExp || Object.prototype.toString.call(value) === '[object RegExp]' || String.call(value) == '[object RegExp]') {
        return (name != null ? ((!isBuffer ? numberOfBytes(name) : Buffer.byteLength(name, 'utf8')) + 1) : 0) + 1 + (!isBuffer ? numberOfBytes(value.source) : Buffer.byteLength(value.source, 'utf8')) + 1
          + (value.global ? 1 : 0) + (value.ignoreCase ? 1 : 0) + (value.multiline ? 1 : 0) + 1
      } else {
        if(serializeFunctions && value.scope != null && Object.keys(value.scope).length > 0) {
          return (name != null ? ((!isBuffer ? numberOfBytes(name) : Buffer.byteLength(name, 'utf8')) + 1) : 0) + 1 + 4 + 4 + (!isBuffer ? numberOfBytes(value.toString()) : Buffer.byteLength(value.toString(), 'utf8')) + 1 + BSON.calculateObjectSize(value.scope, serializeFunctions);
        } else if(serializeFunctions) {
          return (name != null ? ((!isBuffer ? numberOfBytes(name) : Buffer.byteLength(name, 'utf8')) + 1) : 0) + 1 + 4 + (!isBuffer ? numberOfBytes(value.toString()) : Buffer.byteLength(value.toString(), 'utf8')) + 1;
        }
      }
  }

  return 0;
}

/**
 * Serialize a Javascript object using a predefined Buffer and index into the buffer, useful when pre-allocating the space for serialization.
 *
 * @param {Object} object the Javascript object to serialize.
 * @param {Boolean} checkKeys the serializer will check if keys are valid.
 * @param {Buffer} buffer the Buffer you pre-allocated to store the serialized BSON object.
 * @param {Number} index the index in the buffer where we wish to start serializing into.
 * @param {Boolean} serializeFunctions serialize the javascript functions **(default:false)**.
 * @return {Number} returns the new write index in the Buffer.
 * @api public
 */
BSON.serializeWithBufferAndIndex = function serializeWithBufferAndIndex(object, checkKeys, buffer, index, serializeFunctions) {
  // Default setting false
  serializeFunctions = serializeFunctions == null ? false : serializeFunctions;
  // Write end information (length of the object)
  var size = buffer.length;
  // Write the size of the object
  buffer[index++] = size & 0xff;
  buffer[index++] = (size >> 8) & 0xff;
  buffer[index++] = (size >> 16) & 0xff;
  buffer[index++] = (size >> 24) & 0xff;
  return serializeObject(object, checkKeys, buffer, index, serializeFunctions) - 1;
}

/**
 * @ignore
 * @api private
 */
var serializeObject = function(object, checkKeys, buffer, index, serializeFunctions) {
  // Process the object
  if(Array.isArray(object)) {
    for(var i = 0; i < object.length; i++) {
      index = packElement(i.toString(), object[i], checkKeys, buffer, index, serializeFunctions);
    }
  } else {
		// If we have toBSON defined, override the current object
		if(object.toBSON) {
			object = object.toBSON();
		}

		// Serialize the object
    for(var key in object) {
      // Check the key and throw error if it's illegal
      if (key != '$db' && key != '$ref' && key != '$id') {
        // dollars and dots ok
        BSON.checkKey(key, !checkKeys);
      }

      // Pack the element
      index = packElement(key, object[key], checkKeys, buffer, index, serializeFunctions);
    }
  }

  // Write zero
  buffer[index++] = 0;
  return index;
}

var stringToBytes = function(str) {
  var ch, st, re = [];
  for (var i = 0; i < str.length; i++ ) {
    ch = str.charCodeAt(i);  // get char
    st = [];                 // set up "stack"
    do {
      st.push( ch & 0xFF );  // push byte to stack
      ch = ch >> 8;          // shift value down by 1 byte
    }
    while ( ch );
    // add stack contents to result
    // done because chars have "wrong" endianness
    re = re.concat( st.reverse() );
  }
  // return an array of bytes
  return re;
}

var numberOfBytes = function(str) {
  var ch, st, re = 0;
  for (var i = 0; i < str.length; i++ ) {
    ch = str.charCodeAt(i);  // get char
    st = [];                 // set up "stack"
    do {
      st.push( ch & 0xFF );  // push byte to stack
      ch = ch >> 8;          // shift value down by 1 byte
    }
    while ( ch );
    // add stack contents to result
    // done because chars have "wrong" endianness
    re = re + st.length;
  }
  // return an array of bytes
  return re;
}

/**
 * @ignore
 * @api private
 */
var writeToTypedArray = function(buffer, string, index) {
  var bytes = stringToBytes(string);
  for(var i = 0; i < bytes.length; i++) {
    buffer[index + i] = bytes[i];
  }
  return bytes.length;
}

/**
 * @ignore
 * @api private
 */
var supportsBuffer = typeof Buffer != 'undefined';

/**
 * @ignore
 * @api private
 */
var packElement = function(name, value, checkKeys, buffer, index, serializeFunctions) {
  var startIndex = index;

  switch(typeof value) {
    case 'string':
      // Encode String type
      buffer[index++] = BSON.BSON_DATA_STRING;
      // Number of written bytes
      var numberOfWrittenBytes = supportsBuffer ? buffer.write(name, index, 'utf8') : writeToTypedArray(buffer, name, index);
      // Encode the name
      index = index + numberOfWrittenBytes + 1;
      buffer[index - 1] = 0;

      // Calculate size
      var size = supportsBuffer ? Buffer.byteLength(value) + 1 : numberOfBytes(value) + 1;
      // Write the size of the string to buffer
      buffer[index + 3] = (size >> 24) & 0xff;
      buffer[index + 2] = (size >> 16) & 0xff;
      buffer[index + 1] = (size >> 8) & 0xff;
      buffer[index] = size & 0xff;
      // Ajust the index
      index = index + 4;
      // Write the string
      supportsBuffer ? buffer.write(value, index, 'utf8') : writeToTypedArray(buffer, value, index);
      // Update index
      index = index + size - 1;
      // Write zero
      buffer[index++] = 0;
      // Return index
      return index;
    case 'number':
      // We have an integer value
      if(Math.floor(value) === value && value >= BSON.JS_INT_MIN && value <= BSON.JS_INT_MAX) {
        // If the value fits in 32 bits encode as int, if it fits in a double
        // encode it as a double, otherwise long
        if(value >= BSON.BSON_INT32_MIN && value <= BSON.BSON_INT32_MAX) {
          // Set int type 32 bits or less
          buffer[index++] = BSON.BSON_DATA_INT;
          // Number of written bytes
          var numberOfWrittenBytes = supportsBuffer ? buffer.write(name, index, 'utf8') : writeToTypedArray(buffer, name, index);
          // Encode the name
          index = index + numberOfWrittenBytes + 1;
          buffer[index - 1] = 0;
          // Write the int value
          buffer[index++] = value & 0xff;
          buffer[index++] = (value >> 8) & 0xff;
          buffer[index++] = (value >> 16) & 0xff;
          buffer[index++] = (value >> 24) & 0xff;
        } else if(value >= BSON.JS_INT_MIN && value <= BSON.JS_INT_MAX) {
          // Encode as double
          buffer[index++] = BSON.BSON_DATA_NUMBER;
          // Number of written bytes
          var numberOfWrittenBytes = supportsBuffer ? buffer.write(name, index, 'utf8') : writeToTypedArray(buffer, name, index);
          // Encode the name
          index = index + numberOfWrittenBytes + 1;
          buffer[index - 1] = 0;
          // Write float
          writeIEEE754(buffer, value, index, 'little', 52, 8);
          // Ajust index
          index = index + 8;
        } else {
          // Set long type
          buffer[index++] = BSON.BSON_DATA_LONG;
          // Number of written bytes
          var numberOfWrittenBytes = supportsBuffer ? buffer.write(name, index, 'utf8') : writeToTypedArray(buffer, name, index);
          // Encode the name
          index = index + numberOfWrittenBytes + 1;
          buffer[index - 1] = 0;
          var longVal = Long.fromNumber(value);
          var lowBits = longVal.getLowBits();
          var highBits = longVal.getHighBits();
          // Encode low bits
          buffer[index++] = lowBits & 0xff;
          buffer[index++] = (lowBits >> 8) & 0xff;
          buffer[index++] = (lowBits >> 16) & 0xff;
          buffer[index++] = (lowBits >> 24) & 0xff;
          // Encode high bits
          buffer[index++] = highBits & 0xff;
          buffer[index++] = (highBits >> 8) & 0xff;
          buffer[index++] = (highBits >> 16) & 0xff;
          buffer[index++] = (highBits >> 24) & 0xff;
        }
      } else {
        // Encode as double
        buffer[index++] = BSON.BSON_DATA_NUMBER;
        // Number of written bytes
        var numberOfWrittenBytes = supportsBuffer ? buffer.write(name, index, 'utf8') : writeToTypedArray(buffer, name, index);
        // Encode the name
        index = index + numberOfWrittenBytes + 1;
        buffer[index - 1] = 0;
        // Write float
        writeIEEE754(buffer, value, index, 'little', 52, 8);
        // Ajust index
        index = index + 8;
      }

      return index;
    case 'undefined':
      // Set long type
      buffer[index++] = BSON.BSON_DATA_NULL;
      // Number of written bytes
      var numberOfWrittenBytes = supportsBuffer ? buffer.write(name, index, 'utf8') : writeToTypedArray(buffer, name, index);
      // Encode the name
      index = index + numberOfWrittenBytes + 1;
      buffer[index - 1] = 0;
      return index;
    case 'boolean':
      // Write the type
      buffer[index++] = BSON.BSON_DATA_BOOLEAN;
      // Number of written bytes
      var numberOfWrittenBytes = supportsBuffer ? buffer.write(name, index, 'utf8') : writeToTypedArray(buffer, name, index);
      // Encode the name
      index = index + numberOfWrittenBytes + 1;
      buffer[index - 1] = 0;
      // Encode the boolean value
      buffer[index++] = value ? 1 : 0;
      return index;
    case 'object':
      if(value === null || value instanceof MinKey || value instanceof MaxKey
          || value['_bsontype'] == 'MinKey' || value['_bsontype'] == 'MaxKey') {
        // Write the type of either min or max key
        if(value === null) {
          buffer[index++] = BSON.BSON_DATA_NULL;
        } else if(value instanceof MinKey) {
          buffer[index++] = BSON.BSON_DATA_MIN_KEY;
        } else {
          buffer[index++] = BSON.BSON_DATA_MAX_KEY;
        }

        // Number of written bytes
        var numberOfWrittenBytes = supportsBuffer ? buffer.write(name, index, 'utf8') : writeToTypedArray(buffer, name, index);
        // Encode the name
        index = index + numberOfWrittenBytes + 1;
        buffer[index - 1] = 0;
        return index;
      } else if(value instanceof ObjectID || value['_bsontype'] == 'ObjectID') {
        // Write the type
        buffer[index++] = BSON.BSON_DATA_OID;
        // Number of written bytes
        var numberOfWrittenBytes = supportsBuffer ? buffer.write(name, index, 'utf8') : writeToTypedArray(buffer, name, index);
        // Encode the name
        index = index + numberOfWrittenBytes + 1;
        buffer[index - 1] = 0;

        // Write objectid
        supportsBuffer ? buffer.write(value.id, index, 'binary') : writeToTypedArray(buffer, value.id, index);
        // Ajust index
        index = index + 12;
        return index;
      } else if(value instanceof Date || isDate(value)) {
        // Write the type
        buffer[index++] = BSON.BSON_DATA_DATE;
        // Number of written bytes
        var numberOfWrittenBytes = supportsBuffer ? buffer.write(name, index, 'utf8') : writeToTypedArray(buffer, name, index);
        // Encode the name
        index = index + numberOfWrittenBytes + 1;
        buffer[index - 1] = 0;

        // Write the date
        var dateInMilis = Long.fromNumber(value.getTime());
        var lowBits = dateInMilis.getLowBits();
        var highBits = dateInMilis.getHighBits();
        // Encode low bits
        buffer[index++] = lowBits & 0xff;
        buffer[index++] = (lowBits >> 8) & 0xff;
        buffer[index++] = (lowBits >> 16) & 0xff;
        buffer[index++] = (lowBits >> 24) & 0xff;
        // Encode high bits
        buffer[index++] = highBits & 0xff;
        buffer[index++] = (highBits >> 8) & 0xff;
        buffer[index++] = (highBits >> 16) & 0xff;
        buffer[index++] = (highBits >> 24) & 0xff;
        return index;
      } else if(typeof Buffer !== 'undefined' && Buffer.isBuffer(value)) {
        // Write the type
        buffer[index++] = BSON.BSON_DATA_BINARY;
        // Number of written bytes
        var numberOfWrittenBytes = supportsBuffer ? buffer.write(name, index, 'utf8') : writeToTypedArray(buffer, name, index);
        // Encode the name
        index = index + numberOfWrittenBytes + 1;
        buffer[index - 1] = 0;
        // Get size of the buffer (current write point)
        var size = value.length;
        // Write the size of the string to buffer
        buffer[index++] = size & 0xff;
        buffer[index++] = (size >> 8) & 0xff;
        buffer[index++] = (size >> 16) & 0xff;
        buffer[index++] = (size >> 24) & 0xff;
        // Write the default subtype
        buffer[index++] = BSON.BSON_BINARY_SUBTYPE_DEFAULT;
        // Copy the content form the binary field to the buffer
        value.copy(buffer, index, 0, size);
        // Adjust the index
        index = index + size;
        return index;
      } else if(value instanceof Long || value instanceof Timestamp || value['_bsontype'] == 'Long' || value['_bsontype'] == 'Timestamp') {
        // Write the type
        buffer[index++] = value instanceof Long ? BSON.BSON_DATA_LONG : BSON.BSON_DATA_TIMESTAMP;
        // Number of written bytes
        var numberOfWrittenBytes = supportsBuffer ? buffer.write(name, index, 'utf8') : writeToTypedArray(buffer, name, index);
        // Encode the name
        index = index + numberOfWrittenBytes + 1;
        buffer[index - 1] = 0;
        // Write the date
        var lowBits = value.getLowBits();
        var highBits = value.getHighBits();
        // Encode low bits
        buffer[index++] = lowBits & 0xff;
        buffer[index++] = (lowBits >> 8) & 0xff;
        buffer[index++] = (lowBits >> 16) & 0xff;
        buffer[index++] = (lowBits >> 24) & 0xff;
        // Encode high bits
        buffer[index++] = highBits & 0xff;
        buffer[index++] = (highBits >> 8) & 0xff;
        buffer[index++] = (highBits >> 16) & 0xff;
        buffer[index++] = (highBits >> 24) & 0xff;
        return index;
      } else if(value instanceof Double || value['_bsontype'] == 'Double') {
        // Encode as double
        buffer[index++] = BSON.BSON_DATA_NUMBER;
        // Number of written bytes
        var numberOfWrittenBytes = supportsBuffer ? buffer.write(name, index, 'utf8') : writeToTypedArray(buffer, name, index);
        // Encode the name
        index = index + numberOfWrittenBytes + 1;
        buffer[index - 1] = 0;
        // Write float
        writeIEEE754(buffer, value, index, 'little', 52, 8);
        // Ajust index
        index = index + 8;
        return index;
      } else if(value instanceof Code || value['_bsontype'] == 'Code') {
        if(value.scope != null && Object.keys(value.scope).length > 0) {
          // Write the type
          buffer[index++] = BSON.BSON_DATA_CODE_W_SCOPE;
          // Number of written bytes
          var numberOfWrittenBytes = supportsBuffer ? buffer.write(name, index, 'utf8') : writeToTypedArray(buffer, name, index);
          // Encode the name
          index = index + numberOfWrittenBytes + 1;
          buffer[index - 1] = 0;
          // Calculate the scope size
          var scopeSize = BSON.calculateObjectSize(value.scope, serializeFunctions);
          // Function string
          var functionString = value.code.toString();
          // Function Size
          var codeSize = supportsBuffer ? Buffer.byteLength(functionString) + 1 : numberOfBytes(functionString) + 1;

          // Calculate full size of the object
          var totalSize = 4 + codeSize + scopeSize + 4;

          // Write the total size of the object
          buffer[index++] = totalSize & 0xff;
          buffer[index++] = (totalSize >> 8) & 0xff;
          buffer[index++] = (totalSize >> 16) & 0xff;
          buffer[index++] = (totalSize >> 24) & 0xff;

          // Write the size of the string to buffer
          buffer[index++] = codeSize & 0xff;
          buffer[index++] = (codeSize >> 8) & 0xff;
          buffer[index++] = (codeSize >> 16) & 0xff;
          buffer[index++] = (codeSize >> 24) & 0xff;

          // Write the string
          supportsBuffer ? buffer.write(functionString, index, 'utf8') : writeToTypedArray(buffer, functionString, index);
          // Update index
          index = index + codeSize - 1;
          // Write zero
          buffer[index++] = 0;
          // Serialize the scope object
          var scopeObjectBuffer = supportsBuffer ? new Buffer(scopeSize) : new Uint8Array(new ArrayBuffer(scopeSize));
          // Execute the serialization into a seperate buffer
          serializeObject(value.scope, checkKeys, scopeObjectBuffer, 0, serializeFunctions);

          // Adjusted scope Size (removing the header)
          var scopeDocSize = scopeSize;
          // Write scope object size
          buffer[index++] = scopeDocSize & 0xff;
          buffer[index++] = (scopeDocSize >> 8) & 0xff;
          buffer[index++] = (scopeDocSize >> 16) & 0xff;
          buffer[index++] = (scopeDocSize >> 24) & 0xff;

          // Write the scopeObject into the buffer
          supportsBuffer ? scopeObjectBuffer.copy(buffer, index, 0, scopeSize) : buffer.set(scopeObjectBuffer, index);
          // Adjust index, removing the empty size of the doc (5 bytes 0000000005)
          index = index + scopeDocSize - 5;
          // Write trailing zero
          buffer[index++] = 0;
          return index
        } else {
          buffer[index++] = BSON.BSON_DATA_CODE;
          // Number of written bytes
          var numberOfWrittenBytes = supportsBuffer ? buffer.write(name, index, 'utf8') : writeToTypedArray(buffer, name, index);
          // Encode the name
          index = index + numberOfWrittenBytes + 1;
          buffer[index - 1] = 0;
          // Function string
          var functionString = value.code.toString();
          // Function Size
          var size = supportsBuffer ? Buffer.byteLength(functionString) + 1 : numberOfBytes(functionString) + 1;
          // Write the size of the string to buffer
          buffer[index++] = size & 0xff;
          buffer[index++] = (size >> 8) & 0xff;
          buffer[index++] = (size >> 16) & 0xff;
          buffer[index++] = (size >> 24) & 0xff;
          // Write the string
          supportsBuffer ? buffer.write(functionString, index, 'utf8') : writeToTypedArray(buffer, functionString, index);
          // Update index
          index = index + size - 1;
          // Write zero
          buffer[index++] = 0;
          return index;
        }
      } else if(value instanceof Binary || value['_bsontype'] == 'Binary') {
        // Write the type
        buffer[index++] = BSON.BSON_DATA_BINARY;
        // Number of written bytes
        var numberOfWrittenBytes = supportsBuffer ? buffer.write(name, index, 'utf8') : writeToTypedArray(buffer, name, index);
        // Encode the name
        index = index + numberOfWrittenBytes + 1;
        buffer[index - 1] = 0;
        // Extract the buffer
        var data = value.value(true);
        // Calculate size
        var size = value.position;
        // Write the size of the string to buffer
        buffer[index++] = size & 0xff;
        buffer[index++] = (size >> 8) & 0xff;
        buffer[index++] = (size >> 16) & 0xff;
        buffer[index++] = (size >> 24) & 0xff;
        // Write the subtype to the buffer
        buffer[index++] = value.sub_type;

        // If we have binary type 2 the 4 first bytes are the size
        if(value.sub_type == Binary.SUBTYPE_BYTE_ARRAY) {
          buffer[index++] = size & 0xff;
          buffer[index++] = (size >> 8) & 0xff;
          buffer[index++] = (size >> 16) & 0xff;
          buffer[index++] = (size >> 24) & 0xff;
        }

        // Write the data to the object
        supportsBuffer ? data.copy(buffer, index, 0, value.position) : buffer.set(data, index);
        // Ajust index
        index = index + value.position;
        return index;
      } else if(value instanceof Symbol || value['_bsontype'] == 'Symbol') {
        // Write the type
        buffer[index++] = BSON.BSON_DATA_SYMBOL;
        // Number of written bytes
        var numberOfWrittenBytes = supportsBuffer ? buffer.write(name, index, 'utf8') : writeToTypedArray(buffer, name, index);
        // Encode the name
        index = index + numberOfWrittenBytes + 1;
        buffer[index - 1] = 0;
        // Calculate size
        var size = supportsBuffer ? Buffer.byteLength(value.value) + 1 : numberOfBytes(value.value) + 1;
        // Write the size of the string to buffer
        buffer[index++] = size & 0xff;
        buffer[index++] = (size >> 8) & 0xff;
        buffer[index++] = (size >> 16) & 0xff;
        buffer[index++] = (size >> 24) & 0xff;
        // Write the string
        buffer.write(value.value, index, 'utf8');
        // Update index
        index = index + size - 1;
        // Write zero
        buffer[index++] = 0x00;
        return index;
      } else if(value instanceof DBRef || value['_bsontype'] == 'DBRef') {
        // Write the type
        buffer[index++] = BSON.BSON_DATA_OBJECT;
        // Number of written bytes
        var numberOfWrittenBytes = supportsBuffer ? buffer.write(name, index, 'utf8') : writeToTypedArray(buffer, name, index);
        // Encode the name
        index = index + numberOfWrittenBytes + 1;
        buffer[index - 1] = 0;
        // Set up correct object for serialization
        var ordered_values = {
            '$ref': value.namespace
          , '$id' : value.oid
        };

        // Add db reference if it exists
        if(null != value.db) {
          ordered_values['$db'] = value.db;
        }

        // Message size
        var size = BSON.calculateObjectSize(ordered_values, serializeFunctions);
        // Serialize the object
        var endIndex = BSON.serializeWithBufferAndIndex(ordered_values, checkKeys, buffer, index, serializeFunctions);
        // Write the size of the string to buffer
        buffer[index++] = size & 0xff;
        buffer[index++] = (size >> 8) & 0xff;
        buffer[index++] = (size >> 16) & 0xff;
        buffer[index++] = (size >> 24) & 0xff;
        // Write zero for object
        buffer[endIndex++] = 0x00;
        // Return the end index
        return endIndex;
      } else if(value instanceof RegExp || Object.prototype.toString.call(value) === '[object RegExp]') {
        // Write the type
        buffer[index++] = BSON.BSON_DATA_REGEXP;
        // Number of written bytes
        var numberOfWrittenBytes = supportsBuffer ? buffer.write(name, index, 'utf8') : writeToTypedArray(buffer, name, index);
        // Encode the name
        index = index + numberOfWrittenBytes + 1;
        buffer[index - 1] = 0;

        // Write the regular expression string
        supportsBuffer ? buffer.write(value.source, index, 'utf8') : writeToTypedArray(buffer, value.source, index);
        // Adjust the index
        index = index + (supportsBuffer ? Buffer.byteLength(value.source) : numberOfBytes(value.source));
        // Write zero
        buffer[index++] = 0x00;
        // Write the parameters
        if(value.global) buffer[index++] = 0x73; // s
        if(value.ignoreCase) buffer[index++] = 0x69; // i
        if(value.multiline) buffer[index++] = 0x6d; // m
        // Add ending zero
        buffer[index++] = 0x00;
        return index;
      } else {
        // Write the type
        buffer[index++] = Array.isArray(value) ? BSON.BSON_DATA_ARRAY : BSON.BSON_DATA_OBJECT;
        // Number of written bytes
        var numberOfWrittenBytes = supportsBuffer ? buffer.write(name, index, 'utf8') : writeToTypedArray(buffer, name, index);
        // Adjust the index
        index = index + numberOfWrittenBytes + 1;
        buffer[index - 1] = 0;
	      var endIndex = serializeObject(value, checkKeys, buffer, index + 4, serializeFunctions);
        // Write size
        var size = endIndex - index;
        // Write the size of the string to buffer
        buffer[index++] = size & 0xff;
        buffer[index++] = (size >> 8) & 0xff;
        buffer[index++] = (size >> 16) & 0xff;
        buffer[index++] = (size >> 24) & 0xff;
        return endIndex;
      }
    case 'function':
      // WTF for 0.4.X where typeof /someregexp/ === 'function'
      if(value instanceof RegExp || Object.prototype.toString.call(value) === '[object RegExp]' || String.call(value) == '[object RegExp]') {
        // Write the type
        buffer[index++] = BSON.BSON_DATA_REGEXP;
        // Number of written bytes
        var numberOfWrittenBytes = supportsBuffer ? buffer.write(name, index, 'utf8') : writeToTypedArray(buffer, name, index);
        // Encode the name
        index = index + numberOfWrittenBytes + 1;
        buffer[index - 1] = 0;

        // Write the regular expression string
        buffer.write(value.source, index, 'utf8');
        // Adjust the index
        index = index + (supportsBuffer ? Buffer.byteLength(value.source) : numberOfBytes(value.source));
        // Write zero
        buffer[index++] = 0x00;
        // Write the parameters
        if(value.global) buffer[index++] = 0x73; // s
        if(value.ignoreCase) buffer[index++] = 0x69; // i
        if(value.multiline) buffer[index++] = 0x6d; // m
        // Add ending zero
        buffer[index++] = 0x00;
        return index;
      } else {
        if(serializeFunctions && value.scope != null && Object.keys(value.scope).length > 0) {
          // Write the type
          buffer[index++] = BSON.BSON_DATA_CODE_W_SCOPE;
          // Number of written bytes
          var numberOfWrittenBytes = supportsBuffer ? buffer.write(name, index, 'utf8') : writeToTypedArray(buffer, name, index);
          // Encode the name
          index = index + numberOfWrittenBytes + 1;
          buffer[index - 1] = 0;
          // Calculate the scope size
          var scopeSize = BSON.calculateObjectSize(value.scope, serializeFunctions);
          // Function string
          var functionString = value.toString();
          // Function Size
          var codeSize = supportsBuffer ? Buffer.byteLength(functionString) + 1 : numberOfBytes(functionString) + 1;

          // Calculate full size of the object
          var totalSize = 4 + codeSize + scopeSize;

          // Write the total size of the object
          buffer[index++] = totalSize & 0xff;
          buffer[index++] = (totalSize >> 8) & 0xff;
          buffer[index++] = (totalSize >> 16) & 0xff;
          buffer[index++] = (totalSize >> 24) & 0xff;

          // Write the size of the string to buffer
          buffer[index++] = codeSize & 0xff;
          buffer[index++] = (codeSize >> 8) & 0xff;
          buffer[index++] = (codeSize >> 16) & 0xff;
          buffer[index++] = (codeSize >> 24) & 0xff;

          // Write the string
          supportsBuffer ? buffer.write(functionString, index, 'utf8') : writeToTypedArray(buffer, functionString, index);
          // Update index
          index = index + codeSize - 1;
          // Write zero
          buffer[index++] = 0;
          // Serialize the scope object
          var scopeObjectBuffer = new Buffer(scopeSize);
          // Execute the serialization into a seperate buffer
          serializeObject(value.scope, checkKeys, scopeObjectBuffer, 0, serializeFunctions);

          // Adjusted scope Size (removing the header)
          var scopeDocSize = scopeSize - 4;
          // Write scope object size
          buffer[index++] = scopeDocSize & 0xff;
          buffer[index++] = (scopeDocSize >> 8) & 0xff;
          buffer[index++] = (scopeDocSize >> 16) & 0xff;
          buffer[index++] = (scopeDocSize >> 24) & 0xff;

          // Write the scopeObject into the buffer
          scopeObjectBuffer.copy(buffer, index, 0, scopeSize);

          // Adjust index, removing the empty size of the doc (5 bytes 0000000005)
          index = index + scopeDocSize - 5;
          // Write trailing zero
          buffer[index++] = 0;
          return index
        } else if(serializeFunctions) {
          buffer[index++] = BSON.BSON_DATA_CODE;
          // Number of written bytes
          var numberOfWrittenBytes = supportsBuffer ? buffer.write(name, index, 'utf8') : writeToTypedArray(buffer, name, index);
          // Encode the name
          index = index + numberOfWrittenBytes + 1;
          buffer[index - 1] = 0;
          // Function string
          var functionString = value.toString();
          // Function Size
          var size = supportsBuffer ? Buffer.byteLength(functionString) + 1 : numberOfBytes(functionString) + 1;
          // Write the size of the string to buffer
          buffer[index++] = size & 0xff;
          buffer[index++] = (size >> 8) & 0xff;
          buffer[index++] = (size >> 16) & 0xff;
          buffer[index++] = (size >> 24) & 0xff;
          // Write the string
          supportsBuffer ? buffer.write(functionString, index, 'utf8') : writeToTypedArray(buffer, functionString, index);
          // Update index
          index = index + size - 1;
          // Write zero
          buffer[index++] = 0;
          return index;
        }
      }
  }

  // If no value to serialize
  return index;
}

/**
 * Serialize a Javascript object.
 *
 * @param {Object} object the Javascript object to serialize.
 * @param {Boolean} checkKeys the serializer will check if keys are valid.
 * @param {Boolean} asBuffer return the serialized object as a Buffer object **(ignore)**.
 * @param {Boolean} serializeFunctions serialize the javascript functions **(default:false)**.
 * @return {Buffer} returns the Buffer object containing the serialized object.
 * @api public
 */
BSON.serialize = function(object, checkKeys, asBuffer, serializeFunctions) {
  // Throw error if we are trying serialize an illegal type
  if(object == null || typeof object != 'object' || Array.isArray(object)) 
    throw new Error("Only javascript objects supported");
  
  // Emoty target buffer
  var buffer = null;
  // Calculate the size of the object
  var size = BSON.calculateObjectSize(object, serializeFunctions);
  // Fetch the best available type for storing the binary data
  if(buffer = typeof Buffer != 'undefined') {
    buffer = new Buffer(size);
    asBuffer = true;
  } else if(typeof Uint8Array != 'undefined') {
    buffer = new Uint8Array(new ArrayBuffer(size));
  } else {
    buffer = new Array(size);
  }

  // If asBuffer is false use typed arrays
  BSON.serializeWithBufferAndIndex(object, checkKeys, buffer, 0, serializeFunctions);
  return buffer;
}

/**
 * Contains the function cache if we have that enable to allow for avoiding the eval step on each deserialization, comparison is by md5
 *
 * @ignore
 * @api private
 */
var functionCache = BSON.functionCache = {};

/**
 * Crc state variables shared by function
 *
 * @ignore
 * @api private
 */
var table = [0x00000000, 0x77073096, 0xEE0E612C, 0x990951BA, 0x076DC419, 0x706AF48F, 0xE963A535, 0x9E6495A3, 0x0EDB8832, 0x79DCB8A4, 0xE0D5E91E, 0x97D2D988, 0x09B64C2B, 0x7EB17CBD, 0xE7B82D07, 0x90BF1D91, 0x1DB71064, 0x6AB020F2, 0xF3B97148, 0x84BE41DE, 0x1ADAD47D, 0x6DDDE4EB, 0xF4D4B551, 0x83D385C7, 0x136C9856, 0x646BA8C0, 0xFD62F97A, 0x8A65C9EC, 0x14015C4F, 0x63066CD9, 0xFA0F3D63, 0x8D080DF5, 0x3B6E20C8, 0x4C69105E, 0xD56041E4, 0xA2677172, 0x3C03E4D1, 0x4B04D447, 0xD20D85FD, 0xA50AB56B, 0x35B5A8FA, 0x42B2986C, 0xDBBBC9D6, 0xACBCF940, 0x32D86CE3, 0x45DF5C75, 0xDCD60DCF, 0xABD13D59, 0x26D930AC, 0x51DE003A, 0xC8D75180, 0xBFD06116, 0x21B4F4B5, 0x56B3C423, 0xCFBA9599, 0xB8BDA50F, 0x2802B89E, 0x5F058808, 0xC60CD9B2, 0xB10BE924, 0x2F6F7C87, 0x58684C11, 0xC1611DAB, 0xB6662D3D, 0x76DC4190, 0x01DB7106, 0x98D220BC, 0xEFD5102A, 0x71B18589, 0x06B6B51F, 0x9FBFE4A5, 0xE8B8D433, 0x7807C9A2, 0x0F00F934, 0x9609A88E, 0xE10E9818, 0x7F6A0DBB, 0x086D3D2D, 0x91646C97, 0xE6635C01, 0x6B6B51F4, 0x1C6C6162, 0x856530D8, 0xF262004E, 0x6C0695ED, 0x1B01A57B, 0x8208F4C1, 0xF50FC457, 0x65B0D9C6, 0x12B7E950, 0x8BBEB8EA, 0xFCB9887C, 0x62DD1DDF, 0x15DA2D49, 0x8CD37CF3, 0xFBD44C65, 0x4DB26158, 0x3AB551CE, 0xA3BC0074, 0xD4BB30E2, 0x4ADFA541, 0x3DD895D7, 0xA4D1C46D, 0xD3D6F4FB, 0x4369E96A, 0x346ED9FC, 0xAD678846, 0xDA60B8D0, 0x44042D73, 0x33031DE5, 0xAA0A4C5F, 0xDD0D7CC9, 0x5005713C, 0x270241AA, 0xBE0B1010, 0xC90C2086, 0x5768B525, 0x206F85B3, 0xB966D409, 0xCE61E49F, 0x5EDEF90E, 0x29D9C998, 0xB0D09822, 0xC7D7A8B4, 0x59B33D17, 0x2EB40D81, 0xB7BD5C3B, 0xC0BA6CAD, 0xEDB88320, 0x9ABFB3B6, 0x03B6E20C, 0x74B1D29A, 0xEAD54739, 0x9DD277AF, 0x04DB2615, 0x73DC1683, 0xE3630B12, 0x94643B84, 0x0D6D6A3E, 0x7A6A5AA8, 0xE40ECF0B, 0x9309FF9D, 0x0A00AE27, 0x7D079EB1, 0xF00F9344, 0x8708A3D2, 0x1E01F268, 0x6906C2FE, 0xF762575D, 0x806567CB, 0x196C3671, 0x6E6B06E7, 0xFED41B76, 0x89D32BE0, 0x10DA7A5A, 0x67DD4ACC, 0xF9B9DF6F, 0x8EBEEFF9, 0x17B7BE43, 0x60B08ED5, 0xD6D6A3E8, 0xA1D1937E, 0x38D8C2C4, 0x4FDFF252, 0xD1BB67F1, 0xA6BC5767, 0x3FB506DD, 0x48B2364B, 0xD80D2BDA, 0xAF0A1B4C, 0x36034AF6, 0x41047A60, 0xDF60EFC3, 0xA867DF55, 0x316E8EEF, 0x4669BE79, 0xCB61B38C, 0xBC66831A, 0x256FD2A0, 0x5268E236, 0xCC0C7795, 0xBB0B4703, 0x220216B9, 0x5505262F, 0xC5BA3BBE, 0xB2BD0B28, 0x2BB45A92, 0x5CB36A04, 0xC2D7FFA7, 0xB5D0CF31, 0x2CD99E8B, 0x5BDEAE1D, 0x9B64C2B0, 0xEC63F226, 0x756AA39C, 0x026D930A, 0x9C0906A9, 0xEB0E363F, 0x72076785, 0x05005713, 0x95BF4A82, 0xE2B87A14, 0x7BB12BAE, 0x0CB61B38, 0x92D28E9B, 0xE5D5BE0D, 0x7CDCEFB7, 0x0BDBDF21, 0x86D3D2D4, 0xF1D4E242, 0x68DDB3F8, 0x1FDA836E, 0x81BE16CD, 0xF6B9265B, 0x6FB077E1, 0x18B74777, 0x88085AE6, 0xFF0F6A70, 0x66063BCA, 0x11010B5C, 0x8F659EFF, 0xF862AE69, 0x616BFFD3, 0x166CCF45, 0xA00AE278, 0xD70DD2EE, 0x4E048354, 0x3903B3C2, 0xA7672661, 0xD06016F7, 0x4969474D, 0x3E6E77DB, 0xAED16A4A, 0xD9D65ADC, 0x40DF0B66, 0x37D83BF0, 0xA9BCAE53, 0xDEBB9EC5, 0x47B2CF7F, 0x30B5FFE9, 0xBDBDF21C, 0xCABAC28A, 0x53B39330, 0x24B4A3A6, 0xBAD03605, 0xCDD70693, 0x54DE5729, 0x23D967BF, 0xB3667A2E, 0xC4614AB8, 0x5D681B02, 0x2A6F2B94, 0xB40BBE37, 0xC30C8EA1, 0x5A05DF1B, 0x2D02EF8D];

/**
 * CRC32 hash method, Fast and enough versitility for our usage
 *
 * @ignore
 * @api private
 */
var crc32 =  function(string, start, end) {
  var crc = 0
  var x = 0;
  var y = 0;
  crc = crc ^ (-1);

  for(var i = start, iTop = end; i < iTop;i++) {
  	y = (crc ^ string[i]) & 0xFF;
    x = table[y];
  	crc = (crc >>> 8) ^ x;
  }

  return crc ^ (-1);
}

/**
 * Deserialize stream data as BSON documents.
 *
 * Options
 *  - **evalFunctions** {Boolean, default:false}, evaluate functions in the BSON document scoped to the object deserialized.
 *  - **cacheFunctions** {Boolean, default:false}, cache evaluated functions for reuse.
 *  - **cacheFunctionsCrc32** {Boolean, default:false}, use a crc32 code for caching, otherwise use the string of the function.
 *  - **promoteLongs** {Boolean, default:true}, when deserializing a Long will fit it into a Number if it's smaller than 53 bits
 *
 * @param {Buffer} data the buffer containing the serialized set of BSON documents.
 * @param {Number} startIndex the start index in the data Buffer where the deserialization is to start.
 * @param {Number} numberOfDocuments number of documents to deserialize.
 * @param {Array} documents an array where to store the deserialized documents.
 * @param {Number} docStartIndex the index in the documents array from where to start inserting documents.
 * @param {Object} [options] additional options used for the deserialization.
 * @return {Number} returns the next index in the buffer after deserialization **x** numbers of documents.
 * @api public
 */
BSON.deserializeStream = function(data, startIndex, numberOfDocuments, documents, docStartIndex, options) {
  // if(numberOfDocuments !== documents.length) throw new Error("Number of expected results back is less than the number of documents");
  options = options != null ? options : {};
  var index = startIndex;
  // Loop over all documents
  for(var i = 0; i < numberOfDocuments; i++) {
    // Find size of the document
    var size = data[index] | data[index + 1] << 8 | data[index + 2] << 16 | data[index + 3] << 24;
    // Update options with index
    options['index'] = index;
    // Parse the document at this point
    documents[docStartIndex + i] = BSON.deserialize(data, options);
    // Adjust index by the document size
    index = index + size;
  }

  // Return object containing end index of parsing and list of documents
  return index;
}

/**
 * Ensure eval is isolated.
 *
 * @ignore
 * @api private
 */
var isolateEvalWithHash = function(functionCache, hash, functionString, object) {
  // Contains the value we are going to set
  var value = null;

  // Check for cache hit, eval if missing and return cached function
  if(functionCache[hash] == null) {
    eval("value = " + functionString);
    functionCache[hash] = value;
  }
  // Set the object
  return functionCache[hash].bind(object);
}

/**
 * Ensure eval is isolated.
 *
 * @ignore
 * @api private
 */
var isolateEval = function(functionString) {
  // Contains the value we are going to set
  var value = null;
  // Eval the function
  eval("value = " + functionString);
  return value;
}

/**
 * Convert Uint8Array to String
 *
 * @ignore
 * @api private
 */
var convertUint8ArrayToUtf8String = function(byteArray, startIndex, endIndex) {
  return BinaryParser.decode_utf8(convertArraytoUtf8BinaryString(byteArray, startIndex, endIndex));
}

var convertArraytoUtf8BinaryString = function(byteArray, startIndex, endIndex) {
  var result = "";
  for(var i = startIndex; i < endIndex; i++) {
    result = result + String.fromCharCode(byteArray[i]);
  }

  return result;
};

/**
 * Deserialize data as BSON.
 *
 * Options
 *  - **evalFunctions** {Boolean, default:false}, evaluate functions in the BSON document scoped to the object deserialized.
 *  - **cacheFunctions** {Boolean, default:false}, cache evaluated functions for reuse.
 *  - **cacheFunctionsCrc32** {Boolean, default:false}, use a crc32 code for caching, otherwise use the string of the function.
 *  - **promoteLongs** {Boolean, default:true}, when deserializing a Long will fit it into a Number if it's smaller than 53 bits
 *
 * @param {Buffer} buffer the buffer containing the serialized set of BSON documents.
 * @param {Object} [options] additional options used for the deserialization.
 * @param {Boolean} [isArray] ignore used for recursive parsing.
 * @return {Object} returns the deserialized Javascript Object.
 * @api public
 */
BSON.deserialize = function(buffer, options, isArray) {
  // Options
  options = options == null ? {} : options;
  var evalFunctions = options['evalFunctions'] == null ? false : options['evalFunctions'];
  var cacheFunctions = options['cacheFunctions'] == null ? false : options['cacheFunctions'];
  var cacheFunctionsCrc32 = options['cacheFunctionsCrc32'] == null ? false : options['cacheFunctionsCrc32'];
  var promoteLongs = options['promoteLongs'] || true;

  // Validate that we have at least 4 bytes of buffer
  if(buffer.length < 5) throw new Error("corrupt bson message < 5 bytes long");

  // Set up index
  var index = typeof options['index'] == 'number' ? options['index'] : 0;
  // Reads in a C style string
  var readCStyleString = function() {
    // Get the start search index
    var i = index;
    // Locate the end of the c string
    while(buffer[i] !== 0x00) { i++ }
    // Grab utf8 encoded string
    var string = supportsBuffer && Buffer.isBuffer(buffer) ? buffer.toString('utf8', index, i) : convertUint8ArrayToUtf8String(buffer, index, i);
    // Update index position
    index = i + 1;
    // Return string
    return string;
  }

  // Create holding object
  var object = isArray ? [] : {};

  // Read the document size
  var size = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;

  // Ensure buffer is valid size
  if(size < 5 || size > buffer.length) throw new Error("corrupt bson message");

  // While we have more left data left keep parsing
  while(true) {
    // Read the type
    var elementType = buffer[index++];
    // If we get a zero it's the last byte, exit
    if(elementType == 0) break;
    // Read the name of the field
    var name = readCStyleString();
    // Switch on the type
    switch(elementType) {
      case BSON.BSON_DATA_OID:
        var string = supportsBuffer && Buffer.isBuffer(buffer) ? buffer.toString('binary', index, index + 12) : convertArraytoUtf8BinaryString(buffer, index, index + 12);
        // Decode the oid
        object[name] = new ObjectID(string);
        // Update index
        index = index + 12;
        break;
      case BSON.BSON_DATA_STRING:
        // Read the content of the field
        var stringSize = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;
        // Add string to object
        object[name] = supportsBuffer && Buffer.isBuffer(buffer) ? buffer.toString('utf8', index, index + stringSize - 1) : convertUint8ArrayToUtf8String(buffer, index, index + stringSize - 1);
        // Update parse index position
        index = index + stringSize;
        break;
      case BSON.BSON_DATA_INT:
        // Decode the 32bit value
        object[name] = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;
        break;
      case BSON.BSON_DATA_NUMBER:
        // Decode the double value
        object[name] = readIEEE754(buffer, index, 'little', 52, 8);
        // Update the index
        index = index + 8;
        break;
      case BSON.BSON_DATA_DATE:
        // Unpack the low and high bits
        var lowBits = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;
        var highBits = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;
        // Set date object
        object[name] = new Date(new Long(lowBits, highBits).toNumber());
        break;
      case BSON.BSON_DATA_BOOLEAN:
        // Parse the boolean value
        object[name] = buffer[index++] == 1;
        break;
      case BSON.BSON_DATA_NULL:
        // Parse the boolean value
        object[name] = null;
        break;
      case BSON.BSON_DATA_BINARY:
        // Decode the size of the binary blob
        var binarySize = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;
        // Decode the subtype
        var subType = buffer[index++];
        // Decode as raw Buffer object if options specifies it
        if(buffer['slice'] != null) {
          // If we have subtype 2 skip the 4 bytes for the size
          if(subType == Binary.SUBTYPE_BYTE_ARRAY) {
            binarySize = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;
          }
          // Slice the data
          object[name] = new Binary(buffer.slice(index, index + binarySize), subType);
        } else {
          var _buffer = typeof Uint8Array != 'undefined' ? new Uint8Array(new ArrayBuffer(binarySize)) : new Array(binarySize);
          // If we have subtype 2 skip the 4 bytes for the size
          if(subType == Binary.SUBTYPE_BYTE_ARRAY) {
            binarySize = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;
          }
          // Copy the data
          for(var i = 0; i < binarySize; i++) {
            _buffer[i] = buffer[index + i];
          }
          // Create the binary object
          object[name] = new Binary(_buffer, subType);
        }
        // Update the index
        index = index + binarySize;
        break;
      case BSON.BSON_DATA_ARRAY:
        options['index'] = index;
        // Decode the size of the array document
        var objectSize = buffer[index] | buffer[index + 1] << 8 | buffer[index + 2] << 16 | buffer[index + 3] << 24;
        // Set the array to the object
        object[name] = BSON.deserialize(buffer, options, true);
        // Adjust the index
        index = index + objectSize;
        break;
      case BSON.BSON_DATA_OBJECT:
        options['index'] = index;
        // Decode the size of the object document
        var objectSize = buffer[index] | buffer[index + 1] << 8 | buffer[index + 2] << 16 | buffer[index + 3] << 24;
        // Set the array to the object
        object[name] = BSON.deserialize(buffer, options, false);
        // Adjust the index
        index = index + objectSize;
        break;
      case BSON.BSON_DATA_REGEXP:
        // Create the regexp
        var source = readCStyleString();
        var regExpOptions = readCStyleString();
        // For each option add the corresponding one for javascript
        var optionsArray = new Array(regExpOptions.length);

        // Parse options
        for(var i = 0; i < regExpOptions.length; i++) {
          switch(regExpOptions[i]) {
            case 'm':
              optionsArray[i] = 'm';
              break;
            case 's':
              optionsArray[i] = 'g';
              break;
            case 'i':
              optionsArray[i] = 'i';
              break;
          }
        }

        object[name] = new RegExp(source, optionsArray.join(''));
        break;
      case BSON.BSON_DATA_LONG:
        // Unpack the low and high bits
        var lowBits = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;
        var highBits = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;
        // Create long object
        var long = new Long(lowBits, highBits); 
        // Promote the long if possible
        if(promoteLongs) {
          object[name] = long.lessThanOrEqual(JS_INT_MAX_LONG) && long.greaterThanOrEqual(JS_INT_MIN_LONG) ? long.toNumber() : long;
        } else {
          object[name] = long;
        }
        break;
      case BSON.BSON_DATA_SYMBOL:
        // Read the content of the field
        var stringSize = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;
        // Add string to object
        object[name] = new Symbol(buffer.toString('utf8', index, index + stringSize - 1));
        // Update parse index position
        index = index + stringSize;
        break;
      case BSON.BSON_DATA_TIMESTAMP:
        // Unpack the low and high bits
        var lowBits = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;
        var highBits = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;
        // Set the object
        object[name] = new Timestamp(lowBits, highBits);
        break;
      case BSON.BSON_DATA_MIN_KEY:
        // Parse the object
        object[name] = new MinKey();
        break;
      case BSON.BSON_DATA_MAX_KEY:
        // Parse the object
        object[name] = new MaxKey();
        break;
      case BSON.BSON_DATA_CODE:
        // Read the content of the field
        var stringSize = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;
        // Function string
        var functionString = supportsBuffer && Buffer.isBuffer(buffer) ? buffer.toString('utf8', index, index + stringSize - 1) : convertUint8ArrayToUtf8String(buffer, index, index + stringSize - 1);

        // If we are evaluating the functions
        if(evalFunctions) {
          // Contains the value we are going to set
          var value = null;
          // If we have cache enabled let's look for the md5 of the function in the cache
          if(cacheFunctions) {
            var hash = cacheFunctionsCrc32 ? crc32(functionString) : functionString;
            // Got to do this to avoid V8 deoptimizing the call due to finding eval
            object[name] = isolateEvalWithHash(functionCache, hash, functionString, object);
          } else {
            // Set directly
            object[name] = isolateEval(functionString);
          }
        } else {
          object[name]  = new Code(functionString, {});
        }

        // Update parse index position
        index = index + stringSize;
        break;
      case BSON.BSON_DATA_CODE_W_SCOPE:
        // Read the content of the field
        var totalSize = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;
        var stringSize = buffer[index++] | buffer[index++] << 8 | buffer[index++] << 16 | buffer[index++] << 24;
        // Javascript function
        var functionString = supportsBuffer && Buffer.isBuffer(buffer) ? buffer.toString('utf8', index, index + stringSize - 1) : convertUint8ArrayToUtf8String(buffer, index, index + stringSize - 1);
        // Update parse index position
        index = index + stringSize;
        // Parse the element
        options['index'] = index;
        // Decode the size of the object document
        var objectSize = buffer[index] | buffer[index + 1] << 8 | buffer[index + 2] << 16 | buffer[index + 3] << 24;
        // Decode the scope object
        var scopeObject = BSON.deserialize(buffer, options, false);
        // Adjust the index
        index = index + objectSize;

        // If we are evaluating the functions
        if(evalFunctions) {
          // Contains the value we are going to set
          var value = null;
          // If we have cache enabled let's look for the md5 of the function in the cache
          if(cacheFunctions) {
            var hash = cacheFunctionsCrc32 ? crc32(functionString) : functionString;
            // Got to do this to avoid V8 deoptimizing the call due to finding eval
            object[name] = isolateEvalWithHash(functionCache, hash, functionString, object);
          } else {
            // Set directly
            object[name] = isolateEval(functionString);
          }

          // Set the scope on the object
          object[name].scope = scopeObject;
        } else {
          object[name]  = new Code(functionString, scopeObject);
        }

        // Add string to object
        break;
    }
  }

  // Check if we have a db ref object
  if(object['$id'] != null) object = new DBRef(object['$ref'], object['$id'], object['$db']);

  // Return the final objects
  return object;
}

/**
 * Check if key name is valid.
 *
 * @ignore
 * @api private
 */
BSON.checkKey = function checkKey (key, dollarsAndDotsOk) {
  if (!key.length) return;
  // Check if we have a legal key for the object
  if (!!~key.indexOf("\x00")) {
    // The BSON spec doesn't allow keys with null bytes because keys are
    // null-terminated.
    throw Error("key " + key + " must not contain null bytes");
  }
  if (!dollarsAndDotsOk) {
    if('$' == key[0]) {
      throw Error("key " + key + " must not start with '$'");
    } else if (!!~key.indexOf('.')) {
      throw Error("key " + key + " must not contain '.'");
    }
  }
};

/**
 * Deserialize data as BSON.
 *
 * Options
 *  - **evalFunctions** {Boolean, default:false}, evaluate functions in the BSON document scoped to the object deserialized.
 *  - **cacheFunctions** {Boolean, default:false}, cache evaluated functions for reuse.
 *  - **cacheFunctionsCrc32** {Boolean, default:false}, use a crc32 code for caching, otherwise use the string of the function.
 *
 * @param {Buffer} buffer the buffer containing the serialized set of BSON documents.
 * @param {Object} [options] additional options used for the deserialization.
 * @param {Boolean} [isArray] ignore used for recursive parsing.
 * @return {Object} returns the deserialized Javascript Object.
 * @api public
 */
BSON.prototype.deserialize = function(data, options) {
  return BSON.deserialize(data, options);
}

/**
 * Deserialize stream data as BSON documents.
 *
 * Options
 *  - **evalFunctions** {Boolean, default:false}, evaluate functions in the BSON document scoped to the object deserialized.
 *  - **cacheFunctions** {Boolean, default:false}, cache evaluated functions for reuse.
 *  - **cacheFunctionsCrc32** {Boolean, default:false}, use a crc32 code for caching, otherwise use the string of the function.
 *
 * @param {Buffer} data the buffer containing the serialized set of BSON documents.
 * @param {Number} startIndex the start index in the data Buffer where the deserialization is to start.
 * @param {Number} numberOfDocuments number of documents to deserialize.
 * @param {Array} documents an array where to store the deserialized documents.
 * @param {Number} docStartIndex the index in the documents array from where to start inserting documents.
 * @param {Object} [options] additional options used for the deserialization.
 * @return {Number} returns the next index in the buffer after deserialization **x** numbers of documents.
 * @api public
 */
BSON.prototype.deserializeStream = function(data, startIndex, numberOfDocuments, documents, docStartIndex, options) {
  return BSON.deserializeStream(data, startIndex, numberOfDocuments, documents, docStartIndex, options);
}

/**
 * Serialize a Javascript object.
 *
 * @param {Object} object the Javascript object to serialize.
 * @param {Boolean} checkKeys the serializer will check if keys are valid.
 * @param {Boolean} asBuffer return the serialized object as a Buffer object **(ignore)**.
 * @param {Boolean} serializeFunctions serialize the javascript functions **(default:false)**.
 * @return {Buffer} returns the Buffer object containing the serialized object.
 * @api public
 */
BSON.prototype.serialize = function(object, checkKeys, asBuffer, serializeFunctions) {
  return BSON.serialize(object, checkKeys, asBuffer, serializeFunctions);
}

/**
 * Calculate the bson size for a passed in Javascript object.
 *
 * @param {Object} object the Javascript object to calculate the BSON byte size for.
 * @param {Boolean} [serializeFunctions] serialize all functions in the object **(default:false)**.
 * @return {Number} returns the number of bytes the BSON object will take up.
 * @api public
 */
BSON.prototype.calculateObjectSize = function(object, serializeFunctions) {
  return BSON.calculateObjectSize(object, serializeFunctions);
}

/**
 * Serialize a Javascript object using a predefined Buffer and index into the buffer, useful when pre-allocating the space for serialization.
 *
 * @param {Object} object the Javascript object to serialize.
 * @param {Boolean} checkKeys the serializer will check if keys are valid.
 * @param {Buffer} buffer the Buffer you pre-allocated to store the serialized BSON object.
 * @param {Number} index the index in the buffer where we wish to start serializing into.
 * @param {Boolean} serializeFunctions serialize the javascript functions **(default:false)**.
 * @return {Number} returns the new write index in the Buffer.
 * @api public
 */
BSON.prototype.serializeWithBufferAndIndex = function(object, checkKeys, buffer, startIndex, serializeFunctions) {
  return BSON.serializeWithBufferAndIndex(object, checkKeys, buffer, startIndex, serializeFunctions);
}

/**
 * @ignore
 * @api private
 */
exports.Code = Code;
exports.Symbol = Symbol;
exports.BSON = BSON;
exports.DBRef = DBRef;
exports.Binary = Binary;
exports.ObjectID = ObjectID;
exports.Long = Long;
exports.Timestamp = Timestamp;
exports.Double = Double;
exports.MinKey = MinKey;
exports.MaxKey = MaxKey;

}, 



'code': function(module, exports, global, require, undefined){
  /**
 * A class representation of the BSON Code type.
 *
 * @class Represents the BSON Code type.
 * @param {String|Function} code a string or function.
 * @param {Object} [scope] an optional scope for the function.
 * @return {Code}
 */
function Code(code, scope) {
  if(!(this instanceof Code)) return new Code(code, scope);
  
  this._bsontype = 'Code';
  this.code = code;
  this.scope = scope == null ? {} : scope;
};

/**
 * @ignore
 * @api private
 */
Code.prototype.toJSON = function() {
  return {scope:this.scope, code:this.code};
}

exports.Code = Code;
}, 



'db_ref': function(module, exports, global, require, undefined){
  /**
 * A class representation of the BSON DBRef type.
 *
 * @class Represents the BSON DBRef type.
 * @param {String} namespace the collection name.
 * @param {ObjectID} oid the reference ObjectID.
 * @param {String} [db] optional db name, if omitted the reference is local to the current db.
 * @return {DBRef}
 */
function DBRef(namespace, oid, db) {
  if(!(this instanceof DBRef)) return new DBRef(namespace, oid, db);
  
  this._bsontype = 'DBRef';
  this.namespace = namespace;
  this.oid = oid;
  this.db = db;
};

/**
 * @ignore
 * @api private
 */
DBRef.prototype.toJSON = function() {
  return {
    '$ref':this.namespace,
    '$id':this.oid,
    '$db':this.db == null ? '' : this.db
  };
}

exports.DBRef = DBRef;
}, 



'double': function(module, exports, global, require, undefined){
  /**
 * A class representation of the BSON Double type.
 *
 * @class Represents the BSON Double type.
 * @param {Number} value the number we want to represent as a double.
 * @return {Double}
 */
function Double(value) {
  if(!(this instanceof Double)) return new Double(value);
  
  this._bsontype = 'Double';
  this.value = value;
}

/**
 * Access the number value.
 *
 * @return {Number} returns the wrapped double number.
 * @api public
 */
Double.prototype.valueOf = function() {
  return this.value;
};

/**
 * @ignore
 * @api private
 */
Double.prototype.toJSON = function() {
  return this.value;
}

exports.Double = Double;
}, 



'float_parser': function(module, exports, global, require, undefined){
  // Copyright (c) 2008, Fair Oaks Labs, Inc.
// All rights reserved.
// 
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions are met:
// 
//  * Redistributions of source code must retain the above copyright notice,
//    this list of conditions and the following disclaimer.
// 
//  * Redistributions in binary form must reproduce the above copyright notice,
//    this list of conditions and the following disclaimer in the documentation
//    and/or other materials provided with the distribution.
// 
//  * Neither the name of Fair Oaks Labs, Inc. nor the names of its contributors
//    may be used to endorse or promote products derived from this software
//    without specific prior written permission.
// 
// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
// ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
// POSSIBILITY OF SUCH DAMAGE.
//
//
// Modifications to writeIEEE754 to support negative zeroes made by Brian White

var readIEEE754 = function(buffer, offset, endian, mLen, nBytes) {
  var e, m,
      bBE = (endian === 'big'),
      eLen = nBytes * 8 - mLen - 1,
      eMax = (1 << eLen) - 1,
      eBias = eMax >> 1,
      nBits = -7,
      i = bBE ? 0 : (nBytes - 1),
      d = bBE ? 1 : -1,
      s = buffer[offset + i];

  i += d;

  e = s & ((1 << (-nBits)) - 1);
  s >>= (-nBits);
  nBits += eLen;
  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8);

  m = e & ((1 << (-nBits)) - 1);
  e >>= (-nBits);
  nBits += mLen;
  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8);

  if (e === 0) {
    e = 1 - eBias;
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity);
  } else {
    m = m + Math.pow(2, mLen);
    e = e - eBias;
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
};

var writeIEEE754 = function(buffer, value, offset, endian, mLen, nBytes) {
  var e, m, c,
      bBE = (endian === 'big'),
      eLen = nBytes * 8 - mLen - 1,
      eMax = (1 << eLen) - 1,
      eBias = eMax >> 1,
      rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0),
      i = bBE ? (nBytes-1) : 0,
      d = bBE ? -1 : 1,
      s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0;

  value = Math.abs(value);

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0;
    e = eMax;
  } else {
    e = Math.floor(Math.log(value) / Math.LN2);
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--;
      c *= 2;
    }
    if (e+eBias >= 1) {
      value += rt / c;
    } else {
      value += rt * Math.pow(2, 1 - eBias);
    }
    if (value * c >= 2) {
      e++;
      c /= 2;
    }

    if (e + eBias >= eMax) {
      m = 0;
      e = eMax;
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen);
      e = e + eBias;
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
      e = 0;
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8);

  e = (e << mLen) | m;
  eLen += mLen;
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8);

  buffer[offset + i - d] |= s * 128;
};

exports.readIEEE754 = readIEEE754;
exports.writeIEEE754 = writeIEEE754;
}, 



'index': function(module, exports, global, require, undefined){
  try {
  exports.BSONPure = require('./bson');
  exports.BSONNative = require('../../ext');
} catch(err) {
  // do nothing
}

[ './binary_parser'
  , './binary'
  , './code'
  , './db_ref'
  , './double'
  , './max_key'
  , './min_key'
  , './objectid'
  , './symbol'
  , './timestamp'
  , './long'].forEach(function (path) {
  	var module = require('./' + path);
  	for (var i in module) {
  		exports[i] = module[i];
    }
});

// Exports all the classes for the NATIVE JS BSON Parser
exports.native = function() {
  var classes = {};
  // Map all the classes
  [ './binary_parser'
    , './binary'
    , './code'
    , './db_ref'
    , './double'
    , './max_key'
    , './min_key'
    , './objectid'
    , './symbol'
    , './timestamp'
    , './long'
    , '../../ext'
].forEach(function (path) {
    	var module = require('./' + path);
    	for (var i in module) {
    		classes[i] = module[i];
      }
  });
  // Return classes list
  return classes;
}

// Exports all the classes for the PURE JS BSON Parser
exports.pure = function() {
  var classes = {};
  // Map all the classes
  [ './binary_parser'
    , './binary'
    , './code'
    , './db_ref'
    , './double'
    , './max_key'
    , './min_key'
    , './objectid'
    , './symbol'
    , './timestamp'
    , './long'
    , '././bson'].forEach(function (path) {
    	var module = require('./' + path);
    	for (var i in module) {
    		classes[i] = module[i];
      }
  });
  // Return classes list
  return classes;
}

}, 



'long': function(module, exports, global, require, undefined){
  // Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Copyright 2009 Google Inc. All Rights Reserved

/**
 * Defines a Long class for representing a 64-bit two's-complement
 * integer value, which faithfully simulates the behavior of a Java "Long". This
 * implementation is derived from LongLib in GWT.
 *
 * Constructs a 64-bit two's-complement integer, given its low and high 32-bit
 * values as *signed* integers.  See the from* functions below for more
 * convenient ways of constructing Longs.
 *
 * The internal representation of a Long is the two given signed, 32-bit values.
 * We use 32-bit pieces because these are the size of integers on which
 * Javascript performs bit-operations.  For operations like addition and
 * multiplication, we split each number into 16-bit pieces, which can easily be
 * multiplied within Javascript's floating-point representation without overflow
 * or change in sign.
 *
 * In the algorithms below, we frequently reduce the negative case to the
 * positive case by negating the input(s) and then post-processing the result.
 * Note that we must ALWAYS check specially whether those values are MIN_VALUE
 * (-2^63) because -MIN_VALUE == MIN_VALUE (since 2^63 cannot be represented as
 * a positive number, it overflows back into a negative).  Not handling this
 * case would often result in infinite recursion.
 *
 * @class Represents the BSON Long type.
 * @param {Number} low  the low (signed) 32 bits of the Long.
 * @param {Number} high the high (signed) 32 bits of the Long.
 */
function Long(low, high) {
  if(!(this instanceof Long)) return new Long(low, high);
  
  this._bsontype = 'Long';
  /**
   * @type {number}
   * @api private
   */
  this.low_ = low | 0;  // force into 32 signed bits.

  /**
   * @type {number}
   * @api private
   */
  this.high_ = high | 0;  // force into 32 signed bits.
};

/**
 * Return the int value.
 *
 * @return {Number} the value, assuming it is a 32-bit integer.
 * @api public
 */
Long.prototype.toInt = function() {
  return this.low_;
};

/**
 * Return the Number value.
 *
 * @return {Number} the closest floating-point representation to this value.
 * @api public
 */
Long.prototype.toNumber = function() {
  return this.high_ * Long.TWO_PWR_32_DBL_ +
         this.getLowBitsUnsigned();
};

/**
 * Return the JSON value.
 *
 * @return {String} the JSON representation.
 * @api public
 */
Long.prototype.toJSON = function() {
  return this.toString();
}

/**
 * Return the String value.
 *
 * @param {Number} [opt_radix] the radix in which the text should be written.
 * @return {String} the textual representation of this value.
 * @api public
 */
Long.prototype.toString = function(opt_radix) {
  var radix = opt_radix || 10;
  if (radix < 2 || 36 < radix) {
    throw Error('radix out of range: ' + radix);
  }

  if (this.isZero()) {
    return '0';
  }

  if (this.isNegative()) {
    if (this.equals(Long.MIN_VALUE)) {
      // We need to change the Long value before it can be negated, so we remove
      // the bottom-most digit in this base and then recurse to do the rest.
      var radixLong = Long.fromNumber(radix);
      var div = this.div(radixLong);
      var rem = div.multiply(radixLong).subtract(this);
      return div.toString(radix) + rem.toInt().toString(radix);
    } else {
      return '-' + this.negate().toString(radix);
    }
  }

  // Do several (6) digits each time through the loop, so as to
  // minimize the calls to the very expensive emulated div.
  var radixToPower = Long.fromNumber(Math.pow(radix, 6));

  var rem = this;
  var result = '';
  while (true) {
    var remDiv = rem.div(radixToPower);
    var intval = rem.subtract(remDiv.multiply(radixToPower)).toInt();
    var digits = intval.toString(radix);

    rem = remDiv;
    if (rem.isZero()) {
      return digits + result;
    } else {
      while (digits.length < 6) {
        digits = '0' + digits;
      }
      result = '' + digits + result;
    }
  }
};

/**
 * Return the high 32-bits value.
 *
 * @return {Number} the high 32-bits as a signed value.
 * @api public
 */
Long.prototype.getHighBits = function() {
  return this.high_;
};

/**
 * Return the low 32-bits value.
 *
 * @return {Number} the low 32-bits as a signed value.
 * @api public
 */
Long.prototype.getLowBits = function() {
  return this.low_;
};

/**
 * Return the low unsigned 32-bits value.
 *
 * @return {Number} the low 32-bits as an unsigned value.
 * @api public
 */
Long.prototype.getLowBitsUnsigned = function() {
  return (this.low_ >= 0) ?
      this.low_ : Long.TWO_PWR_32_DBL_ + this.low_;
};

/**
 * Returns the number of bits needed to represent the absolute value of this Long.
 *
 * @return {Number} Returns the number of bits needed to represent the absolute value of this Long.
 * @api public
 */
Long.prototype.getNumBitsAbs = function() {
  if (this.isNegative()) {
    if (this.equals(Long.MIN_VALUE)) {
      return 64;
    } else {
      return this.negate().getNumBitsAbs();
    }
  } else {
    var val = this.high_ != 0 ? this.high_ : this.low_;
    for (var bit = 31; bit > 0; bit--) {
      if ((val & (1 << bit)) != 0) {
        break;
      }
    }
    return this.high_ != 0 ? bit + 33 : bit + 1;
  }
};

/**
 * Return whether this value is zero.
 *
 * @return {Boolean} whether this value is zero.
 * @api public
 */
Long.prototype.isZero = function() {
  return this.high_ == 0 && this.low_ == 0;
};

/**
 * Return whether this value is negative.
 *
 * @return {Boolean} whether this value is negative.
 * @api public
 */
Long.prototype.isNegative = function() {
  return this.high_ < 0;
};

/**
 * Return whether this value is odd.
 *
 * @return {Boolean} whether this value is odd.
 * @api public
 */
Long.prototype.isOdd = function() {
  return (this.low_ & 1) == 1;
};

/**
 * Return whether this Long equals the other
 *
 * @param {Long} other Long to compare against.
 * @return {Boolean} whether this Long equals the other
 * @api public
 */
Long.prototype.equals = function(other) {
  return (this.high_ == other.high_) && (this.low_ == other.low_);
};

/**
 * Return whether this Long does not equal the other.
 *
 * @param {Long} other Long to compare against.
 * @return {Boolean} whether this Long does not equal the other.
 * @api public
 */
Long.prototype.notEquals = function(other) {
  return (this.high_ != other.high_) || (this.low_ != other.low_);
};

/**
 * Return whether this Long is less than the other.
 *
 * @param {Long} other Long to compare against.
 * @return {Boolean} whether this Long is less than the other.
 * @api public
 */
Long.prototype.lessThan = function(other) {
  return this.compare(other) < 0;
};

/**
 * Return whether this Long is less than or equal to the other.
 *
 * @param {Long} other Long to compare against.
 * @return {Boolean} whether this Long is less than or equal to the other.
 * @api public
 */
Long.prototype.lessThanOrEqual = function(other) {
  return this.compare(other) <= 0;
};

/**
 * Return whether this Long is greater than the other.
 *
 * @param {Long} other Long to compare against.
 * @return {Boolean} whether this Long is greater than the other.
 * @api public
 */
Long.prototype.greaterThan = function(other) {
  return this.compare(other) > 0;
};

/**
 * Return whether this Long is greater than or equal to the other.
 *
 * @param {Long} other Long to compare against.
 * @return {Boolean} whether this Long is greater than or equal to the other.
 * @api public
 */
Long.prototype.greaterThanOrEqual = function(other) {
  return this.compare(other) >= 0;
};

/**
 * Compares this Long with the given one.
 *
 * @param {Long} other Long to compare against.
 * @return {Boolean} 0 if they are the same, 1 if the this is greater, and -1 if the given one is greater.
 * @api public
 */
Long.prototype.compare = function(other) {
  if (this.equals(other)) {
    return 0;
  }

  var thisNeg = this.isNegative();
  var otherNeg = other.isNegative();
  if (thisNeg && !otherNeg) {
    return -1;
  }
  if (!thisNeg && otherNeg) {
    return 1;
  }

  // at this point, the signs are the same, so subtraction will not overflow
  if (this.subtract(other).isNegative()) {
    return -1;
  } else {
    return 1;
  }
};

/**
 * The negation of this value.
 *
 * @return {Long} the negation of this value.
 * @api public
 */
Long.prototype.negate = function() {
  if (this.equals(Long.MIN_VALUE)) {
    return Long.MIN_VALUE;
  } else {
    return this.not().add(Long.ONE);
  }
};

/**
 * Returns the sum of this and the given Long.
 *
 * @param {Long} other Long to add to this one.
 * @return {Long} the sum of this and the given Long.
 * @api public
 */
Long.prototype.add = function(other) {
  // Divide each number into 4 chunks of 16 bits, and then sum the chunks.

  var a48 = this.high_ >>> 16;
  var a32 = this.high_ & 0xFFFF;
  var a16 = this.low_ >>> 16;
  var a00 = this.low_ & 0xFFFF;

  var b48 = other.high_ >>> 16;
  var b32 = other.high_ & 0xFFFF;
  var b16 = other.low_ >>> 16;
  var b00 = other.low_ & 0xFFFF;

  var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
  c00 += a00 + b00;
  c16 += c00 >>> 16;
  c00 &= 0xFFFF;
  c16 += a16 + b16;
  c32 += c16 >>> 16;
  c16 &= 0xFFFF;
  c32 += a32 + b32;
  c48 += c32 >>> 16;
  c32 &= 0xFFFF;
  c48 += a48 + b48;
  c48 &= 0xFFFF;
  return Long.fromBits((c16 << 16) | c00, (c48 << 16) | c32);
};

/**
 * Returns the difference of this and the given Long.
 *
 * @param {Long} other Long to subtract from this.
 * @return {Long} the difference of this and the given Long.
 * @api public
 */
Long.prototype.subtract = function(other) {
  return this.add(other.negate());
};

/**
 * Returns the product of this and the given Long.
 *
 * @param {Long} other Long to multiply with this.
 * @return {Long} the product of this and the other.
 * @api public
 */
Long.prototype.multiply = function(other) {
  if (this.isZero()) {
    return Long.ZERO;
  } else if (other.isZero()) {
    return Long.ZERO;
  }

  if (this.equals(Long.MIN_VALUE)) {
    return other.isOdd() ? Long.MIN_VALUE : Long.ZERO;
  } else if (other.equals(Long.MIN_VALUE)) {
    return this.isOdd() ? Long.MIN_VALUE : Long.ZERO;
  }

  if (this.isNegative()) {
    if (other.isNegative()) {
      return this.negate().multiply(other.negate());
    } else {
      return this.negate().multiply(other).negate();
    }
  } else if (other.isNegative()) {
    return this.multiply(other.negate()).negate();
  }

  // If both Longs are small, use float multiplication
  if (this.lessThan(Long.TWO_PWR_24_) &&
      other.lessThan(Long.TWO_PWR_24_)) {
    return Long.fromNumber(this.toNumber() * other.toNumber());
  }

  // Divide each Long into 4 chunks of 16 bits, and then add up 4x4 products.
  // We can skip products that would overflow.

  var a48 = this.high_ >>> 16;
  var a32 = this.high_ & 0xFFFF;
  var a16 = this.low_ >>> 16;
  var a00 = this.low_ & 0xFFFF;

  var b48 = other.high_ >>> 16;
  var b32 = other.high_ & 0xFFFF;
  var b16 = other.low_ >>> 16;
  var b00 = other.low_ & 0xFFFF;

  var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
  c00 += a00 * b00;
  c16 += c00 >>> 16;
  c00 &= 0xFFFF;
  c16 += a16 * b00;
  c32 += c16 >>> 16;
  c16 &= 0xFFFF;
  c16 += a00 * b16;
  c32 += c16 >>> 16;
  c16 &= 0xFFFF;
  c32 += a32 * b00;
  c48 += c32 >>> 16;
  c32 &= 0xFFFF;
  c32 += a16 * b16;
  c48 += c32 >>> 16;
  c32 &= 0xFFFF;
  c32 += a00 * b32;
  c48 += c32 >>> 16;
  c32 &= 0xFFFF;
  c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;
  c48 &= 0xFFFF;
  return Long.fromBits((c16 << 16) | c00, (c48 << 16) | c32);
};

/**
 * Returns this Long divided by the given one.
 *
 * @param {Long} other Long by which to divide.
 * @return {Long} this Long divided by the given one.
 * @api public
 */
Long.prototype.div = function(other) {
  if (other.isZero()) {
    throw Error('division by zero');
  } else if (this.isZero()) {
    return Long.ZERO;
  }

  if (this.equals(Long.MIN_VALUE)) {
    if (other.equals(Long.ONE) ||
        other.equals(Long.NEG_ONE)) {
      return Long.MIN_VALUE;  // recall that -MIN_VALUE == MIN_VALUE
    } else if (other.equals(Long.MIN_VALUE)) {
      return Long.ONE;
    } else {
      // At this point, we have |other| >= 2, so |this/other| < |MIN_VALUE|.
      var halfThis = this.shiftRight(1);
      var approx = halfThis.div(other).shiftLeft(1);
      if (approx.equals(Long.ZERO)) {
        return other.isNegative() ? Long.ONE : Long.NEG_ONE;
      } else {
        var rem = this.subtract(other.multiply(approx));
        var result = approx.add(rem.div(other));
        return result;
      }
    }
  } else if (other.equals(Long.MIN_VALUE)) {
    return Long.ZERO;
  }

  if (this.isNegative()) {
    if (other.isNegative()) {
      return this.negate().div(other.negate());
    } else {
      return this.negate().div(other).negate();
    }
  } else if (other.isNegative()) {
    return this.div(other.negate()).negate();
  }

  // Repeat the following until the remainder is less than other:  find a
  // floating-point that approximates remainder / other *from below*, add this
  // into the result, and subtract it from the remainder.  It is critical that
  // the approximate value is less than or equal to the real value so that the
  // remainder never becomes negative.
  var res = Long.ZERO;
  var rem = this;
  while (rem.greaterThanOrEqual(other)) {
    // Approximate the result of division. This may be a little greater or
    // smaller than the actual value.
    var approx = Math.max(1, Math.floor(rem.toNumber() / other.toNumber()));

    // We will tweak the approximate result by changing it in the 48-th digit or
    // the smallest non-fractional digit, whichever is larger.
    var log2 = Math.ceil(Math.log(approx) / Math.LN2);
    var delta = (log2 <= 48) ? 1 : Math.pow(2, log2 - 48);

    // Decrease the approximation until it is smaller than the remainder.  Note
    // that if it is too large, the product overflows and is negative.
    var approxRes = Long.fromNumber(approx);
    var approxRem = approxRes.multiply(other);
    while (approxRem.isNegative() || approxRem.greaterThan(rem)) {
      approx -= delta;
      approxRes = Long.fromNumber(approx);
      approxRem = approxRes.multiply(other);
    }

    // We know the answer can't be zero... and actually, zero would cause
    // infinite recursion since we would make no progress.
    if (approxRes.isZero()) {
      approxRes = Long.ONE;
    }

    res = res.add(approxRes);
    rem = rem.subtract(approxRem);
  }
  return res;
};

/**
 * Returns this Long modulo the given one.
 *
 * @param {Long} other Long by which to mod.
 * @return {Long} this Long modulo the given one.
 * @api public
 */
Long.prototype.modulo = function(other) {
  return this.subtract(this.div(other).multiply(other));
};

/**
 * The bitwise-NOT of this value.
 *
 * @return {Long} the bitwise-NOT of this value.
 * @api public
 */
Long.prototype.not = function() {
  return Long.fromBits(~this.low_, ~this.high_);
};

/**
 * Returns the bitwise-AND of this Long and the given one.
 *
 * @param {Long} other the Long with which to AND.
 * @return {Long} the bitwise-AND of this and the other.
 * @api public
 */
Long.prototype.and = function(other) {
  return Long.fromBits(this.low_ & other.low_, this.high_ & other.high_);
};

/**
 * Returns the bitwise-OR of this Long and the given one.
 *
 * @param {Long} other the Long with which to OR.
 * @return {Long} the bitwise-OR of this and the other.
 * @api public
 */
Long.prototype.or = function(other) {
  return Long.fromBits(this.low_ | other.low_, this.high_ | other.high_);
};

/**
 * Returns the bitwise-XOR of this Long and the given one.
 *
 * @param {Long} other the Long with which to XOR.
 * @return {Long} the bitwise-XOR of this and the other.
 * @api public
 */
Long.prototype.xor = function(other) {
  return Long.fromBits(this.low_ ^ other.low_, this.high_ ^ other.high_);
};

/**
 * Returns this Long with bits shifted to the left by the given amount.
 *
 * @param {Number} numBits the number of bits by which to shift.
 * @return {Long} this shifted to the left by the given amount.
 * @api public
 */
Long.prototype.shiftLeft = function(numBits) {
  numBits &= 63;
  if (numBits == 0) {
    return this;
  } else {
    var low = this.low_;
    if (numBits < 32) {
      var high = this.high_;
      return Long.fromBits(
                 low << numBits,
                 (high << numBits) | (low >>> (32 - numBits)));
    } else {
      return Long.fromBits(0, low << (numBits - 32));
    }
  }
};

/**
 * Returns this Long with bits shifted to the right by the given amount.
 *
 * @param {Number} numBits the number of bits by which to shift.
 * @return {Long} this shifted to the right by the given amount.
 * @api public
 */
Long.prototype.shiftRight = function(numBits) {
  numBits &= 63;
  if (numBits == 0) {
    return this;
  } else {
    var high = this.high_;
    if (numBits < 32) {
      var low = this.low_;
      return Long.fromBits(
                 (low >>> numBits) | (high << (32 - numBits)),
                 high >> numBits);
    } else {
      return Long.fromBits(
                 high >> (numBits - 32),
                 high >= 0 ? 0 : -1);
    }
  }
};

/**
 * Returns this Long with bits shifted to the right by the given amount, with the new top bits matching the current sign bit.
 *
 * @param {Number} numBits the number of bits by which to shift.
 * @return {Long} this shifted to the right by the given amount, with zeros placed into the new leading bits.
 * @api public
 */
Long.prototype.shiftRightUnsigned = function(numBits) {
  numBits &= 63;
  if (numBits == 0) {
    return this;
  } else {
    var high = this.high_;
    if (numBits < 32) {
      var low = this.low_;
      return Long.fromBits(
                 (low >>> numBits) | (high << (32 - numBits)),
                 high >>> numBits);
    } else if (numBits == 32) {
      return Long.fromBits(high, 0);
    } else {
      return Long.fromBits(high >>> (numBits - 32), 0);
    }
  }
};

/**
 * Returns a Long representing the given (32-bit) integer value.
 *
 * @param {Number} value the 32-bit integer in question.
 * @return {Long} the corresponding Long value.
 * @api public
 */
Long.fromInt = function(value) {
  if (-128 <= value && value < 128) {
    var cachedObj = Long.INT_CACHE_[value];
    if (cachedObj) {
      return cachedObj;
    }
  }

  var obj = new Long(value | 0, value < 0 ? -1 : 0);
  if (-128 <= value && value < 128) {
    Long.INT_CACHE_[value] = obj;
  }
  return obj;
};

/**
 * Returns a Long representing the given value, provided that it is a finite number. Otherwise, zero is returned.
 *
 * @param {Number} value the number in question.
 * @return {Long} the corresponding Long value.
 * @api public
 */
Long.fromNumber = function(value) {
  if (isNaN(value) || !isFinite(value)) {
    return Long.ZERO;
  } else if (value <= -Long.TWO_PWR_63_DBL_) {
    return Long.MIN_VALUE;
  } else if (value + 1 >= Long.TWO_PWR_63_DBL_) {
    return Long.MAX_VALUE;
  } else if (value < 0) {
    return Long.fromNumber(-value).negate();
  } else {
    return new Long(
               (value % Long.TWO_PWR_32_DBL_) | 0,
               (value / Long.TWO_PWR_32_DBL_) | 0);
  }
};

/**
 * Returns a Long representing the 64-bit integer that comes by concatenating the given high and low bits. Each is assumed to use 32 bits.
 *
 * @param {Number} lowBits the low 32-bits.
 * @param {Number} highBits the high 32-bits.
 * @return {Long} the corresponding Long value.
 * @api public
 */
Long.fromBits = function(lowBits, highBits) {
  return new Long(lowBits, highBits);
};

/**
 * Returns a Long representation of the given string, written using the given radix.
 *
 * @param {String} str the textual representation of the Long.
 * @param {Number} opt_radix the radix in which the text is written.
 * @return {Long} the corresponding Long value.
 * @api public
 */
Long.fromString = function(str, opt_radix) {
  if (str.length == 0) {
    throw Error('number format error: empty string');
  }

  var radix = opt_radix || 10;
  if (radix < 2 || 36 < radix) {
    throw Error('radix out of range: ' + radix);
  }

  if (str.charAt(0) == '-') {
    return Long.fromString(str.substring(1), radix).negate();
  } else if (str.indexOf('-') >= 0) {
    throw Error('number format error: interior "-" character: ' + str);
  }

  // Do several (8) digits each time through the loop, so as to
  // minimize the calls to the very expensive emulated div.
  var radixToPower = Long.fromNumber(Math.pow(radix, 8));

  var result = Long.ZERO;
  for (var i = 0; i < str.length; i += 8) {
    var size = Math.min(8, str.length - i);
    var value = parseInt(str.substring(i, i + size), radix);
    if (size < 8) {
      var power = Long.fromNumber(Math.pow(radix, size));
      result = result.multiply(power).add(Long.fromNumber(value));
    } else {
      result = result.multiply(radixToPower);
      result = result.add(Long.fromNumber(value));
    }
  }
  return result;
};

// NOTE: Common constant values ZERO, ONE, NEG_ONE, etc. are defined below the
// from* methods on which they depend.


/**
 * A cache of the Long representations of small integer values.
 * @type {Object}
 * @api private
 */
Long.INT_CACHE_ = {};

// NOTE: the compiler should inline these constant values below and then remove
// these variables, so there should be no runtime penalty for these.

/**
 * Number used repeated below in calculations.  This must appear before the
 * first call to any from* function below.
 * @type {number}
 * @api private
 */
Long.TWO_PWR_16_DBL_ = 1 << 16;

/**
 * @type {number}
 * @api private
 */
Long.TWO_PWR_24_DBL_ = 1 << 24;

/**
 * @type {number}
 * @api private
 */
Long.TWO_PWR_32_DBL_ = Long.TWO_PWR_16_DBL_ * Long.TWO_PWR_16_DBL_;

/**
 * @type {number}
 * @api private
 */
Long.TWO_PWR_31_DBL_ = Long.TWO_PWR_32_DBL_ / 2;

/**
 * @type {number}
 * @api private
 */
Long.TWO_PWR_48_DBL_ = Long.TWO_PWR_32_DBL_ * Long.TWO_PWR_16_DBL_;

/**
 * @type {number}
 * @api private
 */
Long.TWO_PWR_64_DBL_ = Long.TWO_PWR_32_DBL_ * Long.TWO_PWR_32_DBL_;

/**
 * @type {number}
 * @api private
 */
Long.TWO_PWR_63_DBL_ = Long.TWO_PWR_64_DBL_ / 2;

/** @type {Long} */
Long.ZERO = Long.fromInt(0);

/** @type {Long} */
Long.ONE = Long.fromInt(1);

/** @type {Long} */
Long.NEG_ONE = Long.fromInt(-1);

/** @type {Long} */
Long.MAX_VALUE =
    Long.fromBits(0xFFFFFFFF | 0, 0x7FFFFFFF | 0);

/** @type {Long} */
Long.MIN_VALUE = Long.fromBits(0, 0x80000000 | 0);

/**
 * @type {Long}
 * @api private
 */
Long.TWO_PWR_24_ = Long.fromInt(1 << 24);

/**
 * Expose.
 */
exports.Long = Long;
}, 



'max_key': function(module, exports, global, require, undefined){
  /**
 * A class representation of the BSON MaxKey type.
 *
 * @class Represents the BSON MaxKey type.
 * @return {MaxKey}
 */
function MaxKey() {
  if(!(this instanceof MaxKey)) return new MaxKey();
  
  this._bsontype = 'MaxKey';  
}

exports.MaxKey = MaxKey;
}, 



'min_key': function(module, exports, global, require, undefined){
  /**
 * A class representation of the BSON MinKey type.
 *
 * @class Represents the BSON MinKey type.
 * @return {MinKey}
 */
function MinKey() {
  if(!(this instanceof MinKey)) return new MinKey();
  
  this._bsontype = 'MinKey';
}

exports.MinKey = MinKey;
}, 



'objectid': function(module, exports, global, require, undefined){
  /**
 * Module dependencies.
 */
var BinaryParser = require('./binary_parser').BinaryParser;

/**
 * Machine id.
 *
 * Create a random 3-byte value (i.e. unique for this
 * process). Other drivers use a md5 of the machine id here, but
 * that would mean an asyc call to gethostname, so we don't bother.
 */
var MACHINE_ID = parseInt(Math.random() * 0xFFFFFF, 10);

// Regular expression that checks for hex value
var checkForHexRegExp = new RegExp("^[0-9a-fA-F]{24}$");

/**
* Create a new ObjectID instance
*
* @class Represents the BSON ObjectID type
* @param {String|Number} id Can be a 24 byte hex string, 12 byte binary string or a Number.
* @return {Object} instance of ObjectID.
*/
var ObjectID = function ObjectID(id, _hex) {
  if(!(this instanceof ObjectID)) return new ObjectID(id, _hex);

  this._bsontype = 'ObjectID';
  var __id = null;

  // Throw an error if it's not a valid setup
  if(id != null && 'number' != typeof id && (id.length != 12 && id.length != 24))
    throw new Error("Argument passed in must be a single String of 12 bytes or a string of 24 hex characters");

  // Generate id based on the input
  if(id == null || typeof id == 'number') {
    // convert to 12 byte binary string
    this.id = this.generate(id);
  } else if(id != null && id.length === 12) {
    // assume 12 byte string
    this.id = id;
  } else if(checkForHexRegExp.test(id)) {
    return ObjectID.createFromHexString(id);
  } else {
    throw new Error("Value passed in is not a valid 24 character hex string");
  }

  if(ObjectID.cacheHexString) this.__id = this.toHexString();
};

// Allow usage of ObjectId aswell as ObjectID
var ObjectId = ObjectID;

/**
* Return the ObjectID id as a 24 byte hex string representation
*
* @return {String} return the 24 byte hex string representation.
* @api public
*/
ObjectID.prototype.toHexString = function() {
  if(ObjectID.cacheHexString && this.__id) return this.__id;

  var hexString = ''
    , number
    , value;

  for (var index = 0, len = this.id.length; index < len; index++) {
    value = BinaryParser.toByte(this.id[index]);
    number = value <= 15
      ? '0' + value.toString(16)
      : value.toString(16);
    hexString = hexString + number;
  }

  if(ObjectID.cacheHexString) this.__id = hexString;
  return hexString;
};

/**
* Update the ObjectID index used in generating new ObjectID's on the driver
*
* @return {Number} returns next index value.
* @api private
*/
ObjectID.prototype.get_inc = function() {
  return ObjectID.index = (ObjectID.index + 1) % 0xFFFFFF;
};

/**
* Update the ObjectID index used in generating new ObjectID's on the driver
*
* @return {Number} returns next index value.
* @api private
*/
ObjectID.prototype.getInc = function() {
  return this.get_inc();
};

/**
* Generate a 12 byte id string used in ObjectID's
*
* @param {Number} [time] optional parameter allowing to pass in a second based timestamp.
* @return {String} return the 12 byte id binary string.
* @api private
*/
ObjectID.prototype.generate = function(time) {
  if ('number' == typeof time) {
    var time4Bytes = BinaryParser.encodeInt(time, 32, true, true);
    /* for time-based ObjectID the bytes following the time will be zeroed */
    var machine3Bytes = BinaryParser.encodeInt(MACHINE_ID, 24, false);
    var pid2Bytes = BinaryParser.fromShort(typeof process === 'undefined' ? Math.floor(Math.random() * 100000) : process.pid);
    var index3Bytes = BinaryParser.encodeInt(this.get_inc(), 24, false, true);
  } else {
  	var unixTime = parseInt(Date.now()/1000,10);
    var time4Bytes = BinaryParser.encodeInt(unixTime, 32, true, true);
    var machine3Bytes = BinaryParser.encodeInt(MACHINE_ID, 24, false);
    var pid2Bytes = BinaryParser.fromShort(typeof process === 'undefined' ? Math.floor(Math.random() * 100000) : process.pid);
    var index3Bytes = BinaryParser.encodeInt(this.get_inc(), 24, false, true);
  }

  return time4Bytes + machine3Bytes + pid2Bytes + index3Bytes;
};

/**
* Converts the id into a 24 byte hex string for printing
*
* @return {String} return the 24 byte hex string representation.
* @api private
*/
ObjectID.prototype.toString = function() {
  return this.toHexString();
};

/**
* Converts to a string representation of this Id.
*
* @return {String} return the 24 byte hex string representation.
* @api private
*/
ObjectID.prototype.inspect = ObjectID.prototype.toString;

/**
* Converts to its JSON representation.
*
* @return {String} return the 24 byte hex string representation.
* @api private
*/
ObjectID.prototype.toJSON = function() {
  return this.toHexString();
};

/**
* Compares the equality of this ObjectID with `otherID`.
*
* @param {Object} otherID ObjectID instance to compare against.
* @return {Bool} the result of comparing two ObjectID's
* @api public
*/
ObjectID.prototype.equals = function equals (otherID) {
  var id = (otherID instanceof ObjectID || otherID.toHexString)
    ? otherID.id
    : ObjectID.createFromHexString(otherID).id;

  return this.id === id;
}

/**
* Returns the generation date (accurate up to the second) that this ID was generated.
*
* @return {Date} the generation date
* @api public
*/
ObjectID.prototype.getTimestamp = function() {
  var timestamp = new Date();
  timestamp.setTime(Math.floor(BinaryParser.decodeInt(this.id.substring(0,4), 32, true, true)) * 1000);
  return timestamp;
}

/**
* @ignore
* @api private
*/
ObjectID.index = parseInt(Math.random() * 0xFFFFFF, 10);

ObjectID.createPk = function createPk () {
  return new ObjectID();
};

/**
* Creates an ObjectID from a second based number, with the rest of the ObjectID zeroed out. Used for comparisons or sorting the ObjectID.
*
* @param {Number} time an integer number representing a number of seconds.
* @return {ObjectID} return the created ObjectID
* @api public
*/
ObjectID.createFromTime = function createFromTime (time) {
  var id = BinaryParser.encodeInt(time, 32, true, true) +
           BinaryParser.encodeInt(0, 64, true, true);
  return new ObjectID(id);
};

/**
* Creates an ObjectID from a hex string representation of an ObjectID.
*
* @param {String} hexString create a ObjectID from a passed in 24 byte hexstring.
* @return {ObjectID} return the created ObjectID
* @api public
*/
ObjectID.createFromHexString = function createFromHexString (hexString) {
  // Throw an error if it's not a valid setup
  if(typeof hexString === 'undefined' || hexString != null && hexString.length != 24)
    throw new Error("Argument passed in must be a single String of 12 bytes or a string of 24 hex characters");

  var len = hexString.length;

  if(len > 12*2) {
    throw new Error('Id cannot be longer than 12 bytes');
  }

  var result = ''
    , string
    , number;

  for (var index = 0; index < len; index += 2) {
    string = hexString.substr(index, 2);
    number = parseInt(string, 16);
    result += BinaryParser.fromByte(number);
  }

  return new ObjectID(result, hexString);
};

/**
* @ignore
*/
Object.defineProperty(ObjectID.prototype, "generationTime", {
   enumerable: true
 , get: function () {
     return Math.floor(BinaryParser.decodeInt(this.id.substring(0,4), 32, true, true));
   }
 , set: function (value) {
     var value = BinaryParser.encodeInt(value, 32, true, true);
     this.id = value + this.id.substr(4);
     // delete this.__id;
     this.toHexString();
   }
});

/**
 * Expose.
 */
exports.ObjectID = ObjectID;
exports.ObjectId = ObjectID;

}, 



'symbol': function(module, exports, global, require, undefined){
  /**
 * A class representation of the BSON Symbol type.
 *
 * @class Represents the BSON Symbol type.
 * @param {String} value the string representing the symbol.
 * @return {Symbol}
 */
function Symbol(value) {
  if(!(this instanceof Symbol)) return new Symbol(value);
  this._bsontype = 'Symbol';
  this.value = value;
}

/**
 * Access the wrapped string value.
 *
 * @return {String} returns the wrapped string.
 * @api public
 */
Symbol.prototype.valueOf = function() {
  return this.value;
};

/**
 * @ignore
 * @api private
 */
Symbol.prototype.toString = function() {
  return this.value;
}

/**
 * @ignore
 * @api private
 */
Symbol.prototype.inspect = function() {
  return this.value;
}

/**
 * @ignore
 * @api private
 */
Symbol.prototype.toJSON = function() {
  return this.value;
}

exports.Symbol = Symbol;
}, 



'timestamp': function(module, exports, global, require, undefined){
  // Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Copyright 2009 Google Inc. All Rights Reserved

/**
 * Defines a Timestamp class for representing a 64-bit two's-complement
 * integer value, which faithfully simulates the behavior of a Java "Timestamp". This
 * implementation is derived from TimestampLib in GWT.
 *
 * Constructs a 64-bit two's-complement integer, given its low and high 32-bit
 * values as *signed* integers.  See the from* functions below for more
 * convenient ways of constructing Timestamps.
 *
 * The internal representation of a Timestamp is the two given signed, 32-bit values.
 * We use 32-bit pieces because these are the size of integers on which
 * Javascript performs bit-operations.  For operations like addition and
 * multiplication, we split each number into 16-bit pieces, which can easily be
 * multiplied within Javascript's floating-point representation without overflow
 * or change in sign.
 *
 * In the algorithms below, we frequently reduce the negative case to the
 * positive case by negating the input(s) and then post-processing the result.
 * Note that we must ALWAYS check specially whether those values are MIN_VALUE
 * (-2^63) because -MIN_VALUE == MIN_VALUE (since 2^63 cannot be represented as
 * a positive number, it overflows back into a negative).  Not handling this
 * case would often result in infinite recursion.
 *
 * @class Represents the BSON Timestamp type.
 * @param {Number} low  the low (signed) 32 bits of the Timestamp.
 * @param {Number} high the high (signed) 32 bits of the Timestamp.
 */
function Timestamp(low, high) {
  if(!(this instanceof Timestamp)) return new Timestamp(low, high);
  this._bsontype = 'Timestamp';
  /**
   * @type {number}
   * @api private
   */
  this.low_ = low | 0;  // force into 32 signed bits.

  /**
   * @type {number}
   * @api private
   */
  this.high_ = high | 0;  // force into 32 signed bits.
};

/**
 * Return the int value.
 *
 * @return {Number} the value, assuming it is a 32-bit integer.
 * @api public
 */
Timestamp.prototype.toInt = function() {
  return this.low_;
};

/**
 * Return the Number value.
 *
 * @return {Number} the closest floating-point representation to this value.
 * @api public
 */
Timestamp.prototype.toNumber = function() {
  return this.high_ * Timestamp.TWO_PWR_32_DBL_ +
         this.getLowBitsUnsigned();
};

/**
 * Return the JSON value.
 *
 * @return {String} the JSON representation.
 * @api public
 */
Timestamp.prototype.toJSON = function() {
  return this.toString();
}

/**
 * Return the String value.
 *
 * @param {Number} [opt_radix] the radix in which the text should be written.
 * @return {String} the textual representation of this value.
 * @api public
 */
Timestamp.prototype.toString = function(opt_radix) {
  var radix = opt_radix || 10;
  if (radix < 2 || 36 < radix) {
    throw Error('radix out of range: ' + radix);
  }

  if (this.isZero()) {
    return '0';
  }

  if (this.isNegative()) {
    if (this.equals(Timestamp.MIN_VALUE)) {
      // We need to change the Timestamp value before it can be negated, so we remove
      // the bottom-most digit in this base and then recurse to do the rest.
      var radixTimestamp = Timestamp.fromNumber(radix);
      var div = this.div(radixTimestamp);
      var rem = div.multiply(radixTimestamp).subtract(this);
      return div.toString(radix) + rem.toInt().toString(radix);
    } else {
      return '-' + this.negate().toString(radix);
    }
  }

  // Do several (6) digits each time through the loop, so as to
  // minimize the calls to the very expensive emulated div.
  var radixToPower = Timestamp.fromNumber(Math.pow(radix, 6));

  var rem = this;
  var result = '';
  while (true) {
    var remDiv = rem.div(radixToPower);
    var intval = rem.subtract(remDiv.multiply(radixToPower)).toInt();
    var digits = intval.toString(radix);

    rem = remDiv;
    if (rem.isZero()) {
      return digits + result;
    } else {
      while (digits.length < 6) {
        digits = '0' + digits;
      }
      result = '' + digits + result;
    }
  }
};

/**
 * Return the high 32-bits value.
 *
 * @return {Number} the high 32-bits as a signed value.
 * @api public
 */
Timestamp.prototype.getHighBits = function() {
  return this.high_;
};

/**
 * Return the low 32-bits value.
 *
 * @return {Number} the low 32-bits as a signed value.
 * @api public
 */
Timestamp.prototype.getLowBits = function() {
  return this.low_;
};

/**
 * Return the low unsigned 32-bits value.
 *
 * @return {Number} the low 32-bits as an unsigned value.
 * @api public
 */
Timestamp.prototype.getLowBitsUnsigned = function() {
  return (this.low_ >= 0) ?
      this.low_ : Timestamp.TWO_PWR_32_DBL_ + this.low_;
};

/**
 * Returns the number of bits needed to represent the absolute value of this Timestamp.
 *
 * @return {Number} Returns the number of bits needed to represent the absolute value of this Timestamp.
 * @api public
 */
Timestamp.prototype.getNumBitsAbs = function() {
  if (this.isNegative()) {
    if (this.equals(Timestamp.MIN_VALUE)) {
      return 64;
    } else {
      return this.negate().getNumBitsAbs();
    }
  } else {
    var val = this.high_ != 0 ? this.high_ : this.low_;
    for (var bit = 31; bit > 0; bit--) {
      if ((val & (1 << bit)) != 0) {
        break;
      }
    }
    return this.high_ != 0 ? bit + 33 : bit + 1;
  }
};

/**
 * Return whether this value is zero.
 *
 * @return {Boolean} whether this value is zero.
 * @api public
 */
Timestamp.prototype.isZero = function() {
  return this.high_ == 0 && this.low_ == 0;
};

/**
 * Return whether this value is negative.
 *
 * @return {Boolean} whether this value is negative.
 * @api public
 */
Timestamp.prototype.isNegative = function() {
  return this.high_ < 0;
};

/**
 * Return whether this value is odd.
 *
 * @return {Boolean} whether this value is odd.
 * @api public
 */
Timestamp.prototype.isOdd = function() {
  return (this.low_ & 1) == 1;
};

/**
 * Return whether this Timestamp equals the other
 *
 * @param {Timestamp} other Timestamp to compare against.
 * @return {Boolean} whether this Timestamp equals the other
 * @api public
 */
Timestamp.prototype.equals = function(other) {
  return (this.high_ == other.high_) && (this.low_ == other.low_);
};

/**
 * Return whether this Timestamp does not equal the other.
 *
 * @param {Timestamp} other Timestamp to compare against.
 * @return {Boolean} whether this Timestamp does not equal the other.
 * @api public
 */
Timestamp.prototype.notEquals = function(other) {
  return (this.high_ != other.high_) || (this.low_ != other.low_);
};

/**
 * Return whether this Timestamp is less than the other.
 *
 * @param {Timestamp} other Timestamp to compare against.
 * @return {Boolean} whether this Timestamp is less than the other.
 * @api public
 */
Timestamp.prototype.lessThan = function(other) {
  return this.compare(other) < 0;
};

/**
 * Return whether this Timestamp is less than or equal to the other.
 *
 * @param {Timestamp} other Timestamp to compare against.
 * @return {Boolean} whether this Timestamp is less than or equal to the other.
 * @api public
 */
Timestamp.prototype.lessThanOrEqual = function(other) {
  return this.compare(other) <= 0;
};

/**
 * Return whether this Timestamp is greater than the other.
 *
 * @param {Timestamp} other Timestamp to compare against.
 * @return {Boolean} whether this Timestamp is greater than the other.
 * @api public
 */
Timestamp.prototype.greaterThan = function(other) {
  return this.compare(other) > 0;
};

/**
 * Return whether this Timestamp is greater than or equal to the other.
 *
 * @param {Timestamp} other Timestamp to compare against.
 * @return {Boolean} whether this Timestamp is greater than or equal to the other.
 * @api public
 */
Timestamp.prototype.greaterThanOrEqual = function(other) {
  return this.compare(other) >= 0;
};

/**
 * Compares this Timestamp with the given one.
 *
 * @param {Timestamp} other Timestamp to compare against.
 * @return {Boolean} 0 if they are the same, 1 if the this is greater, and -1 if the given one is greater.
 * @api public
 */
Timestamp.prototype.compare = function(other) {
  if (this.equals(other)) {
    return 0;
  }

  var thisNeg = this.isNegative();
  var otherNeg = other.isNegative();
  if (thisNeg && !otherNeg) {
    return -1;
  }
  if (!thisNeg && otherNeg) {
    return 1;
  }

  // at this point, the signs are the same, so subtraction will not overflow
  if (this.subtract(other).isNegative()) {
    return -1;
  } else {
    return 1;
  }
};

/**
 * The negation of this value.
 *
 * @return {Timestamp} the negation of this value.
 * @api public
 */
Timestamp.prototype.negate = function() {
  if (this.equals(Timestamp.MIN_VALUE)) {
    return Timestamp.MIN_VALUE;
  } else {
    return this.not().add(Timestamp.ONE);
  }
};

/**
 * Returns the sum of this and the given Timestamp.
 *
 * @param {Timestamp} other Timestamp to add to this one.
 * @return {Timestamp} the sum of this and the given Timestamp.
 * @api public
 */
Timestamp.prototype.add = function(other) {
  // Divide each number into 4 chunks of 16 bits, and then sum the chunks.

  var a48 = this.high_ >>> 16;
  var a32 = this.high_ & 0xFFFF;
  var a16 = this.low_ >>> 16;
  var a00 = this.low_ & 0xFFFF;

  var b48 = other.high_ >>> 16;
  var b32 = other.high_ & 0xFFFF;
  var b16 = other.low_ >>> 16;
  var b00 = other.low_ & 0xFFFF;

  var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
  c00 += a00 + b00;
  c16 += c00 >>> 16;
  c00 &= 0xFFFF;
  c16 += a16 + b16;
  c32 += c16 >>> 16;
  c16 &= 0xFFFF;
  c32 += a32 + b32;
  c48 += c32 >>> 16;
  c32 &= 0xFFFF;
  c48 += a48 + b48;
  c48 &= 0xFFFF;
  return Timestamp.fromBits((c16 << 16) | c00, (c48 << 16) | c32);
};

/**
 * Returns the difference of this and the given Timestamp.
 *
 * @param {Timestamp} other Timestamp to subtract from this.
 * @return {Timestamp} the difference of this and the given Timestamp.
 * @api public
 */
Timestamp.prototype.subtract = function(other) {
  return this.add(other.negate());
};

/**
 * Returns the product of this and the given Timestamp.
 *
 * @param {Timestamp} other Timestamp to multiply with this.
 * @return {Timestamp} the product of this and the other.
 * @api public
 */
Timestamp.prototype.multiply = function(other) {
  if (this.isZero()) {
    return Timestamp.ZERO;
  } else if (other.isZero()) {
    return Timestamp.ZERO;
  }

  if (this.equals(Timestamp.MIN_VALUE)) {
    return other.isOdd() ? Timestamp.MIN_VALUE : Timestamp.ZERO;
  } else if (other.equals(Timestamp.MIN_VALUE)) {
    return this.isOdd() ? Timestamp.MIN_VALUE : Timestamp.ZERO;
  }

  if (this.isNegative()) {
    if (other.isNegative()) {
      return this.negate().multiply(other.negate());
    } else {
      return this.negate().multiply(other).negate();
    }
  } else if (other.isNegative()) {
    return this.multiply(other.negate()).negate();
  }

  // If both Timestamps are small, use float multiplication
  if (this.lessThan(Timestamp.TWO_PWR_24_) &&
      other.lessThan(Timestamp.TWO_PWR_24_)) {
    return Timestamp.fromNumber(this.toNumber() * other.toNumber());
  }

  // Divide each Timestamp into 4 chunks of 16 bits, and then add up 4x4 products.
  // We can skip products that would overflow.

  var a48 = this.high_ >>> 16;
  var a32 = this.high_ & 0xFFFF;
  var a16 = this.low_ >>> 16;
  var a00 = this.low_ & 0xFFFF;

  var b48 = other.high_ >>> 16;
  var b32 = other.high_ & 0xFFFF;
  var b16 = other.low_ >>> 16;
  var b00 = other.low_ & 0xFFFF;

  var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
  c00 += a00 * b00;
  c16 += c00 >>> 16;
  c00 &= 0xFFFF;
  c16 += a16 * b00;
  c32 += c16 >>> 16;
  c16 &= 0xFFFF;
  c16 += a00 * b16;
  c32 += c16 >>> 16;
  c16 &= 0xFFFF;
  c32 += a32 * b00;
  c48 += c32 >>> 16;
  c32 &= 0xFFFF;
  c32 += a16 * b16;
  c48 += c32 >>> 16;
  c32 &= 0xFFFF;
  c32 += a00 * b32;
  c48 += c32 >>> 16;
  c32 &= 0xFFFF;
  c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;
  c48 &= 0xFFFF;
  return Timestamp.fromBits((c16 << 16) | c00, (c48 << 16) | c32);
};

/**
 * Returns this Timestamp divided by the given one.
 *
 * @param {Timestamp} other Timestamp by which to divide.
 * @return {Timestamp} this Timestamp divided by the given one.
 * @api public
 */
Timestamp.prototype.div = function(other) {
  if (other.isZero()) {
    throw Error('division by zero');
  } else if (this.isZero()) {
    return Timestamp.ZERO;
  }

  if (this.equals(Timestamp.MIN_VALUE)) {
    if (other.equals(Timestamp.ONE) ||
        other.equals(Timestamp.NEG_ONE)) {
      return Timestamp.MIN_VALUE;  // recall that -MIN_VALUE == MIN_VALUE
    } else if (other.equals(Timestamp.MIN_VALUE)) {
      return Timestamp.ONE;
    } else {
      // At this point, we have |other| >= 2, so |this/other| < |MIN_VALUE|.
      var halfThis = this.shiftRight(1);
      var approx = halfThis.div(other).shiftLeft(1);
      if (approx.equals(Timestamp.ZERO)) {
        return other.isNegative() ? Timestamp.ONE : Timestamp.NEG_ONE;
      } else {
        var rem = this.subtract(other.multiply(approx));
        var result = approx.add(rem.div(other));
        return result;
      }
    }
  } else if (other.equals(Timestamp.MIN_VALUE)) {
    return Timestamp.ZERO;
  }

  if (this.isNegative()) {
    if (other.isNegative()) {
      return this.negate().div(other.negate());
    } else {
      return this.negate().div(other).negate();
    }
  } else if (other.isNegative()) {
    return this.div(other.negate()).negate();
  }

  // Repeat the following until the remainder is less than other:  find a
  // floating-point that approximates remainder / other *from below*, add this
  // into the result, and subtract it from the remainder.  It is critical that
  // the approximate value is less than or equal to the real value so that the
  // remainder never becomes negative.
  var res = Timestamp.ZERO;
  var rem = this;
  while (rem.greaterThanOrEqual(other)) {
    // Approximate the result of division. This may be a little greater or
    // smaller than the actual value.
    var approx = Math.max(1, Math.floor(rem.toNumber() / other.toNumber()));

    // We will tweak the approximate result by changing it in the 48-th digit or
    // the smallest non-fractional digit, whichever is larger.
    var log2 = Math.ceil(Math.log(approx) / Math.LN2);
    var delta = (log2 <= 48) ? 1 : Math.pow(2, log2 - 48);

    // Decrease the approximation until it is smaller than the remainder.  Note
    // that if it is too large, the product overflows and is negative.
    var approxRes = Timestamp.fromNumber(approx);
    var approxRem = approxRes.multiply(other);
    while (approxRem.isNegative() || approxRem.greaterThan(rem)) {
      approx -= delta;
      approxRes = Timestamp.fromNumber(approx);
      approxRem = approxRes.multiply(other);
    }

    // We know the answer can't be zero... and actually, zero would cause
    // infinite recursion since we would make no progress.
    if (approxRes.isZero()) {
      approxRes = Timestamp.ONE;
    }

    res = res.add(approxRes);
    rem = rem.subtract(approxRem);
  }
  return res;
};

/**
 * Returns this Timestamp modulo the given one.
 *
 * @param {Timestamp} other Timestamp by which to mod.
 * @return {Timestamp} this Timestamp modulo the given one.
 * @api public
 */
Timestamp.prototype.modulo = function(other) {
  return this.subtract(this.div(other).multiply(other));
};

/**
 * The bitwise-NOT of this value.
 *
 * @return {Timestamp} the bitwise-NOT of this value.
 * @api public
 */
Timestamp.prototype.not = function() {
  return Timestamp.fromBits(~this.low_, ~this.high_);
};

/**
 * Returns the bitwise-AND of this Timestamp and the given one.
 *
 * @param {Timestamp} other the Timestamp with which to AND.
 * @return {Timestamp} the bitwise-AND of this and the other.
 * @api public
 */
Timestamp.prototype.and = function(other) {
  return Timestamp.fromBits(this.low_ & other.low_, this.high_ & other.high_);
};

/**
 * Returns the bitwise-OR of this Timestamp and the given one.
 *
 * @param {Timestamp} other the Timestamp with which to OR.
 * @return {Timestamp} the bitwise-OR of this and the other.
 * @api public
 */
Timestamp.prototype.or = function(other) {
  return Timestamp.fromBits(this.low_ | other.low_, this.high_ | other.high_);
};

/**
 * Returns the bitwise-XOR of this Timestamp and the given one.
 *
 * @param {Timestamp} other the Timestamp with which to XOR.
 * @return {Timestamp} the bitwise-XOR of this and the other.
 * @api public
 */
Timestamp.prototype.xor = function(other) {
  return Timestamp.fromBits(this.low_ ^ other.low_, this.high_ ^ other.high_);
};

/**
 * Returns this Timestamp with bits shifted to the left by the given amount.
 *
 * @param {Number} numBits the number of bits by which to shift.
 * @return {Timestamp} this shifted to the left by the given amount.
 * @api public
 */
Timestamp.prototype.shiftLeft = function(numBits) {
  numBits &= 63;
  if (numBits == 0) {
    return this;
  } else {
    var low = this.low_;
    if (numBits < 32) {
      var high = this.high_;
      return Timestamp.fromBits(
                 low << numBits,
                 (high << numBits) | (low >>> (32 - numBits)));
    } else {
      return Timestamp.fromBits(0, low << (numBits - 32));
    }
  }
};

/**
 * Returns this Timestamp with bits shifted to the right by the given amount.
 *
 * @param {Number} numBits the number of bits by which to shift.
 * @return {Timestamp} this shifted to the right by the given amount.
 * @api public
 */
Timestamp.prototype.shiftRight = function(numBits) {
  numBits &= 63;
  if (numBits == 0) {
    return this;
  } else {
    var high = this.high_;
    if (numBits < 32) {
      var low = this.low_;
      return Timestamp.fromBits(
                 (low >>> numBits) | (high << (32 - numBits)),
                 high >> numBits);
    } else {
      return Timestamp.fromBits(
                 high >> (numBits - 32),
                 high >= 0 ? 0 : -1);
    }
  }
};

/**
 * Returns this Timestamp with bits shifted to the right by the given amount, with the new top bits matching the current sign bit.
 *
 * @param {Number} numBits the number of bits by which to shift.
 * @return {Timestamp} this shifted to the right by the given amount, with zeros placed into the new leading bits.
 * @api public
 */
Timestamp.prototype.shiftRightUnsigned = function(numBits) {
  numBits &= 63;
  if (numBits == 0) {
    return this;
  } else {
    var high = this.high_;
    if (numBits < 32) {
      var low = this.low_;
      return Timestamp.fromBits(
                 (low >>> numBits) | (high << (32 - numBits)),
                 high >>> numBits);
    } else if (numBits == 32) {
      return Timestamp.fromBits(high, 0);
    } else {
      return Timestamp.fromBits(high >>> (numBits - 32), 0);
    }
  }
};

/**
 * Returns a Timestamp representing the given (32-bit) integer value.
 *
 * @param {Number} value the 32-bit integer in question.
 * @return {Timestamp} the corresponding Timestamp value.
 * @api public
 */
Timestamp.fromInt = function(value) {
  if (-128 <= value && value < 128) {
    var cachedObj = Timestamp.INT_CACHE_[value];
    if (cachedObj) {
      return cachedObj;
    }
  }

  var obj = new Timestamp(value | 0, value < 0 ? -1 : 0);
  if (-128 <= value && value < 128) {
    Timestamp.INT_CACHE_[value] = obj;
  }
  return obj;
};

/**
 * Returns a Timestamp representing the given value, provided that it is a finite number. Otherwise, zero is returned.
 *
 * @param {Number} value the number in question.
 * @return {Timestamp} the corresponding Timestamp value.
 * @api public
 */
Timestamp.fromNumber = function(value) {
  if (isNaN(value) || !isFinite(value)) {
    return Timestamp.ZERO;
  } else if (value <= -Timestamp.TWO_PWR_63_DBL_) {
    return Timestamp.MIN_VALUE;
  } else if (value + 1 >= Timestamp.TWO_PWR_63_DBL_) {
    return Timestamp.MAX_VALUE;
  } else if (value < 0) {
    return Timestamp.fromNumber(-value).negate();
  } else {
    return new Timestamp(
               (value % Timestamp.TWO_PWR_32_DBL_) | 0,
               (value / Timestamp.TWO_PWR_32_DBL_) | 0);
  }
};

/**
 * Returns a Timestamp representing the 64-bit integer that comes by concatenating the given high and low bits. Each is assumed to use 32 bits.
 *
 * @param {Number} lowBits the low 32-bits.
 * @param {Number} highBits the high 32-bits.
 * @return {Timestamp} the corresponding Timestamp value.
 * @api public
 */
Timestamp.fromBits = function(lowBits, highBits) {
  return new Timestamp(lowBits, highBits);
};

/**
 * Returns a Timestamp representation of the given string, written using the given radix.
 *
 * @param {String} str the textual representation of the Timestamp.
 * @param {Number} opt_radix the radix in which the text is written.
 * @return {Timestamp} the corresponding Timestamp value.
 * @api public
 */
Timestamp.fromString = function(str, opt_radix) {
  if (str.length == 0) {
    throw Error('number format error: empty string');
  }

  var radix = opt_radix || 10;
  if (radix < 2 || 36 < radix) {
    throw Error('radix out of range: ' + radix);
  }

  if (str.charAt(0) == '-') {
    return Timestamp.fromString(str.substring(1), radix).negate();
  } else if (str.indexOf('-') >= 0) {
    throw Error('number format error: interior "-" character: ' + str);
  }

  // Do several (8) digits each time through the loop, so as to
  // minimize the calls to the very expensive emulated div.
  var radixToPower = Timestamp.fromNumber(Math.pow(radix, 8));

  var result = Timestamp.ZERO;
  for (var i = 0; i < str.length; i += 8) {
    var size = Math.min(8, str.length - i);
    var value = parseInt(str.substring(i, i + size), radix);
    if (size < 8) {
      var power = Timestamp.fromNumber(Math.pow(radix, size));
      result = result.multiply(power).add(Timestamp.fromNumber(value));
    } else {
      result = result.multiply(radixToPower);
      result = result.add(Timestamp.fromNumber(value));
    }
  }
  return result;
};

// NOTE: Common constant values ZERO, ONE, NEG_ONE, etc. are defined below the
// from* methods on which they depend.


/**
 * A cache of the Timestamp representations of small integer values.
 * @type {Object}
 * @api private
 */
Timestamp.INT_CACHE_ = {};

// NOTE: the compiler should inline these constant values below and then remove
// these variables, so there should be no runtime penalty for these.

/**
 * Number used repeated below in calculations.  This must appear before the
 * first call to any from* function below.
 * @type {number}
 * @api private
 */
Timestamp.TWO_PWR_16_DBL_ = 1 << 16;

/**
 * @type {number}
 * @api private
 */
Timestamp.TWO_PWR_24_DBL_ = 1 << 24;

/**
 * @type {number}
 * @api private
 */
Timestamp.TWO_PWR_32_DBL_ = Timestamp.TWO_PWR_16_DBL_ * Timestamp.TWO_PWR_16_DBL_;

/**
 * @type {number}
 * @api private
 */
Timestamp.TWO_PWR_31_DBL_ = Timestamp.TWO_PWR_32_DBL_ / 2;

/**
 * @type {number}
 * @api private
 */
Timestamp.TWO_PWR_48_DBL_ = Timestamp.TWO_PWR_32_DBL_ * Timestamp.TWO_PWR_16_DBL_;

/**
 * @type {number}
 * @api private
 */
Timestamp.TWO_PWR_64_DBL_ = Timestamp.TWO_PWR_32_DBL_ * Timestamp.TWO_PWR_32_DBL_;

/**
 * @type {number}
 * @api private
 */
Timestamp.TWO_PWR_63_DBL_ = Timestamp.TWO_PWR_64_DBL_ / 2;

/** @type {Timestamp} */
Timestamp.ZERO = Timestamp.fromInt(0);

/** @type {Timestamp} */
Timestamp.ONE = Timestamp.fromInt(1);

/** @type {Timestamp} */
Timestamp.NEG_ONE = Timestamp.fromInt(-1);

/** @type {Timestamp} */
Timestamp.MAX_VALUE =
    Timestamp.fromBits(0xFFFFFFFF | 0, 0x7FFFFFFF | 0);

/** @type {Timestamp} */
Timestamp.MIN_VALUE = Timestamp.fromBits(0, 0x80000000 | 0);

/**
 * @type {Timestamp}
 * @api private
 */
Timestamp.TWO_PWR_24_ = Timestamp.fromInt(1 << 24);

/**
 * Expose.
 */
exports.Timestamp = Timestamp;
}, 

 });


if(typeof module != 'undefined' && module.exports ){
  module.exports = bson;

  if( !module.parent ){
    bson();
  }
}

if(typeof window != 'undefined' && typeof require == 'undefined'){
  window.require = bson.require;
}
// Utilities to manage cookies


function setCookie(c_name,value,exdays)
{
    var exdate=new Date();
    exdate.setDate(exdate.getDate() + exdays);
    var c_value=escape(value) + ((exdays==null) ? "" : "; expires="+exdate.toUTCString());
    document.cookie=c_name + "=" + c_value;
}

function getCookie(c_name)
{
    var i,x,y,ARRcookies=document.cookie.split(";");
    for (i=0;i<ARRcookies.length;i++)
    {
      x=ARRcookies[i].substr(0,ARRcookies[i].indexOf("="));
      y=ARRcookies[i].substr(ARRcookies[i].indexOf("=")+1);
      x=x.replace(/^\s+|\s+$/g,"");
      if (x==c_name)
        {
        return unescape(y);
        }
      }
}

//var objectId = new ObjectId(0, 0, 0, 0x00ffffff);
//      var objectIdString = objectId.toString();


/*
*
* Copyright (c) 2011-2014- Justin Dearing (zippy1981@gmail.com)
* Dual licensed under the MIT (http://www.opensource.org/licenses/mit-license.php)
* and GPL (http://www.opensource.org/licenses/gpl-license.php) version 2 licenses.
* This software is not distributed under version 3 or later of the GPL.
*
* Version 1.0.2
*
*/

if (!document) var document = { cookie: '' }; // fix crashes on node

/**
 * Javascript class that mimics how WCF serializes a object of type MongoDB.Bson.ObjectId
 * and converts between that format and the standard 24 character representation.
*/
var ObjectId = (function () {
    var increment = Math.floor(Math.random() * (16777216));
    var pid = Math.floor(Math.random() * (65536));
    var machine = Math.floor(Math.random() * (16777216));

    var setMachineCookie = function() {
        var cookieList = document.cookie.split('; ');
        for (var i in cookieList) {
            var cookie = cookieList[i].split('=');
            var cookieMachineId = parseInt(cookie[1], 10);
            if (cookie[0] == 'mongoMachineId' && cookieMachineId && cookieMachineId >= 0 && cookieMachineId <= 16777215) {
                machine = cookieMachineId;
                break;
            }
        }
        document.cookie = 'mongoMachineId=' + machine + ';expires=Tue, 19 Jan 2038 05:00:00 GMT;path=/';
    };
    if (typeof (localStorage) != 'undefined') {
        try {
            var mongoMachineId = parseInt(localStorage['mongoMachineId']);
            if (mongoMachineId >= 0 && mongoMachineId <= 16777215) {
                machine = Math.floor(localStorage['mongoMachineId']);
            }
            // Just always stick the value in.
            localStorage['mongoMachineId'] = machine;
        } catch (e) {
            setMachineCookie();
        }
    }
    else {
        setMachineCookie();
    }

    function ObjId() {
        if (!(this instanceof ObjectId)) {
            return new ObjectId(arguments[0], arguments[1], arguments[2], arguments[3]).toString();
        }

        if (typeof (arguments[0]) == 'object') {
            this.timestamp = arguments[0].timestamp;
            this.machine = arguments[0].machine;
            this.pid = arguments[0].pid;
            this.increment = arguments[0].increment;
        }
        else if (typeof (arguments[0]) == 'string' && arguments[0].length == 24) {
            this.timestamp = Number('0x' + arguments[0].substr(0, 8)),
            this.machine = Number('0x' + arguments[0].substr(8, 6)),
            this.pid = Number('0x' + arguments[0].substr(14, 4)),
            this.increment = Number('0x' + arguments[0].substr(18, 6))
        }
        else if (arguments.length == 4 && arguments[0] != null) {
            this.timestamp = arguments[0];
            this.machine = arguments[1];
            this.pid = arguments[2];
            this.increment = arguments[3];
        }
        else {
            this.timestamp = Math.floor(new Date().valueOf() / 1000);
            this.machine = machine;
            this.pid = pid;
            this.increment = increment++;
            if (increment > 0xffffff) {
                increment = 0;
            }
        }
    };
    return ObjId;
})();

ObjectId.prototype.getDate = function () {
    return new Date(this.timestamp * 1000);
};

ObjectId.prototype.toArray = function () {
    var strOid = this.toString();
    var array = [];
    var i;
    for(i = 0; i < 12; i++) {
        array[i] = parseInt(strOid.slice(i*2, i*2+2), 16);
    }
    return array;
};

/**
* Turns a WCF representation of a BSON ObjectId into a 24 character string representation.
*/
ObjectId.prototype.toString = function () {
    if (this.timestamp === undefined
        || this.machine === undefined
        || this.pid === undefined
        || this.increment === undefined) {
        return 'Invalid ObjectId';
    }

    var timestamp = this.timestamp.toString(16);
    var machine = this.machine.toString(16);
    var pid = this.pid.toString(16);
    var increment = this.increment.toString(16);
    return '00000000'.substr(0, 8 - timestamp.length) + timestamp +
           '000000'.substr(0, 6 - machine.length) + machine +
           '0000'.substr(0, 4 - pid.length) + pid +
           '000000'.substr(0, 6 - increment.length) + increment;
};
// TODO: 
//    $('#slideInformation')
//  ShowViewBrowser();});
// get rid of these.

//function ComparisonSaveAnnotations() {} (used wrongly in text widget.)
//function ShowViewerEditMenu(viewer) {

// Empty
//ViewEditMenu.prototype.SessionAdvanceAjax = function() {


// All edit menus share a ViewBrowser.  Next to consider.  Share the
// presentation browser panel.
var VIEW_BROWSER;


// Other viewer is a hack for copy camera.
// parent is for the view browser.
function ViewEditMenu (viewer, otherViewer) {
    var self = this; // trick to set methods in callbacks.
    this.Viewer = viewer;
    // Other viewer is a hack for copy camera.
    this.OtherViewer = otherViewer;
    this.Tab = new Tab(viewer.GetDiv(),SA.ImagePathUrl+"Menu.jpg", "editTab");
    this.Tab.Div
        .css({'position':'absolute',
              'right':'47px',
              'bottom':'0px',
              'z-index':'200'})
        .prop('title', "View Menu");

    this.Tab.Panel.addClass("sa-view-edit-panel");

    if (VIEW_BROWSER) {
        $('<button>')
            .appendTo(this.Tab.Panel)
            .text("Load Slide")
            .addClass("sa-view-edit-button")
            .click(
                function(){
                    self.Tab.PanelOff();
                    VIEW_BROWSER.Open(self.Viewer);
                });
    }
    if (SA.Edit) {
        $('<button>')
            .appendTo(this.Tab.Panel)
            .text("Save View")
            .addClass("sa-view-edit-button")
            .click(function(){self.SaveView();});
    }
    if (SA.notesWidget) {
        $('<button>')
            .appendTo(this.Tab.Panel)
            .text("Download Image")
            .addClass("sa-view-edit-button")
            .click(function(){self.Tab.PanelOff();
                              DownloadImage(self.Viewer);});

        $('<button>')
            .appendTo(this.Tab.Panel)
            .text("Slide Info")
            .addClass("sa-view-edit-button")
            .click(function(){self.ShowSlideInformation();});

        if (typeof(TIME_LINE) != "undefined") {
            // Test for showing coverage of view histor.
            this.HistoryMenuItem = $('<button>')
                .appendTo(this.Tab.Panel)
                .text("History On")
                .addClass("sa-view-edit-button")
                .click(function(){self.ToggleHistory();});
        }
        // Hack until we have some sort of scale.
        if (this.OtherViewer) {
            this.CopyZoomMenuItem = $('<button>')
                .appendTo(this.Tab.Panel)
                .text("Copy Zoom")
                .hide()
                .addClass("sa-view-edit-button")
                .click(function(){self.CopyZoom();});
        }
    
        $('<button>').appendTo(this.Tab.Panel)
            .text("Flip Horizontal")
            .addClass("sa-view-edit-button")
            .click(function(){self.FlipHorizontal();});
        /* cutout widget dialog is broken.
        $('<button>').appendTo(this.Tab.Panel)
            .text("Download image from server")
            .addClass("sa-view-edit-button")
            .click(function(){
                self.Tab.PanelOff();
                // When the circle button is pressed, create the widget.
                if ( ! self.Viewer) { return; }
                new CutoutWidget(parent, self.Viewer);
            });
        // color threshold is also broken
        for(var plugin in window.PLUGINS) {
            var that = this;
            if(window.PLUGINS[plugin].button_text) {
                (function (plugin) {
                    // console.log("Adding menu for " + plugin);
                    $('<button>').appendTo(that.Tab.Panel)
                        .text(window.PLUGINS[plugin].button_text)
                        .addClass("sa-view-edit-button")
                        .click(function () {
                            window.PLUGINS[plugin].Init();
                        });
                })(plugin);
            }
        }
        */

        // I need some indication that the behavior id different in edit mode.
        // If the user is authorized, the new bounds are automatically saved.
        if (SA.Edit) {
            $('<button>').appendTo(this.Tab.Panel)
                .text("Save Overview Bounds")
                .addClass("sa-view-edit-button")
                .click(function(){self.SetViewBounds();});
        } else {
            $('<button>').appendTo(this.Tab.Panel)
                .text("Set Overview Bounds")
                .addClass("sa-view-edit-button")
                .click(function(){self.SetViewBounds();});
        }
    }
}

ViewEditMenu.prototype.SetVisibility = function(flag) {
    if (flag) {
        this.Tab.show();
    } else {
        this.Tab.hide();
    }
}

ViewEditMenu.prototype.DetectTissueSections = function() {
    initHagfish();
    findHagFishSections(2, 0.0002, 0.01);
}


ViewEditMenu.prototype.ToggleHistory = function() {
    this.Tab.PanelOff();

    this.Viewer.HistoryFlag = ! this.Viewer.HitoryFlag;
    if (this.Viewer.HistoryFlag) {
        this.HistoryMenuItem.text("History Off")
    } else {
        this.HistoryMenuItem.text("History On")
    }
    eventuallyRender();
}


// Record the viewer into the current note and save into the database.
ViewEditMenu.prototype.SaveView = function() {
    this.Tab.PanelOff();
    if (SA.notesWidget) SA.notesWidget.SaveCallback();
}

ViewEditMenu.prototype.GetViewerBounds = function (viewer) {
    var cam = viewer.GetCamera();
    var fp = cam.GetFocalPoint(); 
    var halfWidth = cam.GetWidth()/2;
    var halfHeight = cam.GetHeight()/2;
    return [fp[0]-halfWidth, fp[0]+halfWidth, fp[1]-halfHeight, fp[1]+halfHeight];
}

// Add bounds to view to overide image bounds.
ViewEditMenu.prototype.SetViewBounds = function() {
    this.Tab.PanelOff();
    var bounds = this.GetViewerBounds(this.Viewer);
    var note = SA.DualDisplay.GetNote();
    // Which view record?
    var viewerRecord = note.ViewerRecords[this.Viewer.RecordIndex];

    viewerRecord.OverviewBounds = bounds;
    // Set the image bounds so the new bounds are used immediately.
    viewerRecord.Image.bounds = viewerRecord.OverviewBounds;
    this.Viewer.OverView.Camera.SetFocalPoint( [(bounds[0]+bounds[1])/2,
                                                (bounds[2]+bounds[3])/2]);
    this.Viewer.OverView.Camera.SetHeight(bounds[3]-bounds[2]);
    this.Viewer.OverView.Camera.ComputeMatrix();
    eventuallyRender();

    // Save automatically if user has permission.
    if (SA.Edit) {
        // I cannot do this because it first sets the viewer record and bounds are lost.
        //SA.notesWidget.SaveCallback();
        // Lets try just setting this one note.
        var noteObj = JSON.stringify(note.Serialize(true));
        var d = new Date();
        $.ajax({
            type: "post",
            url: "webgl-viewer/saveviewnotes",
            data: {"note" : noteObj,
                   "date" : d.getTime()},
            success: function(data,status) {},
            error: function() { saDebug( "AJAX - error() : saveviewnotes (bounds)" ); },
        });
    }
}

// Add bounds to view to overide image bounds.
ViewEditMenu.prototype.SetImageBounds = function() {
    this.Tab.PanelOff();

    var viewer = this.Viewer;
    var imageDb = viewer.GetCache().Image.database;
    var imageId = viewer.GetCache().Image._id;
    var bounds = this.GetViewerBounds(viewer);

    // Set the image bounds so the new bounds are used immediately.
    viewer.GetCache().Image.bounds = bounds;
    viewer.OverView.Camera.SetFocalPoint( [(bounds[0]+bounds[1])/2,
                                           (bounds[2]+bounds[3])/2]);
    viewer.OverView.Camera.SetHeight(bounds[3]-bounds[2]);
    viewer.OverView.Camera.ComputeMatrix();
    eventuallyRender();

    var data = JSON.stringify(bounds);
    $.ajax({
        type: "post",
        url: "webgl-viewer/set-image-bounds",
        data: {"img" : imageId,
               "imgdb"  : imageDb,
               "bds" : JSON.stringify(bounds)},
        success: function(data,status) {},
        error: function() {
            saDebug( "AJAX - error() : saveusernote 1" );
        },
    });
}


//==============================================================================
// Create and manage the menu to edit dual views.


// hack: Find the other viewer to copy.
ViewEditMenu.prototype.CopyZoom = function() {
    this.Tab.PanelOff();

    var cam = this.Viewer.GetCamera();
    var copyCam;
    var copyCam = this.OtherViewer.GetCamera();
    
    this.Viewer.AnimateCamera(cam.GetFocalPoint(), cam.Roll, copyCam.Height);
}

ViewEditMenu.prototype.ShowSlideInformation = function() {
    this.Tab.PanelOff();
    
    imageObj = this.Viewer.MainView.Section.Caches[0].Image;

    $('#slideInformation')
        .html("File Name: " + imageObj.filename
              + "<br>Dimensions: " + imageObj.dimensions[0] + ", "
              + imageObj.dimensions[1]
              + "<br>Levels: " + imageObj.levels)
        .show();
}


// Mirror image
ViewEditMenu.prototype.FlipHorizontal = function() {
    this.Tab.PanelOff();
    // When the circle button is pressed, create the widget.
    if ( ! this.Viewer) { return; }

    var cam = this.Viewer.GetCamera();
    this.Viewer.ToggleMirror();
    this.Viewer.SetCamera(cam.GetFocalPoint(), cam.GetRotation()+180.0, cam.Height);
    RecordState();
}


// Stuff that should be moved to some other file.

// Make the download dialog / function a module.
var DownloadImage = (function () {

    // Dialogs require an object when accept is pressed.
    var DOWNLOAD_WIDGET = undefined;
    var VIEWER;

    function DownloadImage(viewer) {
        // Use a global so apply callback can get the viewer.
        VIEWER = viewer;

        if ( ! DOWNLOAD_WIDGET) {
            InitializeDialogs();
        }

        // Setup default dimensions.
        var viewport = viewer.GetViewport();
        var d = DOWNLOAD_WIDGET.DimensionDialog;
        d.PxWidthInput.val(viewport[2]);
        d.PxHeightInput.val(viewport[3]);
        var pixelsPerInch = parseInt(d.SizeResInput.val());
        d.SizeWidthInput.val((viewport[2]/pixelsPerInch).toFixed(2));
        d.SizeHeightInput.val((viewport[3]/pixelsPerInch).toFixed(2));
        d.AspectRatio = viewport[2] / viewport[3];

        // Hide or show the stack option.
        if (SA.DualDisplay.GetNote().Type == "Stack") {
            DOWNLOAD_WIDGET.DimensionDialog.StackDiv.show();
        } else {
            DOWNLOAD_WIDGET.DimensionDialog.StackDiv.hide();
        }

        DOWNLOAD_WIDGET.DimensionDialog.Show(1);
    }

    function InitializeDialogs() {

        DOWNLOAD_WIDGET = {};

        // Two dialogs.
        // Dialog to choose dimensions and initiate download.
        // A dialog to cancel the download while waiting for tiles.
        var CancelDownloadCallback = function () {
            if ( DOWNLOAD_WIDGET.Viewer) {
                // We are in the middle of rendering.
                // This method was called by the cancel dialog.
                DOWNLOAD_WIDGET.Viewer.CancelLargeImage();
                DOWNLOAD_WIDGET.Viewer = undefined;
                // The dialog hides itself.
            }
        }
        var StartDownloadCallback = function () {
            // Trigger the process to start rendering the image.
            DOWNLOAD_WIDGET.Viewer = VIEWER;
            var width = parseInt(DOWNLOAD_WIDGET.DimensionDialog.PxWidthInput.val());
            var height = parseInt(DOWNLOAD_WIDGET.DimensionDialog.PxHeightInput.val());
            var stack = DOWNLOAD_WIDGET.DimensionDialog.StackCheckbox.prop('checked');

            // Show the dialog that empowers the user to cancel while rendering.
            DOWNLOAD_WIDGET.CancelDialog.Show(1);
            // We need a finished callback to hide the cancel dialog.
            if (stack) {
                DOWNLOAD_WIDGET.CancelDialog.StackMessage.show();
            } else {
                DOWNLOAD_WIDGET.CancelDialog.StackMessage.hide();
            }
            VIEWER.SaveLargeImage("slide-atlas.png", width, height, stack,
                                  function () {
                                      // Rendering has finished.
                                      // The user can no longer cancel.
                                      DOWNLOAD_WIDGET.Viewer = undefined;
                                      DOWNLOAD_WIDGET.CancelDialog.Hide();
                                  });
        }

        
        var d = new SAM.Dialog(StartDownloadCallback);
        d.Body.css({'margin':'1em 2em',
                    // Hack no time to figure out layout with border box option.
                    'padding-bottom':'2em',
                    'padding-right':'3em'});
        DOWNLOAD_WIDGET.DimensionDialog = d;
        d.Title.text('Download Image');
        
        // Pixel Dimensions
        d.PxDiv = $('<div>')
            .appendTo(d.Body)
            .css({'border':'1px solid #555',
                  'margin': '15px',
                  'padding-left': '5px'});
        d.PxLabel =
            $('<div>')
            .appendTo(d.PxDiv)
            .text("Dimensions:")
            .css({'position': 'relative',
                  'top': '-9px',
                  'display': 'inline-block',
                  'background-color': 'white'});
        
        d.PxWidthDiv =
            $('<div>')
            .appendTo(d.PxDiv)
            .css({'display':'table-row'});
        
        d.PxWidthLabel =
            $('<div>')
            .appendTo(d.PxWidthDiv)
            .text("Width:")
            .css({'display':'table-cell',
                  'text-align': 'right',
                  'width': '6em'});
        d.PxWidthInput =
            $('<input type="number">')
            .appendTo(d.PxWidthDiv)
            .val('1900')
            .css({'display':'table-cell',
                  'width': '100px',
                  'margin': '5px'})
            .change(function () {PxWidthChanged();});
        d.PxWidthUnits =
            $('<div>')
            .appendTo(d.PxWidthDiv)
            .text("Pixels")
            .css({'display':'table-cell',
                  'text-align': 'left'});
        
        d.PxHeightDiv =
            $('<div>')
            .appendTo(d.PxDiv)
            .css({'display':'table-row',
                  'margin': '5px'});
        d.PxHeightLabel =
            $('<div>')
            .appendTo(d.PxHeightDiv)
            .text("Height:")
            .css({'display':'table-cell',
                  'text-align': 'right'});
        d.PxHeightInput =
            $('<input type="number">')
            .appendTo(d.PxHeightDiv)
            .val('1080')
            .css({'display':'table-cell',
                  'width': '100px',
                  'margin': '5px'})
            .change(function () {PxHeightChanged();});
        
        d.PxHeightUnits =
            $('<div>')
            .appendTo(d.PxHeightDiv)
            .text("Pixels")
            .css({'display':'table-cell',
                  'text-align': 'left'});
        
        
        // Document Size
        d.SizeDiv = $('<div>')
            .appendTo(d.Body)
            .css({'border':'1px solid #555',
                  'margin': '15px',
                  'padding-left': '5px'});
        d.SizeLabel =
            $('<div>')
            .appendTo(d.SizeDiv)
            .text("Document Size:")
            .css({'position': 'relative',
                  'top': '-9px',
                  'display': 'inline-block',
                  'background-color': 'white'});
        
        d.SizeWidthDiv =
            $('<div>')
            .appendTo(d.SizeDiv)
            .css({'display':'table-row',
                  'margin': '5px'});
        d.SizeWidthLabel =
            $('<div>')
            .appendTo(d.SizeWidthDiv)
            .text("Width:")
            .css({'display':'table-cell',
                  'text-align': 'right',
                  'width': '6em'});
        d.SizeWidthInput =
            $('<input type="number">')
            .appendTo(d.SizeWidthDiv)
            .val('1900')
            .css({'display':'table-cell',
                  'width': '100px',
                  'margin': '5px'})
            .change(function () {SizeWidthChanged();});
        
        d.SizeWidthUnits =
            $('<div>')
            .appendTo(d.SizeWidthDiv)
            .text("Inches")
            .css({'display':'table-cell',
                  'text-align': 'left'});
        
        d.SizeHeightDiv =
            $('<div>')
            .appendTo(d.SizeDiv)
            .css({'display':'table-row',
                  'margin': '5px'});
        d.SizeHeightLabel =
            $('<div>')
            .appendTo(d.SizeHeightDiv)
            .text("Height:")
            .css({'display':'table-cell',
                  'text-align': 'right'});
        d.SizeHeightInput =
            $('<input type="number">')
            .appendTo(d.SizeHeightDiv)
            .val('1900')
            .css({'display':'table-cell',
                  'width': '100px',
                  'margin': '5px'})
            .change(function () {SizeHeightChanged();});
        
        d.SizeHeightUnits =
            $('<div>')
            .appendTo(d.SizeHeightDiv)
            .text("Inches")
            .css({'display':'table-cell',
                  'text-align': 'left'});
        
        d.SizeResDiv =
            $('<div>')
            .appendTo(d.SizeDiv)
            .css({'display':'table-row',
                  'margin': '5px'});
        d.SizeResLabel =
            $('<div>')
            .appendTo(d.SizeResDiv)
            .text("Resolution:")
            .css({'display':'table-cell',
                  'text-align': 'right'});
        d.SizeResInput =
            $('<input type="number">')
            .appendTo(d.SizeResDiv)
            .val('72')
            .css({'display':'table-cell',
                  'width': '100px',
                  'margin': '5px'})
            .change(function () {ResChanged();});
        
        d.SizeResUnits =
            $('<div>')
            .appendTo(d.SizeResDiv)
            .text("Pixels/Inch")
            .css({'display':'table-cell',
                  'text-align': 'left'});
        
        
        d.ProportionsDiv = 
            $('<div>')
            .appendTo(d.Body)
            .css({'margin': '15px',
                  'padding-left': '5px'});
        d.ProportionsLabel =
            $('<div>')
            .appendTo(d.ProportionsDiv)
            .text("Constrain Proportions:")
            .css({'display':'inline'});
        d.ProportionsCheckbox =
            $('<input type="checkbox">')
            .appendTo(d.ProportionsDiv)
            .css({'display':'inline'})
            .prop('checked', true);


        d.StackDiv =
            $('<div>')
            .appendTo(d.Body)
            .css({'margin': '15px',
                  'padding-left': '5px'})
            .hide();
        d.StackLabel =
            $('<div>')
            .appendTo(d.StackDiv)
            .text("All stack sections:")
            .css({'display':'inline'});
        d.StackCheckbox =
            $('<input type="checkbox">')
            .appendTo(d.StackDiv)
            .css({'display':'inline'})
            .prop('checked', false);


        d.AspectRatio = 1.0;


        // A dialog to cancel the download before we get all the tiles
        // needed to render thie image.
        d = new SAM.Dialog(CancelDownloadCallback);
        DOWNLOAD_WIDGET.CancelDialog = d;
        d.Title.text('Processing');

        d.WaitingImage = $('<img>')
            .appendTo(d.Body)
            .attr("src", SA.ImagePathUrl+"circular.gif")
            .attr("alt", "waiting...")
            .css({'width':'40px'});

        d.StackMessage = $('<div>')
            .appendTo(d.Body)
            .text("Downloading multiple images.  Turn off browser's prompt-on-download option.")
            .hide();

        d.ApplyButton.text("Cancel");

    }

    function PxWidthChanged () {
        var d = DOWNLOAD_WIDGET.DimensionDialog;
        var pixelsPerInch = parseInt(d.SizeResInput.val());
        var width = parseInt(d.PxWidthInput.val());
        d.SizeWidthInput.val((width/pixelsPerInch).toFixed(2));
        if (d.ProportionsCheckbox.prop('checked')) {
            var height = width / d.AspectRatio;
            d.PxHeightInput.val(height.toFixed());
            d.SizeHeightInput.val((height/pixelsPerInch).toFixed(2));
        } else {
            var height = parseInt(d.PxHeightInput.val());
            d.AspectRatio = width / height;
        }
    }

    function PxHeightChanged () {
        var d = DOWNLOAD_WIDGET.DimensionDialog;
        var pixelsPerInch = parseInt(d.SizeResInput.val());
        var height = parseInt(d.PxHeightInput.val());
        d.SizeHeightInput.val((height/pixelsPerInch).toFixed(2));
        if (d.ProportionsCheckbox.prop('checked')) {
            var width = height * d.AspectRatio;
            d.PxWidthInput.val(width.toFixed());
            d.SizeWidthInput.val((width/pixelsPerInch).toFixed(2));
        } else {
            var width = parseInt(d.PxWidthInput.val());
            d.AspectRatio = width / height;
        }
    }

    function SizeWidthChanged () {
        var d = DOWNLOAD_WIDGET.DimensionDialog;
        var pixelsPerInch = parseInt(d.SizeResInput.val());
        var width = parseInt(d.SizeWidthInput.val());
        d.PxWidthInput.val((width*pixelsPerInch).toFixed());
        if (d.ProportionsCheckbox.prop('checked')) {
            var height = width / d.AspectRatio;
            d.SizeHeightInput.val(height.toFixed(2));
            d.PxHeightInput.val((height*pixelsPerInch).toFixed());
        } else {
            var height = parseInt(d.SizeHeightInput.val());
            d.AspectRatio = width / height;
        }
    }

    function SizeHeightChanged () {
        var d = DOWNLOAD_WIDGET.DimensionDialog;
        var pixelsPerInch = parseInt(d.SizeResInput.val());
        var height = parseInt(d.SizeHeightInput.val());
        d.PxHeightInput.val((height*pixelsPerInch).toFixed());
        if (d.ProportionsCheckbox.prop('checked')) {
            var width = height * d.AspectRatio;
            d.SizeWidthInput.val(width.toFixed(2));
            d.PxWidthInput.val((width*pixelsPerInch).toFixed());
        } else {
            var width = parseInt(d.SizeWidthInput.val());
            d.AspectRatio = width / height;
        }
    }

    function ResChanged () {
        var d = DOWNLOAD_WIDGET.DimensionDialog;
        var pixelsPerInch = parseInt(d.SizeResInput.val());
        var height = parseInt(d.SizeHeightInput.val());
        var width = parseInt(d.SizeWidthInput.val());
        d.PxHeightInput.val((height*pixelsPerInch).toFixed());
        d.PxWidthInput.val((width*pixelsPerInch).toFixed());
    }



    return DownloadImage;
})();



// Create a selection list of sessions.
// This does not belong here.
function InitSlideSelector(parent) {
    $('<div>')
        .appendTo(parent)
        .css({
            'background-color': 'white',
            'border-style': 'solid',
            'border-width': '1px',
            'border-radius': '5px',
            'position': 'absolute',
            'top' : '35px',
            'left' : '35px',
            'width' : '500px',
            'height' : '700px',
            'overflow': 'auto',
            'z-index': '4',
            'color': '#303030',
            'font-size': '20px' })
        .attr('id', 'sessionMenu').hide()
        .mouseleave(function(){$(this).fadeOut();});
    $('<ul>').appendTo('#sessionMenu').attr('id', 'sessionMenuSelector');
    
    // Create a selector for views.
    $('<div>')
        .appendTo(parent)
        .css({
            'background-color': 'white',
            'border-style': 'solid',
            'border-width': '1px',
            'border-radius': '5px',
            'position': 'absolute',
            'top' : '135px',
            'left' : '135px',
            'width' : '500px',
            'height' : '700px',
            'overflow': 'auto',
            'z-index': '4',
            'color': '#303030',
            'font-size': '20px' })
        .attr('id', 'viewMenu').hide()
        .mouseleave(function(){$(this).fadeOut();});
    $('<ul>').appendTo('#viewMenu').attr('id', 'viewMenuSelector'); // <select> for drop down
    
    $('<div>')
        .appendTo(parent)
        .css({
            'background-color': 'white',
            'border-style': 'solid',
            'border-width': '1px',
            'border-radius': '5px',
            'position': 'absolute',
            'top' : '30%',
            'left' : '30%',
            'width': '40%',
            'height': '40%',
            'z-index': '4',
            'color': '#303030',
            'font-size': '20px'})
        .attr('id', 'slideInformation')
        .hide()
        .mouseleave(function(){$(this).fadeOut();});
}







//==============================================================================
// Create and manage the menu to browse and select views.
// I am changing this to be more about selecting an image.
// I am also making this into a dialog object. (not based on the dialog class).

// It may be better to undock and redock


function ViewBrowser(parent) {
    var self = this;
    // A view browser (short cut menu) for the text input.
    this.Div = $('<div>')
        .appendTo(parent)
        .hide().css({
            'position'  : 'absolute',
            'top'       : '5%',
            'height'    : '80%',
            'left'      : '10%',
            'width'     : '70%',
            'padding'   : '5%',
            'z-index'   : '1007',
            'text-align': 'left',
            'color'     : '#303030'})
        .mouseleave(function () {self.Div.fadeOut();});

    this.TabbedDiv = new TabbedDiv(this.Div);
    this.BrowserDiv = this.TabbedDiv.NewTabDiv("Browser");
    this.BrowserDiv.css({'overflow-y':'auto'});
    this.SearchDiv = this.TabbedDiv.NewTabDiv("Search");
    this.ClipboardDiv = this.TabbedDiv.NewTabDiv("Clipboard");

    this.BrowserPanel = new BrowserPanel(
        this.BrowserDiv,
        function (viewObj) {
            self.SelectView(viewObj);
        });

    this.SearchPanel = new SearchPanel(
        this.SearchDiv,
        function (imageObj) {
            self.SelectImage(imageObj);
        });

    this.ClipboardPanel = new ClipboardPanel(
        this.ClipboardDiv,
        function (viewObj) {
            self.SelectView(viewObj);
        });

    this.Viewer = null;
}

ViewBrowser.prototype.SelectView = function(viewObj) {
    if (viewObj == null) {
        this.Viewer.SetCache(null);
        eventuallyRender();
    }

    // This will get the camera and the annotations too.
    var record = new SA.ViewerRecord();
    record.Load(viewObj.ViewerRecords[0]);
    record.Apply(this.Viewer);
    delete record;
    //this.SelectImage(viewObj.ViewerRecords[0].Image);
}

ViewBrowser.prototype.SelectImage = function(imgobj) {
    this.Div.fadeOut();
    var source = FindCache(imgobj);

    // We have to get rid of annotation which does not apply to the new image.
    this.Viewer.Reset();
    this.Viewer.SetCache(source);

    RecordState();

    eventuallyRender();
}


// Open the dialog. (ShowViewBrowser).
ViewBrowser.prototype.Open = function(viewer) {
    this.Viewer = viewer;
    if ( ! viewer) { return; }

    this.Div.show();
}


//==============================================================================
// Open close item
function BrowserFolder(parent, label, data, initCallback) {
    var self = this;
    this.Data = data;
    this.InitializeCallback = initCallback;
    // Bad name for this div because it contains the bullet too.
    // TODO: Change the name.
    this.TitleDiv = $('<div>')
        .css({'position':'relative'})
        .appendTo(parent);
    this.Bullet = $('<span>')
        .appendTo(this.TitleDiv)
        .css({'position':'absolute',
              'left':'0px',
              'top':'1px',
              'opacity':'0.75'})
        .addClass('ui-icon ui-icon-plus')
        .on('click.open',
            function() {
                self.OpenCallback();
            })
        .addClass('saButton'); // for hover highlighting

    this.Title = $('<div>')
        .appendTo(this.TitleDiv)
        .css({'margin-left':'20px'});
    this.Label = $('<div>')
        .appendTo(this.Title)
        .css({'display':'block'})
        .text(label);
    this.List = $('<ul>')
        .appendTo(parent)
        .addClass('sa-ul')
        .hide();
}

BrowserFolder.prototype.OpenCallback = function() {
    var self = this;
    if (this.InitializeCallback) {
        (this.InitializeCallback)(this);
        delete this.InitializeCallback;
    }
    // Remove the binding.
    // Setup next click to close.
    this.Bullet.off('click.open')
        .removeClass('ui-icon-plus')
        .addClass('ui-icon-minus')
        .on(
            'click.close',
            function () {
                self.CloseCallback();
            });
    this.List.show();
}

BrowserFolder.prototype.CloseCallback = function() {
    var self = this;
    // Setup next click to open.
    this.Bullet.off('click.close')
        .removeClass('ui-icon-minus')
        .addClass('ui-icon-plus')
        .on(
            'click.open',
            function () {
                self.OpenCallback();
            });
    this.List.hide();
}


//==============================================================================

function BrowserPanel(browserDiv, callback) {
    this.BrowserDiv = browserDiv;
    this.SelectView = callback;

    this.BrowserInfo = null;
    this.ReloadViewBrowserInfo();
    this.ProgressCount = 0;
}

// I have the same functionality in the SlideAtlas object.
// I am leaving this because this only displays progress in the browser.
BrowserPanel.prototype.PushProgress = function() {
    this.BrowserDiv.css({'cursor':'progress'});
    this.ProgressCount += 1;
}

BrowserPanel.prototype.PopProgress = function() {
    this.ProgressCount -= 1;
    if (this.ProgressCount <= 0) {
        this.BrowserDiv.css({'cursor':'default'});
    }
}




BrowserPanel.prototype.LoadGUI = function() {
    var self = this;
    var data = this.BrowserInfo;
    this.BrowserDiv.empty();
    groupList = $('<ul>')
        .addClass('sa-ul')
        .appendTo(this.BrowserDiv);

    for (i=0; i < data.sessions.length; ++i) {
        groupItem = $('<li>')
            .appendTo(groupList);
        var group = data.sessions[i];
        var groupFolder = new BrowserFolder(groupItem, group.rule);
        // Initialize immediately.
        var sessionList = groupFolder.List;
        for (j=0; j < group.sessions.length; ++j) {
            var session = group.sessions[j];
            var sessionData = {'db': session.sessdb, 'sessid': session.sessid};
            sessionItem = $('<li>')
                .appendTo(sessionList);
            new BrowserFolder(
                sessionItem, session.label, sessionData,
                function (folder) {
                    self.RequestSessionViews(folder)
                });
        }
    }
}

BrowserPanel.prototype.ReloadViewBrowserInfo = function() {
    var self = this;
    // Get the sessions this user has access to.

    this.PushProgress();
    $.get("/sessions?json=true",
          function(data,status){
              self.PopProgress();
              if (status == "success") {
                  self.BrowserInfo = data;
                  // I might want to open a session to avoid an extra click.
                  // I might want to sort the sessions to put the recent at the top.
                  self.LoadGUI(data);
              } else {
                  saDebug("ajax failed.");
              }
          });
}

BrowserPanel.prototype.RequestSessionViews = function(sessionFolder) {
    var self = this;
    this.PushProgress();
    var sessId = sessionFolder.Data.sessid;
    $.get("/sessions?json=true"+"&sessid="+sessId,
          function(data,status){
              self.PopProgress();
              if (status == "success") {
                  self.AddSessionViews(sessionFolder, data);
              } else { saDebug("ajax failed."); }
          });
}

BrowserPanel.prototype.AddSessionViews = function(sessionFolder, sessionData) {
    var self = this;
    var viewList = sessionFolder.List;
    for (var i = 0; i < sessionData.images.length; ++i) {
        var image = sessionData.images[i];
        var viewFolder = self.AddViewFolder(viewList,image.label,image.view);
        this.RequestViewChildren(viewFolder);
    }
}


// NOTE: It would be cleaner to wait for the view data before creating the folder.
// However, we might loose the order of the views in a session.
BrowserPanel.prototype.AddViewFolder = function(viewList, label, viewId) {
    var self = this;
    var item = $('<li>')
        .appendTo(viewList);
    // We do not know if views have subviews until we get the viewObj.
    // Just make them all folders for now.
    var viewData = {viewid:viewId};
    var viewFolder = new BrowserFolder(item, label, viewData);
    viewFolder.Bullet.hide();
    viewFolder.Title
        .click(function(){self.ViewClickCallback(viewFolder);})
        .addClass('saButton'); // for hover highlighting

    return viewFolder;
}


BrowserPanel.prototype.RequestViewChildren = function(viewFolder) {
    var self = this;
    this.PushProgress();
    var viewId = viewFolder.Data.viewid;
    $.ajax({
        type: "get",
        url: "/webgl-viewer/getview",
        data: {"viewid": viewId},
        success: function(data,status) {
            self.PopProgress();
            self.LoadViewChildren(viewFolder, data);
        },
        error: function() { 
            saDebug( "AJAX - error() : getview" ); 
            self.PopProgress();
        },
    });
}

BrowserPanel.prototype.LoadViewChildren = function(viewFolder, data) {
    // Replace image with thumb?
    if (data.Type == 'HTML') {
        // Add a small slide html page.
        var div1 = $('<div>')
            .appendTo(viewFolder.Title)
            .css({'position': 'relative',
                  'height': '100px',
                  'width':  '134px',
                  'margin-bottom':'2px',
                  'overflow':'hidden',
                  'border' :'1px solid #AAA'})
        var div = $('<div>')
            .appendTo(div1)
            .saPresentation({aspectRatio : 1.3333});
        div.saHtml(data.Text);
        div.trigger('resize');
        div.find('.sa-element').saElement({editable:false, interactive:false});
        // hack,  This should be off by default.
        div.find('.sa-viewer').saElement({hideCopyright:true});
        // Look for an alternative label.
        if (! data.Title || data.Title == "") {
            var titleDiv = div.find('.sa-presentation-title');
            if (titleDiv.length > 0) {
                viewFolder.Label.text(titleDiv.text());
            }
        }
    } else if (data.ViewerRecords && data.ViewerRecords.length > 0) {
        // Add the image to the label.
        var image = data.ViewerRecords[0].Image;
        $('<img>')
            .appendTo(viewFolder.Title)
            .attr('src', "/thumb?db="+image.database+"&img="+image._id)
            .css({'height': '50px',
                  'display':'block'});
    }

    if ( ! data.Children || data.Children.length < 1) { return; }
    viewFolder.Bullet.show();
    for (var i = 0; i < data.Children.length; ++i) {
        var child = data.Children[i];
        var childFolder = this.AddViewFolder(viewFolder.List, child.Title,
                                             child._id);

        this.LoadViewChildren(childFolder, child);
    }
}


BrowserPanel.prototype.ViewClickCallback = function(viewFolder) {
    var self = this;

    // null implies the user wants an empty view. ?????????????????
    //if (obj == null) {
    //    this.SelectView(null);
    //    return;
    //}

    // TODO: Get rid of this arg.
    var viewid = viewFolder.Data.viewid;

    // "sessid": $(obj).attr('sessid'),
    // Ok, so we only have the viewId at this point.
    // We need to get the view object to get the image id.
    this.PushProgress();
    $.ajax({
        type: "get",
        url: "/webgl-viewer/getview",
        data: {"viewid": viewid},
        success: function(data,status) {
            self.PopProgress();
            self.SelectView(data);
        },
        error: function() {
            self.PopProgress();
            saDebug( "AJAX - error() : getview (browser)" );
        },
    });
}






// Interface for ViewerSet
// GetNumberOfViewers();

// Does not have to abide.
// SetNumberOfViewers(n);

// GetViewer(idx);




// Create and repond to the dual / single view toggle button.
// How the window is derived between viewer1 and viewer1.
// Default: viewer1 uses all available space.


// TODO: Get rid of these gloabal variable.
var VIEWERS = [];
var VIEWER1;
var VIEWER2;



(function () {
    "use strict";


function DualViewWidget(parent) {
    var self = this;
    this.Viewers = []; // It would be nice to get rid of this.
    this.ViewerDivs = [];

    // Rather than getting the current note from the NotesWidget, keep a
    // reference here.  SlideShow can have multiple "displays".
    // We might consider keep a reference in the dua
    this.saNote = null;

    this.Parent = parent;
    parent.addClass('sa-dual-viewer');

    // This parent used to be CANVAS.
    var width = parent.innerWidth();
    var height = parent.innerHeight();
    var halfWidth = width/2;

    for (var i = 0; i < 2; ++i) {
        var viewerDiv = $('<div>')
            .appendTo(parent)
            .saViewer({overview:true, zoomWidget:true})
            .addClass("sa-view-canvas-div");

        this.ViewerDivs[i] = viewerDiv;
        this.Viewers[i] = viewerDiv[0].saViewer;
        // TODO: Get rid of this.
        // I beleive the note should sets this, and we do not need to do it
        // here..
        this.Viewers[i].RecordIndex = i;
    }

    // TODO: Get rid of these.
    VIEWERS = this.Viewers;
    VIEWER1 = this.Viewers[0];
    VIEWER2 = this.Viewers[1];

    this.DualView = false;
    this.Viewer1Fraction = 1.0;
    // It would be nice to integrate all animation in a flexible utility.
    this.AnimationLastTime = 0;
    this.AnimationDuration = 0;
    this.AnimationTarget = 0;

    if ( ! MOBILE_DEVICE || MOBILE_DEVICE == 'iPad') {
        // Todo: Make the button become more opaque when pressed.
        $('<img>')
            .appendTo(this.ViewerDivs[0])
            .css({'position':'absolute',
                  'right':'0px',
                  'top':'0px'})
            .addClass("sa-view-dualview-div")
            .attr('id', 'dualWidgetLeft')
            .attr('src',SA.ImagePathUrl+"dualArrowLeft2.png")
            .click(function(){self.ToggleDualView();})
            .attr('draggable','false')
            .on("dragstart", function() {
                return false;});

        $('<img>').appendTo(parent)
            .appendTo(this.ViewerDivs[1])
            .css({'position':'absolute',
                  'left':'0px',
                  'top':'0px'})
            .hide()
            .addClass("sa-view-dualview-img")
            .attr('id', 'dualWidgetRight')
            .attr('src',SA.ImagePathUrl+"dualArrowRight2.png")
            .click(function(){self.ToggleDualView();})
            .attr('draggable','false')
            .on("dragstart", function() {
                return false;});


        // DualViewer is the navigation widgets temporary home.
        // SlideShow can have multiple nagivation widgets so it is no
        // longer a singlton.
        // This is for moving through notes, session views and stacks.
        // It is not exactly related to dual viewer. It is sort of a child
        // of the dual viewer.
        this.NavigationWidget = new NavigationWidget(parent,this);
    }
}

// Abstracting saViewer  for viewer and dualViewWidget.
// Save viewer state in a note.
DualViewWidget.prototype.Record = function (note, startViewIdx) {
    if (startViewIdx) {
        note.StartIndex = startViewIdx;
    }
    startViewIdx = startViewIdx || 0;
    // TODO: Deal with multiple  windows consistently.
    // Now num viewRecords indicates the number of views in the display,
    // but not for stacks.  We have this start index which implies stack behavior.
    if ( note.Type != "Stack") {
        if (! this.DualView && note.ViewerRecords.length > 1) {
            note.ViewerRecords = [note.ViewerRecords[0]];
        }
        if (this.DualView && note.ViewerRecords.length < 2) {
            while ( note.ViewerRecords.length < 2) {
                note.ViewerRecords.push(new SA.ViewerRecord());
            }
        }
    }

    for (var i = 0; i  < this.GetNumberOfViewers(); ++i) {
        if (i + startViewIdx < note.ViewerRecords.length) {
            this.GetViewer(i).Record(note, i+startViewIdx);
        }
    }
}


// Abstracting the saViewer class to support dual viewers and stacks.
DualViewWidget.prototype.ProcessArguments = function (args) {
    if (args.note) {
        // TODO: DO we need both?
        this.saNote = args.note;
        //args.note.DisplayView(this);
        this.SetNote(args.note,args.viewIndex);
        // NOTE: TempId is legacy
        this.Parent.attr('sa-note-id', args.note.Id || args.note.TempId);
    }

    if (args.tileSource) {
        var w = args.tileSource.width;
        var h = args.tileSource.height;
        var cache = new SA.Cache();
        cache.TileSource = args.tileSource;
        // Use the note tmp id as an image id so the viewer can index the
        // cache.
        var note = new SA.Note();
        var image = {levels:     args.maxLevel + 1,
                     dimensions: [w,h],
                     bounds: [0,w-1, 0,h-1],
                     _id: note.TempId};
        var record = new SA.ViewerRecord();
        record.Image = image;
        record.OverviewBounds = [0,w-1,0,h-1];
        record.Camera = {FocalPoint: [w/2, h/2],
                         Roll: 0,
                         Height: h};
        note.ViewerRecords.push(record);
        cache.SetImageData(image);
        this.SetNote(args.note,args.viewIndex);
    }

    for (var i = 0; i < this.Viewers.length; ++i) {
        var viewer = this.Viewers[i];

        if (args.hideCopyright != undefined) {
            viewer.SetCopyrightVisibility( ! args.hideCopyright);
        }
        if (args.overview !== undefined) {
            viewer.SetOverViewVisibility(args.overview);
        }
        if (args.navigation !== undefined) {
            this.NavigationWidget.SetVisibility(args.navigation);
        }
        if (args.dualWidget !== undefined) {
            this.HideHandles = ! args.dualWidget;
            this.UpdateGui();
        }
        if (args.zoomWidget !== undefined) {
            viewer.SetZoomWidgetVisibility(args.zoomWidget);
        }
        if (args.drawWidget !== undefined) {
            viewer.SetAnnotationWidgetVisibility(args.drawWidget);
        }
        // The way I handle the viewer edit menu is messy.
        // TODO: Find a more elegant way to add tabs.
        // Maybe the way we handle the anntation tab shouodl be our pattern.
        if (args.menu !== undefined) {
            if ( ! viewer.Menu) {
                viewer.Menu = new ViewEditMenu(viewer, null);
            }
            viewer.Menu.SetVisibility(args.menu);
        }

        if (args.interaction !== undefined) {
            viewer.SetInteractionEnabled(args.interaction);
            if (this.NavigationWidget) {
                this.NavigationWidget.SetInteractionEnabled(args.interaction);
            }
        }
    }
}

// Which is better calling Note.Apply, or viewer.SetNote?  I think this
// will  win.
DualViewWidget.prototype.SetNote = function(note, viewIdx) {
    var self = this;
    // If the note is not loaded, request the note, and call this method
    // when the note is finally loaded.
    if (note && note.LoadState == 0) {
        note.LoadViewId(
            note.Id,
            function () {
                self.SetNote(note, viewIdx);
            });
    }

    if (! note || viewIdx < 0 || viewIdx >= note.ViewerRecords.length) {
        console.log("Cannot set viewer record of note");
        return;
    }
    if (viewIdx !== undefined) {
        note.StartIndex = viewIdx;
    }
    this.saNote = note;
    this.saViewerIndex = viewIdx;
    if (this.NavigationWidget) {
        this.NavigationWidget.SetNote(note);
        //this.NavigationWidget.Update(); // not sure if this is necessary
    }
    if (note.Type == "Stack") {
        // TODO: Can I move this logic into the display? SetNote maybe?
        // Possibly nagivationWidget (we need to know which viewer is referecne.
        // Select only gets called when the stack is first loaded.
        var self = this;
        this.GetViewer(0).OnInteraction(function () {
            self.SynchronizeViews(0, note);});
        this.GetViewer(1).OnInteraction(function () {
            self.SynchronizeViews(1, note);});
        note.DisplayStack(this);
        // First view is set by viewer record camera.
        // Second is set relative to the first.
        this.SynchronizeViews(0, note);
    } else {
        note.DisplayView(this);
    }

    if (SA.notesWidget) { 
        SA.notesWidget.SelectNote(note);
    }
}
DualViewWidget.prototype.GetNote = function () {
    return this.saNote;
}
DualViewWidget.prototype.GetRootNote = function () {
    var note = this.saNote;
    while (note.Parent) {
        note = note.Parent;
    }
    return note;
}
DualViewWidget.prototype.SetNoteFromId = function(noteId, viewIdx) {
    var note = GetNoteFromId(noteId);
    if ( ! note) {
        note = new SA.Note();
        var self = this;
        note.LoadViewId(
            noteId,
            function () {
                self.SetNote(note, viewIdx);
            });
        return note;
    }
    this.SetNote(note,viewIdx);
    return note;
}



// API for ViewerSet
DualViewWidget.prototype.GetNumberOfViewers = function() {
    if (this.DualView) {
        return 2;
    }

    return 1;
}

// API for ViewerSet
DualViewWidget.prototype.GetViewer = function(idx) {
    return this.Viewers[idx];
}

// Called programmatically. No animation.
DualViewWidget.prototype.SetNumberOfViewers = function(numViews) {
    this.DualView = (numViews > 1);

    if (this.DualView) {
        this.Viewer1Fraction = 0.5;
    } else {
        this.Viewer1Fraction = 1.0;
    }

    this.UpdateSize();
    this.UpdateGui();
}


DualViewWidget.prototype.ToggleDualView = function () {
    this.DualView = ! this.DualView;

    if (this.DualView) {
        // If there is no image in the second viewer, copy it from the first.
        if ( ! this.Viewers[1].GetCache()) {
            this.Viewers[1].SetCache(this.Viewers[0].GetCache());
            this.Viewers[1].GetCamera().DeepCopy(this.Viewers[0].GetCamera());
        }
        this.AnimationCurrent = 1.0;
        this.AnimationTarget = 0.5;
        // Edit menu option to copy camera zoom between views.
        // I do not call update gui here because I want
        // the buttons to appear at the end of the animation.
        $('#dualViewCopyZoom').show();
        // Animation takes care of switching the buttons
    } else {
        this.AnimationCurrent = 0.5;
        this.AnimationTarget = 1.0;
        this.UpdateGui();
    }

    RecordState();

    this.AnimationLastTime = new Date().getTime();
    this.AnimationDuration = 1000.0;
    this.AnimateViewToggle();
}

DualViewWidget.prototype.UpdateGui = function () {
    if ( this.HideHandles) {
        $('#dualWidgetLeft').hide();
        $('#dualWidgetRight').hide();
        return;
    }
    // Now swap the buttons.
    if (this.DualView) {
        $('#dualWidgetLeft').hide();
        $('#dualWidgetRight').show();
        // Edit menu option to copy camera zoom between views.
        $('#dualViewCopyZoom').show();
    } else {
        $('#dualWidgetRight').hide();
        $('#dualViewCopyZoom').hide();
        $('#dualWidgetLeft').show();
        // Edit menu option to copy camera zoom between views.
    }
}

DualViewWidget.prototype.AnimateViewToggle = function () {
    var timeStep = new Date().getTime() - this.AnimationLastTime;
    if (timeStep > this.AnimationDuration) {
        // end the animation.
        this.Viewer1Fraction = this.AnimationTarget;
        this.UpdateSize();
        this.UpdateGui();
        this.Draw();
        return;
    }

    var k = timeStep / this.AnimationDuration;

    // update
    this.AnimationDuration *= (1.0-k);
    this.Viewer1Fraction += (this.AnimationTarget - this.Viewer1Fraction) * k;

    this.UpdateSize();
    // 2d canvas does not draw without this.
    this.Draw();
    var self = this;
    requestAnimFrame(function () { self.AnimateViewToggle()});
}


DualViewWidget.prototype.CreateThumbnailImage = function(height) {
    var canvas = document.createElement("canvas"); //create
    var ctx = canvas.getContext("2d");
    var img1 = this.Viewers[0].MainView.CaptureImage();
    var scale = height / img1.height;
    var width1 = Math.round(img1.width * scale);
    var height1 = Math.round(img1.height * scale);
    if (this.DualView) {
        var img2 = this.Viewers[2].MainView.CaptureImage();
        var width2 = Math.round(img2.width * scale);
        var height2 = Math.round(img2.height * scale);
        canvas.width = width1 + width2;
        canvas.height = Math.max(height1, height2);
        ctx.drawImage(img2, 0, 0, img2.width, img2.height,
                      width1, 0, width2, height2);
    } else {
        canvas.width = width1;
        canvas.height = height1;
    }
    ctx.drawImage(img1, 0, 0, img1.width, img1.height,
                  0, 0, width1, height1);

    var url = canvas.toDataURL('image/jpeg', 0.8);
    var thumb = document.createElement("img"); //create
    thumb.src = url;

    return thumb;
}


DualViewWidget.prototype.Draw = function () {
    if (GL) {
      GL.clear(GL.COLOR_BUFFER_BIT | GL.DEPTH_BUFFER_BIT);
    }

    // This just changes the camera based on the current time.
    if (this.Viewers[0]) {
        this.Viewers[0].Animate();
        if (this.DualView) { this.Viewers[1].Animate(); }
        this.Viewers[0].Draw();
    }
    if (this.Viewers[1] && this.DualView) { this.Viewers[1].Draw(); }
}


DualViewWidget.prototype.UpdateSize = function () {
    var percent = this.Viewer1Fraction*100;
    if (this.ViewerDivs[0]) {
        this.ViewerDivs[0].css({'left':'0%',
                                'width':percent+'%',
                                'height':'100%'});
        this.Viewers[0].UpdateSize();
    }
    if (this.ViewerDivs[1]) {
        this.ViewerDivs[1].css({'left':percent+'%',
                                'width':(100-percent)+'%',
                               'height':'100%'});
        this.Viewers[1].UpdateSize();
    }

    if (percent >= 90) {
        this.Viewers[1].Hide();
    } else {
        this.Viewers[1].Show();
    }
}


DualViewWidget.prototype.AnnotationWidgetOn = function() {
    for (var i = 0; i < this.Viewers.length; ++i) {
        this.Viewers.AnnotationWidgetOn();
    }
}

DualViewWidget.prototype.AnnotationWidgetOff = function() {
    for (var i = 0; i < this.Viewers.length; ++i) {
        this.Viewers.AnnotationWidgetOff();
    }
}

// refViewerIdx is the viewer that changed and other viewers need 
// to be updated to match that reference viewer.
DualViewWidget.prototype.SynchronizeViews = function (refViewerIdx, note) {
    // We allow the viewer to go one past the end.
    if (refViewerIdx + note.StartIndex >= note.ViewerRecords.length) {
        return;
    }

    // Special case for when the shift key is pressed.
    // Translate only one camera and modify the tranform to match.
    if (SA.Edit && SA.StackCursorFlag) {
        var trans = note.ViewerRecords[note.StartIndex + 1].Transform;
        if ( ! note.ActiveCorrelation) {
            if ( ! trans) {
                alert("Missing transform");
                return;
            }
            // Remove all correlations visible in the window.
            var cam = this.GetViewer(0).GetCamera();
            var bds = cam.GetBounds();
            var idx = 0;
            while (idx < trans.Correlations.length) {
                var cor = trans.Correlations[idx];
                if (cor.point0[0] > bds[0] && cor.point0[0] < bds[1] && 
                    cor.point0[1] > bds[2] && cor.point0[1] < bds[3]) {
                    trans.Correlations.splice(idx,1);
                } else {
                    ++idx;
                }
            }

            // Now make a new replacement correlation.
            note.ActiveCorrelation = new PairCorrelation();
            trans.Correlations.push(note.ActiveCorrelation);
        }
        var cam0 = this.GetViewer(0).GetCamera();
        var cam1 = this.GetViewer(1).GetCamera();
        note.ActiveCorrelation.SetPoint0(cam0.GetFocalPoint());
        note.ActiveCorrelation.SetPoint1(cam1.GetFocalPoint());
        // I really do not want to set the roll unless the user specifically changed it.
        // It would be hard to correct if the wrong value got set early in the aligment.
        var deltaRoll = cam1.Roll - cam0.Roll;
        if (trans.Correlations.length > 1) {
            deltaRoll = 0;
            // Let roll be set by multiple correlation points.
        }
        note.ActiveCorrelation.SetRoll(deltaRoll);
        note.ActiveCorrelation.SetHeight(0.5*(cam1.Height + cam0.Height));
        return; 
    } else {
        // A round about way to set and unset the active correlation.
        // Note is OK, because if there is no interaction without the shift key
        // the active correlation will not change anyway.
        note.ActiveCorrelation = undefined;
    }

    // No shift modifier:
    // Synchronize all the cameras.
    // Hard coded for two viewers (recored 0 and 1 too).
    // First place all the cameras into an array for code simplicity.
    // Cameras used for preloading.
    if (! note.PreCamera) { note.PreCamera = new Camera();}
    if (! note.PostCamera) { note.PostCamera = new Camera();}
    var cameras = [note.PreCamera,
                   this.GetViewer(0).GetCamera(),
                   this.GetViewer(1).GetCamera(),
                   note.PostCamera];
    var refCamIdx = refViewerIdx+1; // An extra to account for PreCamera.
    // Start with the reference section and move forward.
    // With two sections, the second has the transform.

    for (var i = refCamIdx+1; i < cameras.length; ++i) {
        var transIdx = i - 1 + note.StartIndex;
        if (transIdx < note.ViewerRecords.length) {
            note.ViewerRecords[transIdx].Transform
                .ForwardTransformCamera(cameras[i-1],cameras[i]);
        } else {
            cameras[i] = undefined;
        }
    }

    // Start with the reference section and move backward.
    // With two sections, the second has the transform.
    for (var i = refCamIdx; i > 0; --i) {
        var transIdx = i + note.StartIndex-1;
        if (transIdx > 0) { // First section does not have a transform
            note.ViewerRecords[transIdx].Transform
                .ReverseTransformCamera(cameras[i],cameras[i-1]);
        } else {
            cameras[i-1] = undefined;
        }
    }

    // Preload the adjacent sections.
    if (cameras[0]) {
        var cache = SA.FindCache(note.ViewerRecords[note.StartIndex-1].Image);
        cameras[0].SetViewport(this.GetViewer(0).GetViewport());
        var tiles = cache.ChooseTiles(cameras[0], 0, []);
        for (var i = 0; i < tiles.length; ++i) {
            tiles[i].LoadQueueAdd();
        }
        LoadQueueUpdate();
    }
    if (cameras[3]) {
        var cache = SA.FindCache(note.ViewerRecords[note.StartIndex+2].Image);
        cameras[3].SetViewport(this.GetViewer(0).GetViewport());
        var tiles = cache.ChooseTiles(cameras[3], 0, []);
        for (var i = 0; i < tiles.length; ++i) {
            tiles[i].LoadQueueAdd();
        }
        LoadQueueUpdate();
    }

    // OverView cameras need to be updated.
    if (refViewerIdx == 0) {
        this.GetViewer(1).UpdateCamera();
        this.GetViewer(1).EventuallyRender(false);
    } else {
        this.GetViewer(0).UpdateCamera();
        this.GetViewer(0).EventuallyRender(false);
    }

    // Synchronize annitation visibility.
    var refViewer = this.GetViewer(refViewerIdx);
    for (var i = 0; i < 2; ++i) {
        if (i != refViewerIdx) {
            var viewer = this.GetViewer(i);
            if (viewer.AnnotationWidget && refViewer.AnnotationWidget) {
                viewer.AnnotationWidget.SetVisibility(
                    refViewer.AnnotationWidget.GetVisibility());
            }
        }
    }
}

    SA.DualViewWidget = DualViewWidget;

})();
//==============================================================================
// Is it time to switch to lowercase?  No.  I still like lower case for
// local variables. Upper case for instance variables 


function TabbedDiv(parent) {
    // Default css can be changed by the caller.
    this.Div = $('<div>')
        .appendTo(parent)
        .css({'position':'relative',
              'width':'100%',
              'height':'100%'});
    // div for the tab buttons.
    this.TabDiv = $('<div>')
        .appendTo(this.Div)
        .css({'position':'absolute',
              'width':'100%',
              'height':'30px'});
    // div for the tab bodies.
    this.BodyDiv = $('<div>')
        .appendTo(this.Div)
        .css({'position':'absolute',
              'width':'100%',
              'top':'30px',
              'bottom':'0px'});

    this.TabPanels = [];
    this.CurrentTabPanel = null;
}

// I want to hide the TabPanel object, so I return the div.
TabbedDiv.prototype.NewTabDiv = function (label, helpString) {
    var tabPanel = new TabPanel(this, label);
    if (helpString) {
        tabPanel.Tab.prop('title', helpString);
    }
    this.TabPanels.push(tabPanel);
    // First panel added should be open by default.
    if (this.TabPanels.length == 1) {
        this.OpenTabPanel(tabPanel);
    }

    return tabPanel.Div;
}

// Private
TabbedDiv.prototype.OpenTabPanel = function (tabPanel) {
    if ( ! tabPanel) { return;}
    // close to previous tab
    // NOTE: If we only close the previous panel, tab buttons wrap to the next line
    for (var i = 0; i < this.TabPanels.length; ++i) {
        var panel = this.TabPanels[i];
        panel.Div.hide();
        // The z-index does not seem to be working.
        // When the panel is zoomed, Tab looks like it is on top.
        panel.Tab.css({'color': '#AAA',
                       'z-index' : '4',
                       'border-color': '#BBB'});
    }
    // open the new tab.
    tabPanel.Div.show();
    tabPanel.Tab.css({'color': '#000',
                      'z-index' : '6',
                      'border-color': '#BBB #BBB #FFF #BBB'});
    this.CurrentTabPanel = tabPanel;
}

// Internal helper method
TabbedDiv.prototype.GetTabPanelFromDiv = function (tabDiv) {
    for (var i = 0; i < this.TabPanels.length; ++i) {
        var tabPanel = this.TabPanels[i];
        if (tabPanel.Div == tabDiv) {
            return tabPanel;
        }
    }
    return null;
}

// Internal helper method
TabbedDiv.prototype.GetTabPanelFromIndex = function (index) {
    if (index < 0 || index >= this.TabPanels.length) {
        console.log("GetTabPanelFromIndex("+index +"): error");
        return null;
    }
    return this.TabPanels[index];
}

TabbedDiv.prototype.ShowTabDiv = function (tabDiv) {
    this.OpenTabPanel(this.GetTabPanelFromDiv(tabDiv));
}

TabbedDiv.prototype.ShowTabIndex = function (index) {
    this.OpenTabPanel(this.GetTabPanelFromIndex(index));
}

TabbedDiv.prototype.EnableTabDiv = function (tabDiv) {
    var panel = this.GetTabPanelFromDiv(tabDiv);
    panel.Enabled = true;
    panel.Tab.show();
}

TabbedDiv.prototype.DisableTabDiv = function (tabDiv) {
    var panel = this.GetTabPanelFromDiv(tabDiv);
    if ( ! panel) { return;}

    panel.Enabled = false;
    if (panel == this.CurrentTabPanel) {
        this.CurrentTabPanel = null;
        // Find another panel to display.
        for ( var i = 0; i < this.TabPanels.length; ++i) {
            if (this.TabPanels[i].Enabled) {
                this.OpenTabPanel(this.TabPanel[i]);
                break;
            }
        }
    }

    panel.Tab.css({'color': '#AAA',
                   'z-index' : '4',
                   'border-color': '#BBB'});
    panel.Div.hide();
    panel.Tab.hide();
}


//==============================================================================


function TabPanel(tabbedDiv, title) {
    var self = this;
    this.Enabled = true;
    this.Tab = $('<div>')
        .appendTo(tabbedDiv.TabDiv)
        .text(title)
        .css({'color': '#AAA',
              'border-color': '#BBB',
              'position': 'relative',
              'bottom': '-2px',
              'padding' : '2px 7px 2px 7px',
              'margin'  : '5px 0px 0px 5px',
              'display': 'inline-block',
              'border-width': '1px',
              'border-style': 'solid',
              'border-radius': '5px 5px 0px 0px',
              'position': 'relative',
              'z-index' : '6',
              'background': 'white'})
        .click(function(){
            tabbedDiv.OpenTabPanel(self);
        });
    this.Div = $('<div>')
        .hide()
        .appendTo(tabbedDiv.BodyDiv)
        .css({'position':'absolute',
              'top':'0px',
              'bottom':'3px',
              'left':'3px',
              'right':'3px',
              'border-width': '1px',
              'border-style': 'solid',
              'border-color': '#BBB',
              'z-index' : '5',
              'background': 'white'})

}


//==============================================================================

//------------------------------------------------------------------------------
// Note object (maybe will be used for views and sessions too).

// TODO: Remove GUI from this file.

(function () {
    "use strict";



function Note () {
    if ( ! SA.Notes) {
        // data is the object retrieved from mongo (with string ids)
        // Right now we expect bookmarks, but it will be generalized later.
        SA.Notes = [];
    }

    // A global list of notes so we can find a note by its id.
    // TODO: Legacy.  Get rid of TempId.
    this.Id = this.TempId = new ObjectId().toString();
    SA.Notes.push(this);

    var self = this;
    // 0: just an id
    // 1: requested
    // 2: received
    this.LoadState = 0;

    this.User = GetUser(); // Reset by flask.
    var d = new Date();
    this.Date = d.getTime(); // Also reset later.
    this.Type = "Note";
    this.Mode = "";

    this.Title = "";
    this.Text = "";
    //this.UserText = "";
    this.Modified = false;

    // Upto two for dual view.
    this.ViewerRecords = [];

    // ParentNote (it would be nice to make the session a note too).
    this.Parent = null;

    // Sub notes
    this.Children = [];
    this.ChildrenVisibility = true;

    // GUI elements.
    this.Div = $('<li>')
        .attr({'class':'note'});

    this.TitleDiv = $('<div>')
        .css({'position':'relative'})
        .appendTo(this.Div);

    this.SortHandle = $('<span>')
        .appendTo(this.TitleDiv)
        .css({'position':'absolute',
              'left':'0px',
              'top':'0px',
              'opacity':'0.5'})
        .addClass('ui-icon ui-icon-bullet');

    this.ButtonsDiv = $('<div>')
        .appendTo(this.TitleDiv)
        .css({'float':'right'})
        .hide();
    this.TitleEntry = $('<div>')
        .css({'margin-left':'20px'})
        .appendTo(this.TitleDiv)
        .text(this.Title)
        .addClass('sa-title');

    if (SA.Edit) {
        this.AddButton = $('<img>')
            .appendTo(this.ButtonsDiv)
            .attr('src',SA.ImagePathUrl+"page_add.png")
            .addClass('editButton')
            .prop('title', "add view")
            .css({
                'width':'12px',
                'height':'12px',
                'opacity':'0.5'});
        this.LinkButton = $('<img>')
            .appendTo(this.ButtonsDiv)
            .attr('src',SA.ImagePathUrl+"link.png")
            .prop('title', "show url")
            .addClass('editButton')
            .css({
                'width':'12px',
                'height':'12px',
                'opacity':'1.0'});
        this.RemoveButton = $('<img>')
            .appendTo(this.ButtonsDiv)
            .hide()
            .attr('src',SA.ImagePathUrl+"remove.png")
            .prop('title', "delete")
            .addClass('editButton')
            .css({
                'width':'12px',
                'height':'12px',
                'opacity':'0.5'});
    }

    if (SA.HideAnnotations && this.HiddenTitle) {
        this.TitleEntry.text(this.HiddenTitle);
    }


    if (SA.Edit) {
        this.Modified = false;
        this.TitleEntry
            .attr('contenteditable', "true");
    }


    // The div should attached even if nothing is in it.
    // A child may appear and UpdateChildrenGui called.
    // If we could tell is was removed, UpdateChildGUI could append it.
    this.ChildrenDiv = $('<ul>')
        .addClass('sa-ul')
        .appendTo(this.Div);

    if (SA.Edit) {
        this.ChildrenDiv
            .sortable({update: function(event,ui){self.SortCallback();},
                       handle: ".ui-icon"});
    } else {
        this.ChildrenDiv
            .disableSelection();
    }

    // This is for stack notes (which could be a subclass).
    // It looks like the stack will start on this index when it first
    // is loaded.  This changes when navigating the stack.
    this.StartIndex = 0;
    this.ActiveCorrelation = undefined;
    this.StackDivs = [];
}

// For copy slide in presentations
Note.prototype.DeepCopy = function(note) {
    // I tried serialize / load, but the image changed to a string id.
    this.Image = Note.Image; // not really deep.
    this.Children = [];
    for (var i = 0; i < note.Children.length; ++i) {
        var child = new Note();
        child.DeepCopy(note.Children[i]);
        this.Children.push(child);
    }
    this.Parent = note.Parent;
    this.StartIndex = note.StartIndex;
    // Replace old note id with new in HTML.
    var oldId = note.Id;
    var newId = this.Id;
    this.Text = note.Text.replace(oldId, newId);
    this.Title = note.Title;
    this.Type = note.Type;
    this.User = note.User;
    //this.UserText = note.UserText;
    this.ViewerRecords = [];
    for (var i = 0; i < note.ViewerRecords.length; ++i) {
        var record = new sa.ViewerRecord();
        record.DeepCopy(note.ViewerRecords[i]);
        this.ViewerRecords.push(record);
    }
}

// So this is a real pain.  I need to get the order of the notes from
// the childrenDiv jquery element.
Note.prototype.SortCallback = function() {
    var newChildren = [];
    var children = this.ChildrenDiv.children();
    for (var newIndex = 0; newIndex < children.length; ++newIndex) {
        var oldIndex = $(children[newIndex]).data('index');
        var note = this.Children[oldIndex];
        note.Div.data("index", newIndex);
        newChildren.push(note);
    }

    this.Children = newChildren;
    this.UpdateChildrenGUI();
    if (SA.notesWidget) {
        SA.notesWidget.MarkAsModified();
    }
}


function GetNoteFromId(id) {
    if (id.substr(0,3) == 'tmp') {
        var idx = parseInt(id.substr(3));
        return SA.Notes[idx];
    }
    for (var i = 0; i < SA.Notes.length; ++i) {
        var note = SA.Notes[i];
        if (note.Id && note.Id == id) {
            return note;
        }
    }
    return null;
}


// OBSOLETE
/*
// Every time the "Text" is loaded, they hyper links have to be setup.
Note.prototype.FormatHyperlink = function() {
    if ( ! SA.notesWidget) { return; }
    var self = this;
    if (this.Id) {
        span = document.getElementById(this.Id);
        if (span) {
            $(span)
                //  I do not want the text to change.
                .click(function() { self.DisplayView(SA.notesWidget.Display);})
                //.click(function() { SA.notesWidget.SelectNote(self);})
                .css({'color': '#29C'})
                .hover(function(){ $(this).css("color", "blue");},
                       function(){ $(this).css("color", "#29C");});
            // Let the selection indicate the current note.
            // this highlighting suggests the camera button will
            // will operate on this link rather than inserting a new one.
            //if (this == SA.notesWidget.SelectedNote) {
            //    $(span).css({'background':'#CCC'});
            //} else {
                $(span).css({'background':'white'});
            //}
        }
    }
}
*/

// When the note is deleted, this clear associated text links.
// However, it does not remove the span id.
Note.prototype.ClearHyperlink = function() {
    var self = this;
    if (this.Id) {
        // I think is will be best to seelct the element and then replace
        // it with text.
        this.SelectHyperlink();
        var sel = window.getSelection();
        document.execCommand('insertText', sel.toString());
    }
}

// Programatically select the hyper link (when the note is selected).
Note.prototype.SelectHyperlink = function () {
    if (this.Id) {
        var el = document.getElementById(this.Id);
        if (el) {
            var range = document.createRange();
            //range.selectNodeContents(el);
            range.selectNode(el);
            var sel = window.getSelection();
            sel.removeAllRanges();
            sel.addRange(range);
        }
    }
}

// Programatically select the hyper link (when the note is selected).
Note.prototype.UnselectHyperlink = function () {
    if (this.Id) {
        var el = document.getElementById(this.Id);
        if (el) {
            var range = document.createRange();
            range.collapse(true);
            var sel = window.getSelection();
            sel.removeAllRanges();
            sel.addRange(range);
        }
    }
}

Note.prototype.SetParent = function(parent) {
    var self = this;
    this.Parent = parent;
    if (parent && SA.Edit) {
        this.RemoveButton.show();
    }
}

Note.prototype.TitleFocusInCallback = function() {
    // Keep the viewer from processing arrow keys.
    SA.ContentEditableHasFocus = true;
    if (SA.DualDisplay) {
        SA.DualDisplay.SetNote(this);
    }
}


Note.prototype.TitleFocusOutCallback = function() {
    if (this.Modified) {
        // Move the Title from the GUI to the note.
        this.Modified = false;
        this.Title = this.TitleEntry.text();
        if (SA.notesWidget) {
            SA.notesWidget.MarkAsModified();
        }
    }
    // Allow the viewer to process arrow keys.
    SA.ContentEditableHasFocus = false;
    if ( ! this.Modified) { return; }
    this.Modified = false;
    var text = this.TitleEntry.text();
    if (this.Title != text && ! SA.HideAnnotations) {
        this.Title = text;
        this.Save();
    }
    if (this.HiddenTitle != text && SA.HideAnnotations) {
        this.HiddenTitle = text;
        this.Save();
    }
}

Note.prototype.LinkCallback = function() {
    if ( ! SA.LinkDiv) { return; }
    var text = "slide-atlas.org/webgl-viewer?view="+this.Id;
    SA.LinkDiv.html(text);
    SA.LinkDiv.show();
    // Select the text so it is easy to copy.
    var range = document.createRange();
    range.selectNodeContents(SA.LinkDiv[0]);
    var sel = window.getSelection();
    sel.removeAllRanges();
    sel.addRange(range);
    
    // Try to copy to the clipboard.
    document.execCommand('copy',false,null);
}

Note.prototype.DeleteCallback = function() {
    if (this.Type == "UserNote") {
        // User notes have a parent, but are also roots.
        return;
    }
    var parent = this.Parent;
    if (parent == null) {
        return;
    }

    this.ClearHyperlink();

    if (this.Type != 'view') {
        if (SA.DualDisplay && SA.DualDisplay.NavigationWidget &&
            SA.DualDisplay.NavigationWidget.GetNote() == this) {
            // Move the current note off this note.
            // There is always a previous.
            SA.DualDisplay.NavigationWidget.PreviousNote();
        }
    }

    // Get rid of the note.
    var index = parent.Children.indexOf(this);
    parent.Children.splice(index, 1);
    this.Parent = null;

    // Redraw the GUI.
    parent.UpdateChildrenGUI();
    if (SA.notesWidget) {
        SA.notesWidget.MarkAsModified();
    }
}

Note.prototype.SetUserNote = function(userNote) {
    var parentNote = this;
    parentNote.UserNote = userNote;
    userNote.Parent = parentNote;
    userNote.Type = "UserNote";
}

Note.prototype.UserCanEdit = function() {
    return SA.Edit;
}

Note.prototype.RecordView = function(display) {
    // TODO: Get rid of VIEWER globals.
    if (display.GetNumberOfViewers() == 0) { return; }

    if (this.Type == "Stack") {
        // All we want to do is record the default
        // camera of the first section (if we at
        // the start of the stack).
        var viewer0 = display.GetViewer(0);
        if (this.StartIndex == 0) {
            this.ViewerRecords[0].CopyViewer(viewer0);
        }
        return;
    }
    this.ViewerRecords = [];
    for (var i = 0; i < display.GetNumberOfViewers(); ++i) {
        var viewerRecord = new SA.ViewerRecord();
        viewerRecord.CopyViewer(display.GetViewer(i));
        this.ViewerRecords.push(viewerRecord);
    }

}

Note.prototype.AddChild = function(childNote, first) {
  // Needed to get the order after a sort.
  childNote.Div.data("index", this.Children.length);

  if (first) {
    this.Children.splice(0, 0, childNote);
  } else {
    this.Children.push(childNote);
  }

  this.UpdateChildrenGUI();
}

// TODO: Get the GUI stuff out of note objects.
Note.prototype.UpdateChildrenGUI = function() {
    // Callback trick
    var self = this;
    
    // Clear
    this.ChildrenDiv.empty();

    // Stacks
    if (this.Type == "Stack") {
        // I want viewer records to look like children for stacks.
        this.StackDivs = [];
        for (var i = 0; i < this.ViewerRecords.length; ++i) {
            var sectionDiv = $('<div>')
                .addClass('note')
                .appendTo(this.ChildrenDiv);
            if (SA.HideAnnotations) {
                sectionDiv.text(i.toString())
            } else {
                sectionDiv.text(this.ViewerRecords[i].Image.label)
            }
            this.StackDivs.push(sectionDiv);
            if (i == this.StartIndex) {
                sectionDiv.css({'background-color':'#BBB'});
            }
        }
        return;
    }

    // Notes
    if (this.Children.length == 0) {
        return;
    }

    // Move all the views to the end.  They do not take part in the notes
    // gui. They are for text links.  They may mess up drag ordering.
    var newChildren = [];
    for (var i = 0; i < this.Children.length; ++i) {
        if (this.Children[i].Type == "Note") {
            newChildren.push(this.Children[i]);
        }
    }
    for (var i = 0; i < this.Children.length; ++i) {
        if (this.Children[i].Type != "Note") {
            newChildren.push(this.Children[i]);
        }
    }
    this.Children = newChildren;

    for (var i = 0; i < this.Children.length; ++i) {
        if (this.Children[i].Type == "Note") {
            this.Children[i].DisplayGUI(this.ChildrenDiv);
            // Indexes used for sorting.
            this.Children[i].Div.data("index", i);
            if (this.Children.length > 1) {
                this.Children[i].SortHandle.addClass('sa-sort-handle');
            } else {
                this.Children[i].SortHandle.removeClass('sa-sort-handle');
            }
        }
    }
}

Note.prototype.NewIterator = function() {
    return new NoteIterator(this);
}

Note.prototype.Contains = function(decendent) {
  for (var i = 0; i < this.Children.length; ++i) {
    var child = this.Children[i];
    if (child == decendent) {
      return true;
    }
    if (child.Contains(decendent)) {
      return true;
    }
  }
  return false;
}

// Create a new note,  add it to the parent notes children at index "childIdx".
// The new note is not automatically selected.
Note.prototype.NewChild = function(childIdx, title) {
    // Create a new note.
    var childNote = new Note();
    childNote.Title = title;
    var d = new Date();
    childNote.Date = d.getTime(); // Temporary. Set for real by server.

    // Now insert the child after the current note.
    this.Children.splice(childIdx,0,childNote);
    childNote.SetParent(parentNote);

    return childNote;
}

// Save the note in the database and set the note's id if it is new.
// callback function can be set to execute an action with the new id.
Note.prototype.Save = function(callback, excludeChildren) {
    console.log("Save note " + this.Id + " " + this.Title);

    var self = this;
    // Save this users notes in the user specific collection.
    var noteObj = JSON.stringify(this.Serialize(excludeChildren));
    var d = new Date();
    SA.PushProgress();
    $.ajax({
        type: "post",
        url: "/webgl-viewer/saveviewnotes",
        data: {"note" : noteObj,
               "date" : d.getTime()},
        success: function(data,status) {
            SA.PopProgress();
            if (callback) {
                (callback)(self);
            }
        },
        error: function() {
            SA.PopProgress();
            saDebug("AJAX - error() : saveviewnotes" );
        },
    });
}

Note.prototype.RecordAnnotations = function(display) {
    for (var i = 0; i < display.GetNumberOfViewers(); ++i) {
        if (this.ViewerRecords.length > this.StartIndex+i) {
            this.ViewerRecords[this.StartIndex+i].CopyAnnotations(
                display.GetViewer(i));
        }
    }
}

// No clearing.  Just draw this notes GUI in a div.
Note.prototype.DisplayGUI = function(div) {
    var self = this;
    this.Div.appendTo(div);

    this.TitleEntry
        .click(function() {
            if (SA.DualDisplay) { SA.DualDisplay.SetNote(self); }
            self.ButtonsDiv.show();
        })
        .bind('input', function () {
            self.Modified = true;
        })
        .focusin(function() { self.TitleFocusInCallback(); })
        .focusout(function() { self.TitleFocusOutCallback(); })
        .mouseleave(function() {
            if (self.Modified) {
                self.Modified = false;
                self.Title = self.TitleEntry.text();
                if (SA.notesWidget) {SA.notesWidget.MarkAsModified();}
            }
        });

    this.TitleDiv
        .hover(
            function() {
                self.TitleEntry.css({'color':'#33D'});
                if (SA.notesWidget && SA.notesWidget.SelectedNote == self) {
                    self.ButtonsDiv.show();
                }
            },
            function() {
                self.TitleEntry.css({'color':'#3AF'});
                self.ButtonsDiv.hide();
            });

    if (SA.HideAnnotations && this.HiddenTitle) {
        this.TitleEntry.text(this.HiddenTitle);
    } else {
        this.TitleEntry.text(this.Title);
    }

    // Changing a div "parent/appendTo" removes all event bindings like click.
    // I would like to find a better solution to redraw.
    if (SA.Edit) {
        // Removing and adding removes the callbacks.
        this.AddButton
            .click(function () {
                if (SA.notesWidget) {SA.notesWidget.NewCallback();}
            });
        this.LinkButton
            .click(function () {
                self.LinkCallback();
            });
        this.RemoveButton
            .click(function () {
                self.DeleteCallback();
        });
    }

    this.UpdateChildrenGUI();
}


Note.prototype.Serialize = function(excludeChildren) {
    var obj = {};
    obj.SessionId = localStorage.sessionId;
    obj.Type = this.Type;
    obj.Mode = this.Mode;
    obj.User = this.User;
    obj.Date = this.Date;

    // user data to customize note types
    // I needed this for background color and apsect ratio of presentations.
    if (this.TypeData) {
        obj.TypeData = this.TypeData;
    }
    

    if (this.NotesPanelOpen) {
        obj.NotesPanelOpen = true;
    }

    if (this.Id) {
        obj._id = this.Id;
        delete this._id;
    }
    // I would like to put the session as parent, but this would be an inclomplete reference.
    // A space is not a valid id. Niether is 'false'. Lets leave it blank. 
    if (this.Parent) {
        if (typeof(this.Parent) == 'string') {
            // When the parent is an image.
            obj.ParentId = this.Parent;
        }
        if (typeof(this.Parent) == 'object' && this.Parent.Id) {
            // When the parent is a note.
            obj.ParentId = this.Parent.Id;
        }
        // These snuck into the database.
        delete this.ParentId
    }
    obj.Title = this.Title;
    obj.HiddenTitle = this.HiddenTitle;

    obj.Text = this.Text;
    // The server handles copying views and the code is a pain.
    // I would rather have the client copy notes since is can now
    // save them one by one and get ids for new notes.
    // However,  until I make this change, I need a simple way of copying
    // a note and not messing up the references in the text.
    // Code the links in the html as indexes.
    //for (var i = 0; i < this.Children.length; ++i) {
    //    var Child
    //}

    // We should probably serialize the ViewerRecords too.
    obj.ViewerRecords = [];

    // The database wants an image id, not an embedded iamge object.
    //  The server should really take care of this since if
    for (var i = 0; i < this.ViewerRecords.length; ++i) {
        if(!this.ViewerRecords[i].Image) continue;
        var record = this.ViewerRecords[i].Serialize();
        obj.ViewerRecords.push(record);
    }

    // upper left pixel
    obj.CoordinateSystem = "Pixel";

    // Will this erase children if includeChildren is off?
    if ( ! excludeChildren) {
        obj.Children = [];
        for (var i = 0; i < this.Children.length; ++i) {
            obj.Children.push(this.Children[i].Serialize(excludeChildren));
        }
    }

    return obj;
}

// This method of loading is causing a pain.
// Children ...
Note.prototype.Load = function(obj){
    var self = this;

    // Received
    this.LoadState = 2;

    var ivar;
    for (ivar in obj) {
        this[ivar] = obj[ivar];
    }
    // I am not sure blindly copying all of the variables is a good idea.
    if (this._id) {
        this.Id = this._id;
        delete this._id;
    }

    if (this.ParentId) {
        this.Parent = GetNoteFromId(this.ParentId);
        delete this.ParentId
    }

    if (SA.HideAnnotations && this.HiddenTitle) {
        this.TitleEntry.text(this.HiddenTitle);
    } else {
        this.TitleEntry.text(this.Title);
    }

    for (var i = 0; i < this.Children.length; ++i) {
        var child = this.Children[i];
        var childNote = new Note();
        childNote.SetParent(this);
        if (typeof(child) == "string") {
            // Asynchronous.  This may cause problems (race condition)
            // We should have a load state in note.
            //childNote.LoadViewId(child);
            childNote.Id = child;
        } else {
            childNote.Load(child);
        }
        this.Children[i] = childNote;
        childNote.Div.data("index", i);
    }

    // I believe the server embeds the correct user note.
    if (this.UserNote) {
        // Make the user not into a real object.
        var obj = this.UserNote;
        this.UserNote = new Note();
        this.UserNote.Load(obj);
    }

    for (var i = 0; i < this.ViewerRecords.length; ++i) {
        if (this.ViewerRecords[i]) {
            obj = this.ViewerRecords[i];
            // It would be nice to have a constructor that took an object.
            this.ViewerRecords[i] = new SA.ViewerRecord();
            this.ViewerRecords[i].Load(obj);
        }
    }
}

Note.prototype.LoadViewId = function(viewId, callback) {
    var self = this;
    // Received
    this.LoadState = 1;

    SA.PushProgress();

    $.ajax({
        type: "get",
        url: "/webgl-viewer/getview",
        data: {"viewid": viewId},
        success: function(data,status) {
            SA.PopProgress();
            self.Load(data);
            if (callback) {
                (callback)();
            }
        },
        error: function() {
            SA.PopProgress();
            saDebug( "AJAX - error() : getview" )
        },
    });
}

Note.prototype.Collapse = function() {
    this.ChildrenVisibility = false;
    if (this.Contains(SA.notesWidget.SelectedNote)) {
        // Selected note should not be in collapsed branch.
        // Make the visible ancestor active.
        SA.DualDisplay.SetNote(this);
    }
    this.UpdateChildrenGUI();
    SA.DualDisplay.NavigationWidget.Update();
}

Note.prototype.Expand = function() {
    this.ChildrenVisibility = true;
    this.UpdateChildrenGUI();
    SA.DualDisplay.NavigationWidget.Update();
}

// Extra stuff for stack.
Note.prototype.DisplayStack = function(display) {
    this.DisplayView(display);
    // For editing correlations
    if (SA.Edit && this.StartIndex+1 < this.ViewerRecords.length) {
        var trans = this.ViewerRecords[this.StartIndex + 1].Transform;
        if (trans) {
            display.GetViewer(0).StackCorrelations = trans.Correlations;
            display.GetViewer(1).StackCorrelations = trans.Correlations;
        }
    }
    // Indicate which section is being displayed in viewer 1
    for (var i = 0; i < this.StackDivs.length; ++i) {
        if (i == this.StartIndex) {
            this.StackDivs[i].css({'background-color':'#BBB'});
        } else {
            this.StackDivs[i].css({'background-color':'#FFF'});
        }
    }
}

// Set the state of the WebGL viewer from this notes ViewerRecords.
Note.prototype.DisplayView = function(display) {
    if (display.NavigationWidget) {
        display.NavigationWidget.SetNote(this);
    }

    // To determine which notes camera to save.
    // For when the user creates a camera link.
    if (SA.notesWidget) {
        SA.notesWidget.DisplayedNote = this;
    }

    var numViewers = display.GetNumberOfViewers();
    if (numViewers == 0) { return; }
    if (this.Type == 'Stack') {
        // Stack display needs to keep both viewers up to date.
        numViewers = 2;
    }

    // Remove Annotations from the previous note.
    for (var i = 0; i < numViewers; ++i) {
        display.GetViewer(i).Reset();
    }

    // We could have more than two in the future.
    if (this.Type != 'Stack') {
        // I want the single view (when set by the user) to persist for rthe stack.
        numViewers = this.ViewerRecords.length;
    }
    display.SetNumberOfViewers(numViewers);

    var idx = this.StartIndex;
    for (var i = 0; i < numViewers; ++i) {
        var viewer = display.GetViewer(i);

        if (i + idx < this.ViewerRecords.length) {
            this.ViewerRecords[idx + i].Apply(viewer);
            // This is for synchroninzing changes in the viewer back to the note.
            viewer.RecordIndex = i;
        }
    }
}

// Creates default transforms for Viewer Records 1-n
// (if they do not exist already).  Uses cameras focal point.
Note.prototype.InitializeStackTransforms = function () {
    for (var i = 1; i < this.ViewerRecords.length; ++i) {
        if ( ! this.ViewerRecords[i].Transform) {
            var cam0 = this.ViewerRecords[i-1].Camera;
            var cam1 = this.ViewerRecords[i].Camera;
            var dRoll = cam1.Roll - cam0.Roll;
            if (dRoll < 0.0) { dRoll += 2*Math.PI; }
            var trans = new PairTransformation();
            trans.AddCorrelation(cam0.FocalPoint, cam1.FocalPoint, dRoll, 
                                 0.5*(cam0.Height+cam1.Height));
            this.ViewerRecords[i].Transform = trans;
        }
    }
}

    SA.Note = Note;

})();
// that possibly share a superclass.

// Notes can be nested (tree structure) to allow for student questions, comments or discussion.
// Sessions could be notes.
// Notes within the same level are ordered.
// Question answers can be sub notes.

// Students can save comments that are not seen by other students.
// Student notes are stored as "favorites".
// Notes keep an ID of their parent in the database.
// The recording API is used to save the state of viewers (ViewerRecord)
// Notes just add a tree structure on top of these states (with GUI).

// Right now we are loading the view and bookmarks as notes.
// Bookmarks have two notes: Question and a child answer.
// I need to change this to be more like the origin open layers presentation.

// TODO:
// Highlight icon on hover.
// Drag notes to change the order.
// Show the user "favorite" notes.
// Allow user to delete the favorite note (even if edit is not on).

// HTML:
// Students like the HTML Text and would like to see hyperlinks to
// annotation and cameras.  The Scheme is not setup for this because
// children have their own text.  I am going to change the behavior so
// that children that do not have their own text, show the text of their
// parent.  I will probably hide children without text in the top display.
// TODO:
// Bug: Tabs do not look right (bottom should be white / z_index?)
// Bug: only the last child added can be selected by the title.
//      only the last child added shows the delete and camera buttons.
//      This only happens when editing.  Loading a saved view/note works
//      fine.
// Bug: Note title not being saved.
// Bug: Type "test" reload (not saved).


// Deleting a note should delete the usernote.
// Deleting a hyper link should delete its note. (test)

// Maybe have a "Add" at the bottom of the link list.
// Move deleted links to trash instead of deleting. (Undo delete)
// A way to get permalink to notes. (for Brown) (LinkCallback)
// Indicate the current note in the text.
// Save notes panel state (opened, closed, width) in mongo.
// ??? Link notes better in html ??? Saving edited html is the problem here.
// Make browser back arrow undo link (will this cause tiles to reload (note
//     panel to disapear?)

// NOTE:
// - !!!!!!!!!!!!!!!!!!!!!! Copy note needs to change ids in html !!!!!!!!!!!!!!!
// -I Could not highlight hyperlink when note is selected.
//     Text cannot be selected when hidden.  I would have to select the
//     text when Text tabe is clicked.....
// -Hyperlink selection background color (and color) should not be saved in
//     the note / database.

//==============================================================================

(function () {
    "use strict";

    // TODO: Merge this with the text editor in viewer-utils.
    // Gray out buttons when no text is selected.
    // Remove options to insert link if no text is selected.


    function TextEditor(parent, display) {
        var self = this;
        this.Display = display;
        this.Parent = parent;
        // I do not want the text editable until the note is set.
        this.Editable = true;
        this.Edit = true;
        // The user can set this to save the note automatically.
        this.ChangeCallback = null;

        this.EditButtons = [];
        this.AddEditButton(SA.ImagePathUrl+"camera.png", "link view",
                           function() {self.InsertCameraLink();});
        this.AddEditButton(SA.ImagePathUrl+"link.png", "link URL",
                           function() {self.InsertUrlLink();});
        this.AddEditButton(SA.ImagePathUrl+"font_bold.png", "bold",
                           function() {document.execCommand('bold',false,null);});
        this.AddEditButton(SA.ImagePathUrl+"text_italic.png", "italic",
                           function() {document.execCommand('italic',false,null);});
        this.AddEditButton(SA.ImagePathUrl+"edit_underline.png", "underline",
                           function() {document.execCommand('underline',false,null);});
        this.AddEditButton(SA.ImagePathUrl+"list_bullets.png", "unorded list",
                           function() {document.execCommand('InsertUnorderedList',false,null);});
        this.AddEditButton(SA.ImagePathUrl+"list_numbers.png", "ordered list",
                           function() {document.execCommand('InsertOrderedList',false,null);});
        this.AddEditButton(SA.ImagePathUrl+"indent_increase.png", "indent",
                           function() {document.execCommand('indent',false,null);});
        this.AddEditButton(SA.ImagePathUrl+"indent_decrease.png", "outdent",
                           function() {document.execCommand('outdent',false,null);});
        this.AddEditButton(SA.ImagePathUrl+"alignment_left.png", "align left",
                           function() {document.execCommand('justifyLeft',false,null);});
        this.AddEditButton(SA.ImagePathUrl+"alignment_center.png", "align center",
                           function() {document.execCommand('justifyCenter',false,null);});
        this.AddEditButton(SA.ImagePathUrl+"edit_superscript.png", "superscript",
                           function() {document.execCommand('superscript',false,null);});
        this.AddEditButton(SA.ImagePathUrl+"edit_subscript.png", "subscript",
                           function() {document.execCommand('subscript',false,null);});
        this.AddEditButton(SA.ImagePathUrl+"font_increase.png", "large font",
                           function(){
                               document.execCommand('fontSize',false,'5');
                               self.ChangeBulletSize('1.5em');
                           });
        this.AddEditButton(SA.ImagePathUrl+"font_decrease.png", "small font",
                           function() {
                               document.execCommand('fontSize',false,'2');
                               self.ChangeBulletSize('0.9em');
                           });
        // TODO: Get selected text to see if we can convert it into a question.
        this.AddEditButton(SA.ImagePathUrl+"question.png", "add question",
                           function() {
                               self.AddQuestion();
                           });

        this.InitializeHomeButton(parent);

        this.TextEntry = $('<div>')
            .appendTo(parent)
            .attr('contenteditable', "true")
            .removeAttr('readonly')
            .css({'box-sizing': 'border-box',
                  'width': '100%',
                  'height':'100%',
                  'border-style': 'solid',
                  'overflow': 'auto',
                  'resize': 'none',
                  'border-style': 'inset',
                  'background': '#f5f8ff'})
            .bind('input', function () {
                // Leave events are not triggering.
                self.EventuallyUpdate();
            })
            .focusin(function() {
                SA.ContentEditableHasFocus = true;
            })
            .focusout(function() {
                SA.ContentEditableHasFocus = false;
                self.Update();
            })
        // Mouse leave events are not triggering.
            .mouseleave(function() { // back button does not cause loss of focus.
                self.Update();
            });

        this.UpdateTimer = null;
        this.RecordViewTimer = null;

        // Do not enable editing until the Note is set.
        this.EditOff();
        this.Note = null;
    }

    TextEditor.prototype.HomeCallback = function() {
        if ( ! this.Note) {
            return;
        }
        this.Note.DisplayView(this.Display);
    }

    // Home button is a link.  The link menu is used for other links too.
    TextEditor.prototype.InitializeHomeButton = function(parent) {
        var self = this;
        this.HomeButton = $('<div>')
            .appendTo(parent)
            .text("Home")
            .css({'text-align':'center',
                  'border':'1px solid #666666',
                  'border-radius': '10px',
                  'color': '#29C',
                  'background':'white'})
            .hover(function(){ $(this).css("color", "blue");},
                   function(){ $(this).css("color", "#29C");});
        this.HomeButton.contextmenu( function() { return false; });
        this.HomeButton.mousedown(function(e){
            if( e.button == 0 ) {
                self.HomeCallback();
                return false;
            }
            if( e.button == 2 ) {
                self.LinkMenuObject = {Link : self.HomeButton,
                                       Note : self.Note};
                // Position and show the properties menu.
                var pos = $(this).position();
                // Cannot delete the root note.
                self.DeleteLinkButton.hide();
                self.LinkMenu
                    .css({'left':(25 + pos.left)+'px',
                          'top' :(pos.top)+'px'})
                    .show();
                return false;
            }
            return true;
        });

        // When a link is right clicked, the object {Link: ..., Note: ...} is set and the
        // menu is made visible.
        this.LinkMenuObject = undefined;
        this.LinkMenu = $('<div>')
            .appendTo(parent)
            .hide()
            .mouseleave(function(){$(this).hide();})
            .css({'position'  :'absolute',
                  'background-color': '#FFFFFF',
                  'border'    :'1px solid #666666',
                  'box-sizing': 'border-box',
                  'left'      : '-78px',
                  'width'     : '100px',
                  'padding'   : '0px 2px'})
        $('<button>')
            .appendTo(this.LinkMenu)
            .text("Save View")
            .css({'margin': '2px 0px',
                  'width' : '100%'})
            .prop('title', "Replace Annotation")
            .click(
                function(){
                    self.SaveLink(self.LinkMenuObject.Link,
                                  self.LinkMenuObject.Note);
                    self.LinkMenu.hide();
                });
        this.DeleteLinkButton = $('<button>')
            .appendTo(this.LinkMenu)
            .text("Delete")
            .css({'margin': '2px 0px',
                  'width' : '100%'})
            .click(
                function(){
                    self.DeleteLink(self.LinkMenuObject.Link,
                                    self.LinkMenuObject.Note);
                    self.LinkMenu.hide();
                });
    }

    // Every time the "Text" is loaded, they hyper links have to be setup.
    // TODO: Do we need to turn off editable?
    TextEditor.prototype.FormatLink = function(linkNote) {
        var self = this;
        var link = document.getElementById(linkNote.Id);
        if (link) {
            $(link)
                .css({'color': '#29C',
                      'background':'white'})
                .hover(function(){ $(this).css("color", "blue");},
                       function(){ $(this).css("color", "#29C");})
                .attr('contenteditable', "false");

            $(link).contextmenu( function() { return false; });
            $(link).mousedown(function(e){
                if( e.button == 0 ) {
                    linkNote.DisplayView(self.Display);
                    return false;
                }
                if( e.button == 2 ) {
                    self.LinkMenuObject = {Link : $(link),
                                           Note : linkNote};
                    // Position and show the properties menu.
                    var pos = $(this).position();
                    self.DeleteLinkButton.show();
                    self.LinkMenu
                        .css({'left':(25 + pos.left)+'px',
                              'top' :(pos.top)+'px'})
                        .show();
                    return false;
                }
                return true;
            });
        }
    }

    TextEditor.prototype.SaveLink = function(link, note) {
        note.RecordView(this.Display);
        note.Save();
    }

    TextEditor.prototype.DeleteLink = function(link, note) {
        // TODO: Keep the old text.
        var text = link.text();
        $(document.createTextNode(text)).insertAfter(link);
        link.remove();
        note.DeleteCallback();
        this.UpdateNote();
        this.Note.Save();
    }

    TextEditor.prototype.Change = function(callback) {
        this.ChangeCallback = callback;
    }

    TextEditor.prototype.EventuallyUpdate = function() {
        if (this.UpdateTimer) {
            clearTimeout(this.UpdateTimer);
            this.UpdateTimer = null;
        }
        var self = this;
        this.UpdateTimer = setTimeout(function () { self.UpdateNote() }, 5000);
    }

    TextEditor.prototype.Update = function() {
        if (this.UpdateTimer) {
            clearTimeout(this.UpdateTimer);
            this.UpdateTimer = null;
        } else {
            // I am using the timer as a modified flag.
            // Call update note to force an update.
            return;
        }
        this.UpdateNote();
    }

    TextEditor.prototype.EditOff = function() {
        if ( ! this.Edit) { return;}
        this.Edit = false;

        for (var i = 0; i < this.EditButtons.length; ++i) {
            this.EditButtons[i].hide();
        }

        this.TextEntry
            .attr('contenteditable', 'false')
            .attr('spellcheck', 'false')
            .css({'border-style': 'outset',
                  'background': '#ffffff'})
            .unbind('input')
            .unbind('focusin')
            .unbind('focusout')
            .unbind('mouseleave')
            .blur();
    }

    TextEditor.prototype.EditableOff = function() {
        this.EditOff();
        this.Editable = false;
    }


    TextEditor.prototype.EditOn = function() {
        var self = this;
        if ( ! this.Editable) { return; }
        if (this.Edit) { return;}
        this.Edit = true;

        for (var i = 0; i < this.EditButtons.length; ++i) {
            this.EditButtons[i].show();
        }

        this.TextEntry
            .attr('contenteditable', "true")
            .removeAttr('readonly')
            .css({'border-style': 'inset',
                  'background': '#f5f8ff'})
            .bind('input', function () {
                self.Modified = true;
                self.EventuallyUpdate();
            })
            .focusin(function() {
                SA.ContentEditableHasFocus = true;
            })
            .focusout(function() {
                SA.ContentEditableHasFocus = false;
                self.Update();
            })
            .mouseleave(function() { // back button does not cause loss of focus.
                self.Update();
            });
    }

    TextEditor.prototype.AddEditButton = function(src, tooltip, callback) {
        var self = this;
        var button = $('<img>');
        if (tooltip) {
            //button = $('<img title="'+tooltip+'">')
            button.prop('title', tooltip);
        }
        button
            .appendTo(this.Parent)
            .addClass('editButton')
            .attr('src',src)
            .click(callback);
        this.EditButtons.push(button);
    }

    TextEditor.prototype.AddQuestion = function() {
        var bar = $('<div>')
            .css({'position':'relative',
                  'margin':'3%',
                  'width':'90%',
                  'background':'#FFF',
                  'border':'1px solid #AAA',
                  'padding':'1% 1% 1% 1%'}) // top right bottom left
            .attr('contenteditable', 'false')
            .saQuestion({editable: SA.Edit,
                         position : 'static'});

        // Need to get the range here because the dialog changes it.
        var self = this;
        var range = SA.GetSelectionRange(this.TextEntry);
        // Try to initialize the dialog with the contents of the range.
        if ( ! range.collapsed) {
            var clone = range.cloneContents();
            bar.saQuestion('SetQuestionText', clone.firstChild.textContent);
            if (clone.childElementCount > 1) {
                //var answers = clone.querySelectorAll('li');
                var answers = [];
                var li = clone.querySelector('li');
                if (li) {
                    answers = li.parentElement;
                } else {
                    answers = clone.children[1];
                }
                for (var i = 0; i < answers.childElementCount; ++i) {
                    var answer = answers.children[i];
                    var bold = (answer.style.fontWeight == "bold") ||
                        ($(answer).find('b').length > 0);
                    bar.saQuestion('AddAnswerText',
                                   answer.textContent,
                                   bold);
                }
            }
        }

        bar.saQuestion('OpenDialog',
                       function () {
                           if (range) {
                               range.deleteContents();
                               range.insertNode(document.createElement('br'));
                           } else {
                               range = SA.MakeSelectionRange(self.TextEntry);
                           }
                           range.insertNode(bar[0]);
                           // Some gymnasitcs to keep the cursor after the question.
                           range.collapse(false);
                           var sel = window.getSelection();
                           sel.removeAllRanges();
                           sel.addRange(range);
                           self.TextEntry[0].focus();
                           self.UpdateNote();
                       });
    }

    // execCommand fontSize does change bullet size.
    // This is a work around.
    TextEditor.prototype.ChangeBulletSize = function(sizeString) {
        var self = this;
        var sel = window.getSelection();
        // This call will clear the selected text if it is not in this editor.
        var range = SA.GetSelectionRange(this.TextEntry);
        range = range || SA.MakeSelectionRange(this.TextEntry);
        var listItems = $('li');
        for (var i = 0; i < listItems.length; ++i) {
            var item = listItems[i];
            if (range.isPointInRange(item,0) ||
                range.isPointInRange(item,1)) {
                $(item).css({'font-size':sizeString});
            }
        }
    }


    TextEditor.prototype.InsertUrlLink = function() {
        var self = this;
        var sel = window.getSelection();
        // This call will clear the selected text if it is not in this editor.
        var range = SA.GetSelectionRange(this.TextEntry);
        var selectedText = sel.toString();

        if ( ! this.UrlDialog) {
            var self = this;
            var dialog = new Dialog(function() {
                self.InsertUrlLinkAccept();
            });
            dialog.Body.css({'margin':'1em 2em'});
            this.UrlDialog = dialog;
            dialog.Dialog.css({'width':'40em'});
            dialog.Title.text("Paste URL link");
            dialog.TextDiv =
                $('<div>')
                .appendTo(dialog.Body)
                .css({'display':'table-row',
                      'width':'100%'});
            dialog.TextLabel =
                $('<div>')
                .appendTo(dialog.TextDiv)
                .text("Text to display:")
                .css({'display':'table-cell',
                      'height':'2em',
                      'text-align': 'left'});
            dialog.TextInput =
                $('<input>')
                .appendTo(dialog.TextDiv)
                .val('#30ff00')
                .css({'display':'table-cell',
                      'width':'25em'});

            dialog.UrlDiv =
                $('<div>')
                .appendTo(dialog.Body)
                .css({'display':'table-row'});
            dialog.UrlLabel =
                $('<div>')
                .appendTo(dialog.UrlDiv)
                .text("URL link:")
                .css({'display':'table-cell',
                      'text-align': 'left'});
            dialog.UrlInput =
                $('<input>')
                .appendTo(dialog.UrlDiv)
                .val('#30ff00')
                .css({'display':'table-cell',
                      'width':'25em'})
                .bind('input', function () {
                    var url = self.UrlDialog.UrlInput.val();
                    if (self.UrlDialog.LastUrl == self.UrlDialog.TextInput.val()) {
                        // The text is same as the URL. Keep them synchronized.
                        self.UrlDialog.TextInput.val(url);
                    }
                    self.UrlDialog.LastUrl = url;
                    // Deactivate the apply button if the url is blank.
                    if (url == "") {
                        self.UrlDialog.ApplyButton.attr("disabled", true);
                    } else {
                        self.UrlDialog.ApplyButton.attr("disabled", false);
                    }
                });
        }

        // We have to save the range/selection because user interaction with
        // the dialog clears the text entry selection.
        this.UrlDialog.SelectionRange = range;
        this.UrlDialog.TextInput.val(selectedText);
        this.UrlDialog.UrlInput.val("");
        this.UrlDialog.LastUrl = "";
        this.UrlDialog.ApplyButton.attr("disabled", true);
        this.UrlDialog.Show(true);
    }

    TextEditor.prototype.InsertUrlLinkAccept = function() {
        var sel = window.getSelection();
        var range = this.UrlDialog.SelectionRange;
        range = range || SA.MakeSelectionRange(this.TextEntry);

        // Simply put a span tag around the text with the id of the view.
        // It will be formated by the note hyperlink code.
        var link = document.createElement("a");
        link.href = this.UrlDialog.UrlInput.val();
        link.target = "_blank";

        // Replace or insert the text.
        if ( ! range.collapsed) {
            // Remove the seelcted text.
            range.extractContents(); // deleteContents(); // cloneContents
            range.collapse(true);
        }
        var linkText = this.UrlDialog.TextInput.val();
        if (linkText == "") {
            linkText = this.UrlDialog.UrlInput.val();
        }
        link.appendChild( document.createTextNode(linkText) );

        range.insertNode(link);
        if (range.noCursor) {
            // Leave the selection the same as we found it.
            // Ready for the next link.
            sel.removeAllRanges();
        }
        this.UpdateNote();
    }

    // This global variable is an attempt to enumerate generated
    // names for links.  The flaw is it always starts over when page is
    // loaded. It does not detect links from previous edits.
    var LINKS_WITH_NO_NAME = 0;

    // TODO: Untangle view links from the note.
    TextEditor.prototype.InsertCameraLink = function() {
        // Create a child note.
        var parentNote = this.Note;
        if ( ! parentNote) {
            parentNote = SA.DualDisplay.GetRootNote();
        }

        // Create a new note to hold the view.
        // Put the new note at the end of the list.
        var childIdx = parentNote.Children.length;
        //var childIdx = 0; // begining
        var childNote = parentNote.NewChild(childIdx, text);
        // Setup and save
        childNote.RecordView(this.Display);
        // Block subnotes and separate text.
        childNote.Type = 'View';

        // We need to save the note to get its Id.
        var text = "(view)";
        var range = SA.GetSelectionRange(this.TextEntry);
        if ( ! range) {
            range = SA.MakeSelectionRange(this.TextEntry);
        } else if ( ! range.collapsed) {
            text = range.toString();
        }
        childNote.Title = text;
        range.deleteContents();

        // Simply put a span tag around the text with the id of the view.
        // It will be formated by the note hyperlink code.
        var span = document.createElement("span");
        // This id identifies the span as a hyperlink to this note.
        // The note will format the link and add callbacks later.
        span.id = childNote.Id;
        $(span).attr('contenteditable', 'false');
        span.appendChild( document.createTextNode(text) );
        range.insertNode(span);
        // Let the note format it.
        this.FormatLink(childNote);

        // Some gymnasitcs to keep the cursor after the question.
        range.collapse(false);
        var sel = window.getSelection();
        sel.removeAllRanges();
        sel.addRange(range);
        this.TextEntry[0].focus();
        // NOTE: This may not be necesary no that text note "views" are
        // issolated from notes in views tab.
        this.UpdateNote();

        this.Note.Save();
    }

    TextEditor.prototype.Resize = function(width, height) {
        var pos;
        pos = this.TextEntry.offset();
        this.TextEntry.height(height - pos.top - 5);
    }

    TextEditor.prototype.SetHtml = function(html) {
        if (this.UpdateTimer) {
            clearTimeout(this.UpdateTimer);
            this.Update();
        }
        this.Note = null; //??? Editing without a note
        this.EditOn();
        this.TextEntry.html(html);

        if (SA.Edit) {
            var items = this.TextEntry.find('.sa-question');
            items.saQuestion({editable:true,
                              position : 'static'});
        }

        // Note needed here long term.
        // this looks for keywords in text and makes tags.
        SA.AddHtmlTags(this.TextEntry);
    }

    TextEditor.prototype.GetHtml = function() {
        return this.TextEntry.html();
    }

    // TODO: Editor should not become active until it has a note.
    // This probably belongs in a subclass.
    // Or in the note.
    TextEditor.prototype.LoadNote = function(note) {
        if (this.UpdateTimer) {
            clearTimeout(this.UpdateTimer);
            this.Update();
        }
        this.Note = note;
        this.TextEntry.html(note.Text);

        // TODO: Hide this.  Maybe use saHtml.
        if (SA.Edit) {
            var items = this.TextEntry.find('.sa-question');
            items.saQuestion({editable:true,
                              position : 'static'});
        }

        // TODO: Make the hyper link the same pattern as questions.
        for (var i = 0; i < note.Children.length; ++i) {
            // In the future we can only call this on type "View"
            this.FormatLink(note.Children[i]);
        }

        this.MakeLinksClickable();
        if (SA.Edit) {
            this.EditOn();
        }
    }

    // Copy the text entry text back into the note
    // (when the textEntry changes).
    // It saves the note too.
    TextEditor.prototype.UpdateNote = function() {
        this.UpdateTimer = null;
        if ( ! this.Note) {
            return;
        }
        this.Note.Text = this.TextEntry.html();
        if (this.ChangeCallback) {
            (this.ChangeCallback)();
        }

        this.MakeLinksClickable();
    }

    // Link are not active in content editable divs.
    // Work around this.
    TextEditor.prototype.MakeLinksClickable = function() {
        if (SA.Edit) {
            // This is only necesary when div is editable.
            // Links work the same in both situations with this.
            var links = $("a");
            for (var i = 0; i < links.length; ++i) {
                var link = links[i];
                $(link)
                    .click(function() {
                        window.open(this.href,'_blank');
                    })
            }
        }
    }

    SA.TextEditor = TextEditor;

})();

    //==============================================================================


(function () {
    "use strict";


function NotesWidget(parent, display) {
    this.ModifiedCallback = null;
    this.LinkDiv;
    // This is a hack.  I do not know when to save the camera.
    // The save button will save the camera for the last note displayed.
    // This may be different that the selected note because of camera links
    // in text that do not change the text.
    this.DisplayedNote = null;

    // Popup div to display permalink.
    SA.LinkDiv =
        $("<div>")
        .appendTo('body')
        .css({'top':'30px',
              'left': '10%',
              'position': 'absolute',
              'width':'80%',
              'height': '50px',
              'z-index':'3',
              'background-color':'#FFF',
              'border':'1px solid #777',
              'border-radius': '8px',
              'text-align': 'center',
              'padding-top': '26px'})
        .hide()
        .mouseleave(function() { SA.LinkDiv.fadeOut(); });

    // There is not option to show the link when SA.Edit is not on,
    // so this really does nothing.  Editable is probably necessary
    // for selection to copy.
    if (SA.Edit) {
        SA.LinkDiv.attr('contenteditable', "true");
    }

    var self = this;
    this.Display = display;

    this.Modified = false;
    this.Window = $('<div>')
        .appendTo(parent)
        .css({
            'background-color': 'white',
            'position': 'absolute',
            'top'    : '0%',
            'left'   : '0%',
            'height' : '100%',
            'width'  : '100%',
            'z-index': '2'})
        .attr('draggable','false')
        .on("dragstart", function() {return false;})
        .attr('id', 'NoteWindow');

    //--------------------------------------------------------------------------

    // Keeps track of the current note.
    this.NavigationWidget;

    // For clearing selected GUI setting.
    this.SelectedNote;

    // GUI elements
    this.TabbedWindow = new TabbedDiv(this.Window);
    this.LinksDiv = this.TabbedWindow.NewTabDiv("Views");
    this.LinksRoot = $('<ul>')
        .addClass('sa-ul')
        .css({'padding-left':'0px'})
        .appendTo(this.LinksDiv);
    this.TextDiv = this.TabbedWindow.NewTabDiv("Text");
    this.UserTextDiv = this.TabbedWindow.NewTabDiv("Notes", "private notes");

    for (var i = 0; i < this.Display.GetNumberOfViewers(); ++i) {
        this.Display.GetViewer(i).OnInteraction(function (){self.RecordView();});
    }


    this.LinksDiv
        .css({'overflow': 'auto',
              'text-align': 'left',
              'color': '#303030',
              'font-size': '18px'})
        .attr('id', 'NoteTree');

    // no longer needed, but interesting: 'box-sizing': 'border-box'

    // This is the button for the links tab div.
    if (SA.Edit) {
        this.AddViewButton = $('<button>')
            .appendTo(this.LinksDiv)
            .css({'border-radius': '4px',
                  'margin': '1em'})
            .text("+ New View")
    }

    // Show hidden content to non administrator.
    // Do not show this unless not is interactive.
    this.QuizButton = $('<div>')
        .appendTo(this.TextDiv)
        .addClass('editButton')
        .css({'float':'right',
              'font-size':'small',
              'margin-top':'4px',
              'padding-left':'2px',
              'padding-right':'2px',
              'border':'1px solid #AAA',
              'border-radius':'2px'})
        .text("show")
        .hide();

    // Now for the text tab:
    if (SA.Edit) {
        // TODO: Encapsulate this menu (used more than once)
        this.QuizDiv = $('<div>')
            .appendTo(this.TextDiv)
        this.QuizMenu = $('<select name="quiz" id="quiz">')
            .appendTo(this.QuizDiv)
            .css({'float':'right',
                  'margin':'3px'})
            .change(function () {
                if ( ! self.RootNote) { return; }
                if (this.value == "review") {
                    self.RootNote.Mode = "answer-show";
                } else if (this.value == "hidden") {
                    self.RootNote.Mode = "answer-hide";
                } else if (this.value == "interactive") {
                    self.RootNote.Mode = "answer-interactive";
                }
                self.UpdateQuestionMode();
            });
        this.QuizLabel = $('<div>')
            .appendTo(this.TextDiv)
            .css({'float':'right',
                  'font-size':'small',
                  'margin-top':'4px'})
            .text("quiz");
        $('<option>')
            .appendTo(this.QuizMenu)
            .text('review');
        $('<option>')
            .appendTo(this.QuizMenu)
            .text('hidden');
        $('<option>')
            .appendTo(this.QuizMenu)
            .text('interactive');
        // Set the question mode
        this.QuizMenu.val("review");
    }

    this.TextEditor = new SA.TextEditor(this.TextDiv, this.Display);
    if ( ! SA.Edit) {
        this.TextEditor.EditableOff();
    } else {
        this.TextEditor.Change(
            function () {
                self.MarkAsModified();
            });
    }
    // Private notes.
    this.UserTextEditor = new SA.TextEditor(this.UserTextDiv, this.Display);
    this.UserTextEditor.Change(
        function () {
            self.UserTextEditor.Note.Save();
        });
}

NotesWidget.prototype.UpdateQuestionMode = function() {
    // Set the question mode
    if ( ! this.RootNote) {
        return;
    }

    if ( ! this.RootNote.Mode) {
        this.RootNote.Mode = 'answer-show';
    }

    if (this.QuizMenu) {
        if (this.RootNote.Mode == 'answer-hide') {
            this.QuizMenu.val("hidden");
        } else if (this.RootNote.Mode == 'answer-interactive') {
            this.QuizMenu.val("interactive");
        } else {
            //this.RootNote.Mode = 'answer-show';
            this.QuizMenu.val("review");
        }
    }
    if (this.RootNote.Mode == 'answer-interactive') {
        var self = this;
        this.QuizButton
            .show()
            .css('background-color','')
            .click(function () {
                self.SetAnswerVisibility('answer-show');
                self.QuizButton.css({'background-color':'#AAAAAA'});
            })
    } else {
        this.QuizButton.hide();
    }

    this.SetAnswerVisibility(this.RootNote.Mode);
}


NotesWidget.prototype.SetAnswerVisibility = function(mode) {
    // make sure tags have been decoded.
    SA.AddHtmlTags(this.TextEditor.TextEntry);

    if (mode == 'answer-show') {
        $('.sa-note').show();
        $('.sa-notes').show();
        $('.sa-diagnosis').show();
        $('.sa-differential-diagnosis').show();
        $('.sa-teaching-points').show();
        $('.sa-compare').show();
    } else {
        $('.sa-note').hide();
        $('.sa-notes').hide();
        $('.sa-diagnosis').hide();
        $('.sa-differential-diagnosis').hide();
        $('.sa-teaching-points').hide();
        $('.sa-compare').hide();
    }
    $('.sa-question').saQuestion('SetMode', mode);
}


NotesWidget.prototype.SetNavigationWidget = function(nav) {
    this.NavigationWidget = nav;
}

NotesWidget.prototype.SetModifiedCallback = function(callback) {
    this.ModifiedCallback = callback;
}

NotesWidget.prototype.SetModifiedClearCallback = function(callback) {
    this.ModifiedClearCallback = callback;
}

// Two types of select.  This one is from the views tab.
// It sets the text from the note.
// There has to be another from text links.  That does not set the
// text.
NotesWidget.prototype.SelectNote = function(note) {
    if (note == this.SelectedNote) {
        // Just reset the camera.
        //note.DisplayView(this.Display);
        return;
    }
    // Flush the timers before moving to another view.
    // GUI cannot call this object.
    if (this.RecordViewTimer) {
        clearTimeout(this.RecordViewTimer);
        this.RecordViewTimer = null;
        this.RecordView2();
    }

    // This should method should be split between Note and NotesWidget
    if (SA.LinkDiv.is(':visible')) { SA.LinkDiv.fadeOut();}

    this.TextEditor.LoadNote(note);

    // Handle the note that is being unselected.
    // Clear the selected background of the deselected note.
    if (this.SelectedNote) {
        this.SelectedNote.TitleEntry.css({'background':'white'});
        // Make the old hyper link normal color.
        $('#'+this.SelectedNote.Id).css({'background':'white'});
    }

    this.SelectedNote = note;

    // Indicate which note is selected.
    note.TitleEntry.css({'background':'#f0f0f0'});
    // This highlighting can be confused with the selection highlighting.
    // Indicate hyperlink current note.
    //$('#'+SA.notesWidget.SelectedNote.Id).css({'background':'#CCC'});
    // Select the current hyper link
    note.SelectHyperlink();

    //if (SA.DualDisplay &&
    //    SA.DualDisplay.NavigationWidget) {
    //    SA.DualDisplay.NavigationWidget.Update();
    //}

    //if (this.Display.GetNumberOfViewers() > 1) {
    //    this.Display.GetViewer(1).Reset();
    //    // TODO:
    //    // It would be nice to store the viewer configuration
    //    // as a separate state variable.  We might want a stack
    //    // that defaults to a single viewer.
    //    this.Display.SetNumberOfViewers(note.ViewerRecords.length);
    //}

    // Clear the sync callback.
    //var self = this;
    //for (var i = 0; i < this.Display.GetNumberOfViewers(); ++i) {
    //    this.Display.GetViewer(i).OnInteraction();
    //    if (SA.Edit) {
    //        // These record changes in the viewers to the notes.
    //        this.Display.GetViewer(i).OnInteraction(function () {self.RecordView();});
    //    }
    //}
}

NotesWidget.prototype.RecordView = function() {
    if ( ! SA.Edit) { return; }

    if (this.RecordViewTimer) {
        clearTimeout(this.RecordViewTimer);
    }
    var self = this;
    this.RecordViewTimer = setTimeout(
        function () { self.RecordView2() },
        1000);
}

NotesWidget.prototype.RecordView2 = function() {
    this.RecordViewTimer = null;
    var note = this.GetCurrentNote();
    //note.RecordView(this.Display);
    // Hack to keep root from getting view annotations.
    // TODO: CLean up the two parallel paths Notes ad views.
    if (this.DisplayedNote && note == this.DisplayedNote) {
        note.RecordAnnotations(this.Display);
    }
}


NotesWidget.prototype.MarkAsModified = function() {
    if (this.ModifiedCallback) {
        this.ModifiedCallback();
    }
    this.Modified = true;
}


NotesWidget.prototype.MarkAsNotModified = function() {
    if (this.ModifiedClearCallback) {
        this.ModifiedClearCallback();
    }
    this.Modified = false;
}

NotesWidget.prototype.SetRootNote = function(rootNote) {
    if (this.UpdateTimer) {
        clearTimeout(this.UpdateTimer);
        this.Update();
    }
    //this.Display.SetNote();

    this.RootNote = rootNote;
    this.DisplayRootNote();

    // Only show user notes for the first image of the root note.
    // I can rethink this later.
    if (rootNote.ViewerRecords.length > 0) {
        this.RequestUserNote(rootNote.ViewerRecords[0].Image._id);
    }

    // Set the state of the notes widget.
    // Should we ever turn it off?
    if (SA.ResizePanel) {
        SA.ResizePanel.SetVisibility(rootNote.NotesPanelOpen, 0.0);
    }

    this.UpdateQuestionMode();
}


// TODO:
// Hmmmm.  I do not think this is used yet.
// SA.SaveButton setup should not be here though.
NotesWidget.prototype.EditOn = function() {
    SA.SaveButton
        .prop('title', "save to database")
        .attr('src',SA.ImagePathUrl+"save22.png")
        .click(function(){self.SaveCallback();});
    this.AddViewButton.show();
    this.TextEditor.EditOn();
}

NotesWidget.prototype.EditOff = function() {
    SA.SaveButton
        .prop('title', "edit view")
        .attr('src',SA.ImagePathUrl+"text_edit.png")
        .click(function(){self.EditOn();});
    this.AddViewButton.hide();
    this.TextEditor.EditOff();

    /*
    .. note camera buttons....
        .. note title entry (content editable.) ....
        .. note remove button ...
        .. link and delete button ...
        .. Stack stuff ...
    */

}

NotesWidget.prototype.SaveCallback = function(finishedCallback) {
    // Process containers for diagnosis ....
    SA.AddHtmlTags(this.TextEditor.TextEntry);

    // Lets try saving the camera for the current note.
    // This is a good comprise.  Do not record the camera
    // every time it moves, but do record it when the samve button
    // is pressed.
    // Camer links in text can display a note without selecting the note. (current).
    var note = this.DisplayedNote;
    if (note) {
        note.RecordView(this.Display);
    }
    note = this.GetCurrentNote();
    // Lets save the state of the notes widget.
    note.NotesPanelOpen = (SA.ResizePanel && SA.ResizePanel.Visibility);

    var rootNote = this.Display.GetRootNote();
    if (rootNote.Type == "Stack") {
        // Copy viewer annotation to the viewer record.
        rootNote.RecordAnnotations(this.Display);
    }

    var self = this;
    rootNote.Save(function () {
        self.Modified = false;
        if (finishedCallback) {
            finishedCallback();
        }
    });
}

//------------------------------------------------------------------------------

NotesWidget.prototype.GetCurrentNote = function() {
    return this.Display.GetNote();
}


NotesWidget.prototype.SaveBrownNote = function() {
    // Create a new note.
    var note = new SA.Note();
    note.RecordView(this.Display);

    // This is not used and will probably be taken out of the scheme,
    note.SetParent(this.GetCurrentNote());

    // Make a thumbnail image to represent the favorite.
    // Bug: canvas.getDataUrl() not supported in Safari on iPad.
    // Fix: If on mobile, use the thumbnail for the entire slide.
    var src;
    if(MOBILE_DEVICE){
        var image = this.Display.GetViewer(0).GetCache().Image;
        src = "/thumb?db=" + image.database + "&img=" + image._id + "";
    } else {
        var thumb = SA.DualDisplay.CreateThumbnailImage(110);
        src = thumb.src;
    }

    // Save the favorite (note) in the admin database for this specific user.
    $.ajax({
        type: "post",
        url: "/webgl-viewer/saveusernote",
        data: {"note": JSON.stringify(note.Serialize(true)),
               "thumb": src,
               "col" : "views",
               "type": "Favorite"},//"favorites"
        success: function(data,status) {
            FAVORITES_WIDGET.FavoritesBar.LoadFavorites();
        },
        error: function() {
            saDebug( "AJAX - error() : saveusernote 2" );
        },
    });
}

// Randomize the order of the children
NotesWidget.prototype.RandomCallback = function() {
  var note = this.GetCurrentNote();
  note.Children.sort(function(a,b){return Math.random() - 0.5;});
  note.UpdateChildrenGUI();
}

// Called when a new slide/view is loaded.
NotesWidget.prototype.DisplayRootNote = function() {
    this.TextEditor.LoadNote(this.RootNote);
    this.LinksRoot.empty();
    this.RootNote.DisplayGUI(this.LinksRoot);
    this.SelectNote(this.RootNote);

    // Add an obvious way to add a link / view to the root note.
    if (SA.Edit) {
        var self = this;
        this.AddViewButton
            .appendTo(this.LinksDiv)
            .click(function () {
                var parentNote = SA.notesWidget.RootNote;
                var childIdx = parentNote.Children.length;
                var childNote = parentNote.NewChild(childIdx, "New View");
                // Setup and save
                childNote.RecordView(self.Display);
                // We need to save the note to get its Id (for the link div).
                childNote.Save();
                parentNote.UpdateChildrenGUI();
                this.Display.SetNote(childNote);
                //self.SelectNote(childNote);
            });
    }
    // Default to old style when no text exists (for backward compatability).
    if (this.RootNote.Text == "") {
        this.TabbedWindow.ShowTabDiv(this.LinksDiv);
    } else {
        this.TabbedWindow.ShowTabDiv(this.TextDiv);
    }
}

// Add a user note to the currently selected notes children.
NotesWidget.prototype.NewCallback = function() {
    var note = this.GetCurrentNote();
    var childIdx = 0;
    if (note.Parent) {
        var idx = note.Children.indexOf(note);
        if (idx >= 0) {
            childIdx = idx+1;
            note = note.Parent;
        }
    }
    // Create a new note.
    var childNote = note.NewChild(childIdx, "New View");
    // Setup and save
    childNote.RecordView(this.Display);
    //childNote.Save();
    note.UpdateChildrenGUI();

    note.Save();
    //this.SelectNote(childNote);
    this.Display.SetNote(childNote);
}

// UserNotes used to be attached to a parent note.  Now I am indexing them
// from the image id.  They will not get lost, but this causes a could
// issues.  I do not support multiple user notes per image.  I have to be
// careful about infinte recursion when loading. I am only going to display
// the note for the first image in the root note. (I can rethink this last
// decision later.)
// Maybe we should store the image id directly in the user not instead of
// the viewerRecord.
NotesWidget.prototype.RequestUserNote = function(imageId) {
    var self = this;
    $.ajax({
        type: "get",
        url: "/webgl-viewer/getusernotes",
        data: {"imageid": imageId},
        success: function(data,status) { self.LoadUserNote(data, imageId);},
        error: function() { saDebug( "AJAX - error() : getusernotes" ); },
    });
}


// Note will not be active until it has a note.
// Edit to a previous note are saved before it is replaced.
NotesWidget.prototype.LoadUserNote = function(data, imageId) {
    if (this.UserNote) {
        // Save the previous note incase the user is in mid edit????
        if (this.UserNote.Text != "" || this.UserNote.Children.length > 0) {
            this.UserNote.Save();
        }
    }
    this.UserNote = new SA.Note();

    if (data.Notes.length > 0) {
        if (data.Notes.length > 1) {
            saDebug("Warning: Only showing the first user note.");
        }
        var noteData = data.Notes[0];
        this.UserNote.Load(noteData);
    } else {
        // start with a copy of the current note.
        // The server searches viewer records for the image.
        // Only copoy the first viewer records.  More could be problematic.
        var note = this.GetCurrentNote();
        if (note && note.ViewerRecords.length > 0) {
            var record = new SA.ViewerRecord();
            record.DeepCopy(note.ViewerRecords[0]);
            this.UserNote.ViewerRecords.push(record);
        }
    }

    // This is new, Parent was always a note before this.
    // Although this is more robust (user notes are constent when notes are
    // copied...), the GUI looks like user notes are associated with notes
    // not viewerRecords/images.
    this.UserNote.Parent = imageId;
    this.UserNote.Type = "UserNote";

    // Must display the text.
    this.UserTextEditor.LoadNote(this.UserNote);
    // User notes are always editable. Unless it tis the demo account.
    if (SA.User != "") {
        this.UserTextEditor.EditOn();
    }
}

    SA.NotesWidget = NotesWidget;

})();



// Tabbed gui.

// Closure namespace
Tab = (function () {

    var Tabs = [];

    // If a tabbed object is specified, only one tab for the object
    // will be allowed open at a time.
    function Tab (parent,imageSrc, tabID) {
        var self = this; // trick to set methods in callbacks.
        if ( ! parent) { alert("null parent: tab"); }
        parent = parent || SA.MainDiv;

        this.Div = $('<div>')
            .appendTo(parent)
            .attr('id', tabID)
            .addClass('sa-view-div');

        // Button has to have the border (not the tab) to be covered by Div.
        this.Button = $('<img>')
            .appendTo(this.Div)
            .attr('type','image')
            .attr('src',imageSrc)
            .addClass("sa-view-button")
            .click(function(){self.TogglePanel();})
            .attr('draggable','false')
            .on("dragstart", function() {
                return false;});


        this.Panel = $('<div>')
            .appendTo(this.Div)
            .hide()
            .addClass("sa-view-panel");

        Tabs.push(this);

        // I need to maintain this state even when the whole tab is not
        // visible.
        this.PanelOpen = false;
    }


    Tab.prototype.show = function() {
        this.Div.show();
    }
    Tab.prototype.hide = function() {
        this.Div.hide();
    }


    Tab.prototype.TogglePanel = function() {
        if (this.PanelOpen) {
            this.PanelOff();
        } else {
            this.PanelOn();
        }
    }


    Tab.prototype.PanelOn = function() {
        if (this.PanelOpen) { return; }
        this.PanelOpen = true;

        // position returns 0 if panel is hidden.
        this.Panel.show();

        // Close tabs that overlap.
        var minX0 = this.Panel.offset().left;
        var maxX0 = minX0 + this.Panel.outerWidth();
        for (var i = 0; i < Tabs.length; ++i) {
            if (Tabs[i] !== this) {
                var minX1 = Tabs[i].Panel.offset().left;
                var maxX1 = minX1 + Tabs[i].Panel.outerWidth();
                // Overlap
                minX1 = Math.max(minX0,minX1);
                maxX1 = Math.min(maxX0,maxX1);
                if (minX1 < maxX1) {
                    Tabs[i].PanelOff();
                }
            }
        }

        // Make the tab look like it is part of the panel.
        this.Button.addClass("sa-active")
    }

    Tab.prototype.PanelOff = function() {
        this.PanelOpen = false;
        this.Panel.hide();
        this.Button.removeClass("sa-active")
    }



    // Export the tab object.
    return Tab;
})();
    
    

// Annotation widget toggles annotation visibility and also shows the drawing tools.
// Each view will need its own widget.
// I am less happy about this than the right click menu implementation.
// It would be nice to expand the drawing tools on hover, but
// the toggle for annotation visibiity naturally suggests
// the same state should show drawing tool palette.

// Todo:
// - Make an object out of it to support two views.
// - Change behavior of text widget to first drag an arrow when created.
// - eliminate polyLine verticies when they are dragged ontop of another vert.
// or maybe the delete key.

function AnnotationWidget (layer, viewer) {
    var self = this; // trick to set methods in callbacks.
    this.Viewer = viewer;
    this.Layer = layer;
    layer.AnnotationWidget = this;

    this.Tab = new Tab(layer.GetCanvasDiv(),
                       SA.ImagePathUrl+"pencil3Up.png",
                       "annotationTab");
    this.Tab.Div
        .css({'box-sizing':'border-box',
              'position':'absolute',
              'bottom':'0px',
              'right':'110px'})
        .prop('title', "Annotation");

    this.Tab.Panel.addClass("sa-view-annotation-panel");
    this.VisibilityDiv = $('<div>')
        .appendTo(this.Tab.Panel)
        .addClass("sa-view-annotation-vis")
        .prop('title', "Visibility")
        .click(function(){self.ToggleVisibility();});
    this.VisibilityImage = $('<img>')
        .appendTo(this.VisibilityDiv)
        .addClass('sa-view-annotation-vis-img')
        .addClass('sa-active')
        .attr('type','image')
        .attr('src',SA.ImagePathUrl+"toggleswitch.jpg");

    this.TextButton = $('<img>')
        .appendTo(this.Tab.Panel)
        .addClass("sa-view-annotation-button sa-flat-button-active")
        .addClass('sa-active')
        .attr('type','image')
        .attr('src',SA.ImagePathUrl+"Text.gif")
        .prop('title', "Text")
        .click(function(){self.NewText();});
    this.CircleButton = $('<img>')
        .appendTo(this.Tab.Panel)
        .addClass("sa-view-annotation-button sa-flat-button-active")
        .addClass('sa-active')
        .attr('type','image')
        .attr('src',SA.ImagePathUrl+"Circle.gif")
        .prop('title', "Circle")
        .click(function(){self.NewCircle();});
    /*
    this.RectButton = $('<img>')
        .appendTo(this.Tab.Panel)
        .addClass("sa-view-annotation-button sa-flat-button-active")
        .addClass('sa-active')
        .attr('type','image')
        .attr('src',SA.ImagePathUrl+"rectangle.gif")
        .prop('title', "Rectangle")
        .click(function(){self.NewRect();});
    */
    this.GridButton = $('<img>')
        .appendTo(this.Tab.Panel)
        .addClass("sa-view-annotation-button sa-flat-button-active")
        .addClass('sa-active')
        .attr('type','image')
        .attr('src',SA.ImagePathUrl+"grid.png")
        .prop('title', "Grid")
        .click(function(){self.NewGrid();});
    this.PolylineButton = $('<img>')
        .appendTo(this.Tab.Panel)
        .addClass("sa-view-annotation-button sa-flat-button-active")
        .addClass('sa-active')
        .attr('type','image')
        .attr('src',SA.ImagePathUrl+"FreeForm.gif")
        .prop('title', "Polygon")
        .click(function(){self.NewPolyline();});
    this.PencilButton = $('<img>')
        .appendTo(this.Tab.Panel)
        .addClass("sa-view-annotation-button sa-flat-button-active")
        .addClass('sa-active')
        .attr('type','image')
        .prop('title', "Pencil")
        .attr('src',SA.ImagePathUrl+"Pencil-icon.jpg")
        .click(function(){self.NewPencil();});
    this.LassoButton = $('<img>')
        .appendTo(this.Tab.Panel)
        .addClass("sa-view-annotation-button sa-flat-button-active")
        .addClass('sa-active')
        .attr('type','image')
        .attr('src',SA.ImagePathUrl+"select_lasso.png")
        .prop('title', "Lasso")
        .click(function(){self.NewLasso();});
    if (this.Viewer) {
        this.SectionsButton = $('<img>')
            .appendTo(this.Tab.Panel)
            .addClass("sa-view-annotation-button sa-flat-button-active")
            .addClass('sa-active')
            .attr('type','image')
            .attr('src',SA.ImagePathUrl+"sections.png")
            .prop('title', "Segment")
            .click(function(){self.DetectSections();});
    }
    /*
    this.FillButton = $('<img>')
        .appendTo(this.Tab.Panel)
        .css({'height': '28px',
              'opacity': '0.6',
              'margin': '1px',
              'border-style': 'outset',
              'border-radius': '4px',
              'border-thickness':'2px'})
        .attr('type','image')
        .attr('src',SA.ImagePathUrl+"brush1.jpg")
        .click(function(){self.NewFill();});
        */
}

// Show hide the tool tab button
AnnotationWidget.prototype.show = function() {
    this.Tab.show()
}

AnnotationWidget.prototype.hide = function() {
    this.Tab.hide()
}

AnnotationWidget.prototype.SetVisibility = function(visibility) {
    if (this.Layer.GetVisibility() == visibility) {
        return;
    }

    // Hack to make all stack viewers share a single annotation visibility
    // flag.
    if (SA.notesWidget) {
        var note = SA.notesWidget.GetCurrentNote();
        if (note.Type == 'Stack') {
            for (var i = 0; i < note.ViewerRecords.length; ++i) {
                note.ViewerRecords[i].AnnotationVisibility = visibility;
            }
        }
    }

    if (this.VisibilityImage) {
        if (visibility == ANNOTATION_OFF) {
            this.VisibilityImage.css({'top': '-30px'});
        } else {
            this.VisibilityImage.css({'top': '1px'});
        }
    }

    this.Layer.SetVisibility(visibility);
    this.Layer.EventuallyDraw();
}

AnnotationWidget.prototype.GetVisibility = function() {
  return this.Layer.GetVisibility();
}

AnnotationWidget.prototype.ToggleVisibility = function() {
    var vis = this.GetVisibility();
    if (vis == ANNOTATION_OFF) {
        vis = ANNOTATION_ON;
    } else {
        vis = ANNOTATION_OFF;
    }
    this.SetVisibility( vis );
    RecordState();
}



AnnotationWidget.prototype.TogglePanel = function() {
    this.Panel.toggle();
    if (this.Panel.is(":visible")) {
        this.TabButton.addClass("sa-active");
    } else {
        // Should we deactivate any active widget tool?
        this.TabButton.removeClass("sa-active");
    }
}







// I would like to change the behavior of this.
// First slide the arrow, then pop up the dialog to set text.
AnnotationWidget.prototype.NewText = function() {
    var button = this.TextButton;
    var widget = this.ActivateButton(button, SAM.TextWidget);
    // The dialog is used to set the initial text.
    widget.ShowPropertiesDialog();
}

// Probably want a singleton pencil.
AnnotationWidget.prototype.NewPencil = function() {
    var button = this.PencilButton;
    var widget = this.ActivateButton(button, SAM.PencilWidget);
}

AnnotationWidget.prototype.NewLasso = function() {
    var button = this.LassoButton;
    var widget = this.ActivateButton(button, SAM.LassoWidget);
}

AnnotationWidget.prototype.NewPolyline = function() {
    var button = this.PolylineButton;
    var widget = this.ActivateButton(button, SAM.PolylineWidget);
}

AnnotationWidget.prototype.NewCircle = function() {
    var button = this.CircleButton;
    var widget = this.ActivateButton(button, SAM.CircleWidget);
    // Use the mouse position to place the circle.
    // Mouse in under button.  Should we put the cirlce in the middle?
    widget.Shape.Origin = this.Layer.GetCamera().ConvertPointViewerToWorld(
        this.Layer.LastMouseX,
        this.Layer.LastMouseY);
}

AnnotationWidget.prototype.NewRect = function() {
    var button = this.RectButton;
    var widget = this.ActivateButton(button, SAM.RectWidget);
    // DJ: Make sure the rect is around the circle
    widget.Shape.Origin = this.Layer.GetCamera().ConvertPointViewerToWorld(
        this.Layer.LastMouseX,
        this.Layer.LastMouseY);
};

AnnotationWidget.prototype.NewGrid = function() {
    var button = this.GridButton;
    var widget = this.ActivateButton(button, SAM.GridWidget);
    var cam = this.Layer.GetCamera();
    var fp = cam.GetFocalPoint();
    // Square grid elements determined by height
    var height = cam.GetHeight() * 0.75;
    var yDim = 5;
    var size = height / yDim;
    var width = cam.GetWidth() * 0.75;
    var xDim = Math.floor(width/size);
    widget.Grid.Origin = [fp[0], fp[1], 0.0];
    widget.Grid.Orientation = cam.GetRotation();
    this.Layer.DeactivateWidget(widget);
};

AnnotationWidget.prototype.NewFill = function() {
    var button = this.FillButton;
    var widget = this.ActivateButton(button, SAM.FillWidget);
    widget.Initialize();
}


// Boilerplate code that was in every "newWidget" method.
AnnotationWidget.prototype.ActivateButton = function(button, WidgetFunction) {
    var widget = this.Layer.ActiveWidget;
    if ( widget ) {
        if  (button.Pressed) {
            // The user pressed the button again (while it was active).
            widget.Deactivate();
            return;
        }
        // This call sets pressed to false as a side action..
        widget.Deactivate();
    }
    button.Pressed = true;
    button.addClass("sa-active");

    this.SetVisibility(ANNOTATION_ON);
    widget = new WidgetFunction(this.Layer, true);
    this.Layer.ActivateWidget(widget);

    // Button remains "pressed" until the circle deactivates.
    widget.DeactivateCallback = 
        function () {
            button.removeClass("sa-active");
            widget.DeactivateCallback = undefined;
            button.Pressed = false;
        }
    return widget;
}


AnnotationWidget.prototype.DetectSections = function() {
    var widget = this.Layer.GetActiveWidget();
    var button = this.SectionsButton;
    if ( widget ) {
        if  (button.Pressed) {
            // The user pressed the button again (while it was active).
            widget.Deactivate();
            return;
        }
        // This call sets pressed to false as a side action.
        widget.Deactivate();
    }
    button.Pressed = true;
    button.addClass("sa-active");

    // See if a SectionsWidget already exists.
    var widget = null;
    var widgets = this.Layer.GetWidgets();
    for (var i = 0; i < widgets.length && widget == null; ++i) {
        var w = widgets[i];
        //if (w instanceOf SectionsWidget) {
        if (w.Type == "sections") {
            widget = w;
        }
    }
    if (widget == null) {
        // Find sections to initialize sections widget.
        widget = new SAM.SectionsWidget(this.Viewer, false);
        widget.ComputeSections();
        if (widget.IsEmpty()) {
            this.Layer.RemoveWidget(widget);
            button.removeClass('sa-active');
            button.Pressed = false;
            return;
        }
    }

    widget.SetActive(true);
    widget.DeactivateCallback = 
        function () {
            button.removeClass('sa-active');
            widget.DeactivateCallback = undefined;
            button.Pressed = false;
        }
}
// This "widget" implements undo and redo as well as saving states in the database for a recording of a session.
// I save the recording state as a cookie so that the user can change slides or even sessions.
// I am going to have a separate recording collection.
// Each recording will be a single object.
// They will be tagged with start time, end time, user ID and a name (autogenerated or entered by user).


// NOTES:
//I will have to think about this ...
//save state vs. save delta state.
//State is simple .... Supports undo better .... Start with this.

// Maybe students can link to the instructor recording session.  The could add notes which are added to the recording.

// It might be nice to know where the mouse is pointing at all times.  We need a pointing tool. That is many events though.  LATER....

// Design issue:
// Should I save the state at the end of a move or the beginning?  I chose end.  Although beginning is easier,
// I like just popping the last state off the TIME_LINE and pushing to the REDO_STACK


//------------------------------------------------------------------------------
// Records are now being used for notes.  Since page record may contain
// information about current note, I am using ViewerRecord as a shared object.

var RECORDER_WIDGET = null;


(function () {
    "use strict";


function ViewerRecord () {
    this.AnnotationVisibility = 0;
    this.Annotations = [];
}

// For copy slide in presentatations.  Serialize / load messup image.
ViewerRecord.prototype.DeepCopy = function(source) {
    this.AnnotationVisibility = source.AnnotationVisibility;
    this.Annotations = JSON.parse(JSON.stringify(source.Annotations));
    this.Camera = new Camera();
    this.Camera.DeepCopy(source.Camera);
    this.Image = source.Image;
    this.OverviewBounds = source.OverviewBounds.slice(0);
}

// I am still trying to figure out a good pattern for loading
// objects from mongo.
// Cast to a ViewerObject by setting its prototype does not work on IE
ViewerRecord.prototype.Load = function(obj) {
    if ( ! obj.Camera) {
        var bds = obj.Image.bounds;
        if (bds) {
            obj.Camera = {FocalPoint: [(bds[0]+bds[1])/2, (bds[2]+bds[3])/2],
                          Height: bds[3]-bds[2],
                          Width: bds[1]-bds[0],
                          Roll: 0};
        }
    }

    var ivar;
    for (ivar in obj) {
        this[ivar] = obj[ivar];
    }

    if ( this.Camera.Width === undefined) {
        this.Camera.Width = this.Camera.Height * 1.62;
    }

    // Stuck with Overview because it is in the database.
    if (! this.OverviewBounds) {
        this.OverviewBounds = this.Image.bounds;
    }

    if (this.Annotations) {
        for (var i = 0; i < this.Annotations.length; ++ i) {
            var a = this.Annotations[i];
            if (a && a.color) {
                a.color = SAM.ConvertColor(a.color);
            }
        }
    }

    if (this.Transform) {
        var t = new PairTransformation;
        t.Load(this.Transform);
        this.Transform = t;
    }
}


ViewerRecord.prototype.CopyViewer = function (viewer) {
    var cache = viewer.GetCache();
    if ( ! cache) {
        this.Camera = null;
        this.AnnotationVisibility = false;
        this.Annotations = [];
        return;
    }

    this.OverviewBounds = viewer.GetOverViewBounds();

    this.OverviewBounds = viewer.GetOverViewBounds();
    this.Image = cache.Image;
    this.Camera = viewer.GetCamera().Serialize();

    this.AnnotationVisibility = viewer.GetAnnotationLayer().GetVisibility();
    this.Annotations = [];

    var widgets = viewer.GetAnnotationLayer().GetWidgets();
    for (var i = 0; i < widgets.length; ++i) {
        this.Annotations.push(widgets[i].Serialize());
    }
}

// For stacks.  A reduced version of copy view. 
ViewerRecord.prototype.CopyAnnotations = function (viewer) {
    this.Annotations = [];
    var widgets = viewer.GetAnnotationLayer().GetWidgets();
    for (var i = 0; i < widgets.length; ++i) {
        var o = widgets[i].Serialize();
        if (o) {
            this.Annotations.push(o);
        }
    }
}

// I am not sure we need to serialize.  
// The annotations are already in database form.
// Possibly we need to restrict which ivars get into the database.
ViewerRecord.prototype.Serialize = function () {
    var rec = {};
    rec.Image = this.Image._id;
    rec.Database = this.Image.database;
    rec.NumberOfLevels = this.Image.levels;
    rec.Camera = this.Camera;
    // deep copy
    if ( this.Annotations) {
        rec.Annotations = JSON.parse(JSON.stringify(this.Annotations));
    }
    rec.AnnotationVisibility = this.AnnotationVisibility;

    if (this.OverviewBounds) {
        rec.OverviewBounds = this.OverviewBounds;
    }

    if (this.Transform) {
        rec.Transform = this.Transform.Serialize();
    }

    return rec;
}


ViewerRecord.prototype.Apply = function (viewer) {
    viewer.Reset();
    // If a widget is active, then just inactivate it.
    // It would be nice to undo pencil strokes in the middle, but this feature will have to wait.
    if (viewer.ActiveWidget) {
        // Hackish way to deactivate.
        viewer.ActiveWidget.SetActive(false);
    }

    var cache = viewer.GetCache();
    if ( ! cache || this.Image._id != cache.Image._id) {
        var newCache = SA.FindCache(this.Image);
        viewer.SetCache(newCache);
    }

    viewer.SetOverViewBounds(this.OverviewBounds);

    if (this.Camera !== undefined && this.Transform === undefined) {
        var cameraRecord = this.Camera;
        viewer.GetCamera().Load(cameraRecord);
        if (viewer.OverView) {
            viewer.OverView.Camera.Roll = cameraRecord.Roll;
            viewer.OverView.Camera.ComputeMatrix();
        }
        viewer.UpdateZoomGui();
        viewer.UpdateCamera();
    }

    // TODO: Get rid of this hack.
    if (viewer.AnnotationWidget && this.AnnotationVisibility != undefined) {
        viewer.AnnotationWidget.SetVisibility(this.AnnotationVisibility);
    }
    if (this.Annotations != undefined && viewer.AnnotationLayer) {
        // TODO: Fix this.  Keep actual widgets in the records / notes.
        // For now lets just do the easy thing and recreate all the
        // annotations.
        viewer.AnnotationLayer.Reset();
        for (var i = 0; i < this.Annotations.length; ++i) {
            var widget = viewer.AnnotationLayer.LoadWidget(this.Annotations[i]);
            if (! widget) {
                // Get rid of corrupt widgets that do not load properly
                this.Annotations.splice(i,1);
                --i;
            }
        }
    }

    // fit the canvas to the div size.
    viewer.UpdateSize();
}

// This is a helper method to start preloading tiles for an up coming view.
ViewerRecord.prototype.LoadTiles = function (viewport) {
    var cache = SA.FindCache(this.Image);
    // TODO:  I do not like the fact that we are keeping a serialized
    // version of the camera in the record object.  It should be a real 
    // camera that is serialized when it is saved.
    var cam = new Camera();
    cam.Load(this.Camera);
    cam.SetViewport(viewport);
    cam.ComputeMatrix();

    // Load only the tiles we need.
    var tiles = cache.ChooseTiles(cam, 0, []);
    for (var i = 0; i < tiles.length; ++i) {
        LoadQueueAddTile(tiles[i]);
    }
}

    SA.ViewerRecord = ViewerRecord;

})();





function GetTrackingData(){
  $.ajax({
    type: "get",
    url: "/webgl-viewer/gettrackingdata",
    success: function(data,status){
               if (status == "success") {
                 LoadTrackingCallback(data);
               } else { saDebug("ajax failed - get tracking data"); }
             },
    error: function() { saDebug( "AJAX - error() : gettrackingdata" ); },
    });
}

function LoadTrackingCallback(data){
  alert(data);
}

// legacy
function RecordState() {
    if (RECORDER_WIDGET) {
        RECORDER_WIDGET.RecordState();
    }
}








(function () {
    "use strict";


// display is a set of viewers (like DualViewWidet)
var RecorderWidget = function(display) {
    if ( ! RECORDER_WIDGET) {
        RECORDER_WIDGET = this;
    }
    
    var self = this;
    this.Display = display;
    this.RecordTimerId = 0;
    this.Records;

    this.TimeLine = [];
    this.RedoStack = [];
    this.Recording = true;
    this.RecordingName = "";

    // The recording button indicates that recording is in
    // progress and also acts to stop recording.
    this.RecordButton = $('<img>')
        .appendTo('body')
        .css({
            'opacity': '0.5',
            'position': 'absolute',
            'height': '20px',
            'bottom' : '120px',
            'right' : '20px',
            'z-index': '1'})
        .attr('src',SA.ImagePathUrl+'stopRecording2.png')
        .hide()
        .click(function () {self.RecordingStop()});

    // Optional buttons.  Exposed for testing.
    // Undo (control z) and redo (control y) keys work,
    this.UndoButton = $('<img>').appendTo('body')
        .css({
            'opacity': '0.5',
            'position': 'absolute',
            'height': '30px',
            'bottom' : '5px',
            'right' : '100px',
            'z-index': '1'})
        .attr('src',SA.ImagePathUrl+'undo.png')
        .hide()
        .click(function(){alert("undo");});
    this.RedoButton = $('<img>').appendTo('body').css({
        'opacity': '0.5',
        'position': 'absolute',
        'height': '30px',
        'bottom' : '5px',
        'right' : '70px',
        'z-index': '1'})
        .attr('src',SA.ImagePathUrl+'redo.png')
        .hide()
        .click(function(){alert("REDO");});

    this.RecordingName = getCookie("SlideAtlasRecording");
    if (this.RecordingName != undefined && this.RecordingName != "false") {
        this.Recording = true;
        this.UpdateGUI();
    }

    // We have to start with one state (since we are recording states at the end of a move).
    this.RecordState();
}

// Should we name a recording?
RecorderWidget.prototype.UpdateGUI = function() {
    if (this.Recording) {
        this.RecordButton.show();
    } else {
        this.RecordButton.hide();
    }
}

// Should we name a recording?
RecorderWidget.prototype.RecordingStart = function() {
    if (this.Recording) { return; }
    this.Recording = true;
    // Generate a recording name as a placeholder.
    // User should be prompted for a name when recording stops.
    var d = new Date();
    this.RecordingName = "Bev" + d.getTime();
    setCookie("SlideAtlasRecording",this.RecordingName,1);
    this.UpdateGUI();
    // Create a new recording object in the database.
    this.RecordState();
}

RecorderWidget.prototype.RecordingStop = function() {
    if ( ! this.Recording) { return; }
    this.Recording = false;
    setCookie("SlideAtlasRecording","false",1);
    this.UpdateGUI();
    
    // Prompt for a name and if the user want to keep the recording.
}

RecorderWidget.prototype.RecordStateCallback = function() {
    if (this.Display.GetNumberOfViewers() == 0) {return;}

    // Timer called this method.  Timer id is no longer valid.
    this.RecordTimerId = 0;
    // Redo is an option after undo, until we save a new state.
    this.RedoStack = [];

    // Create a new note.
    var note = new SA.Note();
    // This will probably have to be passed the viewers.
    note.RecordView(this.Display);

    // The note will want to know its context
    // The stack viewer does not have  notes widget.
    if (SA.DualDisplay) {
        var parentNote = SA.DualDisplay.GetNote();
        if ( ! parentNote || ! parentNote.Id) {
            //  Note is not loaded yet.
            // Wait some more
            this.RecordState();
            return;
        }
        // ParentId should be depreciated.
        note.ParentId = parentNote.Id;
        note.SetParent(parentNote);
    }
    // Save the note in the admin database for this specific user.
    $.ajax({
        type: "post",
        url: "/webgl-viewer/saveusernote",
        data: {"note": JSON.stringify(note.Serialize(true)),
               "col" : "tracking",
               "type": "Record"},
        success: function(data,status) {
            note.Id = data;
        },
        error: function() {
            //saDebug( "AJAX - error() : saveusernote" );
        },
    });

    this.TimeLine.push(note);
}


// Create a snapshot of the current state and push it on the TIME_LINE stack.
// I still do not compress scroll wheel zoom, so I am putting a timer event
// to collapse recording to lest than oner per second.
RecorderWidget.prototype.RecordState = function() {
    if (this.Display.GetNumberOfViewers() == 0) {return;}
    // Delete the previous pending record timer
    if (this.RecordTimerId) {
        clearTimeout(this.RecordTimerId);
        this.RecordTimerId = 0;
    }
    // Start a record timer.
    var self = this;
    this.RecordTimerId = setTimeout(
        function(){ self.RecordStateCallback();}, 
        1000);
}

RecorderWidget.prototype.GetRecords = function() {
    var self = this;
    $.ajax({
        type: "get",
        url: "/webgl-viewer/getfavoriteviews",
        data: {"col" : "tracking"},
        success: function(data,status) {
            self.Records = data.viewArray;
        },
        error: function() {
            saDebug( "AJAX - error() : get records" );
        },
    });
}


// Create a snapshot of the current state and push it on the TIME_LINE stack.
// I still do not compress scroll wheel zoom, so I am putting a timer event
// to collapse recording to lest than oner per second.
RecorderWidget.prototype.RecordState = function() {
    // Delete the previous pending record timer
    if (this.RecordTimerId) {
        clearTimeout(this.RecordTimerId);
        this.RecordTimerId = 0;
    }
    // Start a record timer.
    var self = this;
    this.RecordTimerId = setTimeout(function(){self.RecordStateCallback();}, 1000);
}


// Move the state back in time.
RecorderWidget.prototype.UndoState = function () {
    if (this.TimeLine.length > 1) {
        // We need at least 2 states to undo.  The last state gets removed,
        // the second to last get applied.
        var recordNote = this.TimeLine.pop();
        this.RedoStack.push(recordNote);

        // Get the new end state
        recordNote = this.TimeLine[this.TimeLine.length-1];
        // Now change the page to the state at the end of the timeline.
        recordNote.DisplayView();
    }
}

// Move the state forward in time.
RecorderWidget.prototype.RedoState = function() {
    if (this.RedoState.length == 0) {
        return;
    }
    var recordNote = this.RedoStack.pop();
    this.TimeLine.push(recordNote);

    // Now change the page to the state at the end of the timeline.
    recordNote.DisplayView();
}


    SA.RecorderWidget = RecorderWidget;

})();
// VCR like buttons to get to next/previous note/slide.
// entwined with the notes widget at the moment.


//------------------------------------------------------------------------------
// I intend to have only one object
function NavigationWidget(parent,display) {
    this.Display = display;

   // Load the session slides from the localStorage
    this.SlideIndex = 0;
    this.Session = [];
    this.NoteIterator = new NoteIterator();

    var self = this;
    var size = '40px';
    var left = '170px';
    var bottom = '10px';
    if (MOBILE_DEVICE) {
        // fake a tab
        this.Tab = {};
        this.Tab.Panel = $('<div>')
            .appendTo(display.GetViewer(0).GetDiv())
            .hide()
            //.addClass("sa-view-navigation-div ui-responsive");
            .addClass("ui-responsive")
            .css({'position': 'absolute',
                  'left': '50px',
                  'bottom': '20px',
                  'z-index': '5'});
        var panel = this.Tab.Panel;
        this.Tab.show = function () {panel.show();}
        this.Tab.hide = function () {
            panel.hide();
        }
        //SA.OnStartInteraction( function () { panel.hide();} );
    } else {
        this.Tab = new Tab(parent,SA.ImagePathUrl+"nav.png", "navigationTab");
        this.Tab.Div.prop('title', "Navigation");
        this.Tab.Div.addClass("sa-view-navigation-div");
        this.Tab.Panel.addClass("sa-view-navigation-panel");

        // Put the stack display in the navigation button
        this.NoteDisplay = $('<div>')
            .appendTo(this.Tab.Div)
            .addClass("sa-view-note")
            .html("");
    }

    this.PreviousSlideButton =
        $('<img>').appendTo(this.Tab.Panel)
        .addClass("sa-view-navigation-button")
        .attr('src',SA.ImagePathUrl+"previousSlide.png")
        .prop('title', "Previous Slide. (page-up)")
        .click(function(){self.PreviousSlide();});

    this.PreviousNoteButton =
        $('<img>').appendTo(this.Tab.Panel)
        .addClass("sa-view-navigation-button")
        .attr('src',SA.ImagePathUrl+"previousNote.png")
        .prop('title', "Previous Note. (p)")
        .click(function(){self.PreviousNote();});

    this.NextNoteButton =
        $('<img>').appendTo(this.Tab.Panel)
        .addClass("sa-view-navigation-button")
        .attr('src',SA.ImagePathUrl+"nextNote.png")
        .prop('title',"Next Note, (n, space)")
        .click(function(){self.NextNote();});

    this.NextSlideButton =
        $('<img>').appendTo(this.Tab.Panel)
        .addClass("sa-view-navigation-button")
        .attr('src',SA.ImagePathUrl+"nextSlide.png")
        .prop('title',"Next Slide. (page-down)")
        .click(function(){self.NextSlide();});

    // TODO: Fix the main css file for mobile.  Hack this until fixed.
    if (MOBILE_DEVICE) {
        size = '80px';
        if (MOBILE_DEVICE == "iPhone") {
            size = '100px';
        }
        this.PreviousSlideButton
            .css({'height': size,
                  'width' : size,
                  'opacity':'0.8'})
            .on('touchend', function(){self.PreviousSlide();});
        this.PreviousNoteButton
            .css({'height': size,
                  'width' : size,
                  'opacity':'0.8'})
            .on('touchend', function(){self.PreviousNote();});
        this.NextNoteButton
            .css({'height': size,
                  'width' : size,
                  'opacity':'0.8'})
            .on('touchend', function(){self.NextNote();});
        this.NextSlideButton
            .css({'height': size,
                  'width' : size,
                  'opacity':'0.8'})
            .on('touchend', function(){self.NextSlide();});
    }

    this.CopyrightWrapper =
        $('<div>').appendTo(parent)
        .css({
            'width': '100%',
            'text-align': 'center'
        }).html();
}

NavigationWidget.prototype.SetInteractionEnabled = function(flag) {
    var self = this;
    if (flag) {
        this.Display.Parent.on(
            'keydown.navigation',
            function (event) {
                return self.HandleKeyDown(event);
            });
    } else {
        this.Display.Parent.off('keydown.navigation');
    }
}

NavigationWidget.prototype.HandleKeyDown = function(event) {
    keyCode = event.keyCode;
    // 34=page down, 78=n, 32=space
    if (keyCode == 34) {
        this.NextSlide();
        return false;
    }
    if (keyCode == 78 || keyCode == 32) {
        this.NextNote();
        return false;
    }
    // 33=page up, 80=p
    if (keyCode == 33) {
        this.PreviousSlide();
        return false;
    }
    if (keyCode == 80) {
        this.PreviousNote();
        return false;
    }

    return true;
}

NavigationWidget.prototype.SetNote = function(note) {
    var self = this;
    if ( ! this.SessionId) {
        if (SA.Session) {
            this.Session = SA.Session.session.views;
            this.SessionId = SA.Session.sessid;
            this.Update();
        } else if (note.SessionId && SA.RootNote.Type != "HTML") {
            this.SessionId = note.SessionId;
            $.ajax({
                type: "get",
                url: SA.SessionUrl+"?json=true&sessid="+this.SessionId,
                success: function(data,status) {
                    if (self.SessionId != data.sessid) {
                        // This will never happen.
                        console.log("expecting a second session to load.");
                        return;
                    }
                    self.Session = data.session.views;
                    self.Update();
                },
                error: function() {
                    saDebug("AJAX - error() : session" );
                },
            });
        }
    } else {
        // Correct an error.  SessionId's are wrong because the
        // notes sessionId is not being updated when a session is
        // copied.
        note.SessionId = this.SessionId;
    }

    this.NoteIterator.SetNote(note);
    this.Update();
}

NavigationWidget.prototype.GetNote = function() {
    return this.NoteIterator.GetNote();
}

NavigationWidget.prototype.ToggleVisibility = function() {
    this.SetVisibility( ! this.Visibility);
}

// Used on mobile.
NavigationWidget.prototype.SetVisibility = function(v) {
    this.Visibility = v;
    if (v) {
        this.Tab.show();
    } else {
        this.Tab.hide();
    }
}

NavigationWidget.prototype.Update = function() {
    // Disable prev/next note buttons by default.
    this.PreviousNoteButton.removeClass("sa-active");
    this.NextNoteButton.removeClass("sa-active");
    var note = this.NoteIterator.GetNote();
    if (note) {
        for (var i = 0; i < this.Session.length; ++i) {
            if (this.Session[i].id == note.Id) {
                this.SlideIndex = i;
            }
        }

        if (note.Type == "Stack") {
            // Next note refers to ViewerRecords.
            if (note.StartIndex > 0) {
                this.PreviousNoteButton.addClass("sa-active");
            }
            if (note.StartIndex < note.ViewerRecords.length - 1) {
                this.NextNoteButton.addClass("sa-active");
            }
        } else {
            // Next note refers to children.
            if ( ! this.NoteIterator.IsStart()) {
                this.PreviousNoteButton.addClass("sa-active");
            }
            if ( ! this.NoteIterator.IsEnd()) {
                this.NextNoteButton.addClass("sa-active");
            }
        }
    }

    // Disable and enable prev/next slide buttons so we cannot go past the end.
    if (this.SlideIndex <= 0) {
        this.PreviousSlideButton.removeClass("sa-active");
    } else {
        this.PreviousSlideButton.addClass("sa-active");
    }
    if (this.SlideIndex >= this.Session.length-1) {
        this.NextSlideButton.removeClass("sa-active");
    } else {
        this.NextSlideButton.addClass("sa-active")
    }

    // Hack because next slide does not with presentations.
    if (SA.RootNote && SA.RootNote.Type == "HTML") {
        this.PreviousSlideButton.removeClass("sa-active");
        this.NextSlideButton.removeClass("sa-active");
    }

}

NavigationWidget.prototype.PreviousNote = function() {
    SA.StackCursorFlag = false;

    var current = this.NoteIterator.GetNote();
    if (current.Type == "Stack") {
        if (current.StartIndex <= 0) { return;}
        // Copy viewer annotation to the viewer record.
        current.RecordAnnotations(this.Display);

        // Move camera
        // Hardcoded for dual display
        var viewer1 = this.Display.GetViewer(1);
        var viewer0 = this.Display.GetViewer(0);
        var cam = viewer0.GetCamera();
        viewer1.SetCamera(cam.GetFocalPoint(),
                          cam.GetRotation(),
                          cam.Height);

        --current.StartIndex;
        current.DisplayStack(this.Display);
        this.Display.SynchronizeViews(1, current);
        // activate or deactivate buttons.
        this.Update();
        if (this.NoteDisplay) {
            this.NoteDisplay.html("" + current.StartIndex);
        }
        return;
    }

    if (this.NoteIterator.IsStart()) {
        // if not previous notes move to the previous slide
        this.PreviousSlide();
        return;
    }

    // This is such a good idea I am doing it with children notes too.
    // Before everytime a new child was selected, we lost new annotations.
    // Copy viewer annotation to the viewer record.
    current.RecordAnnotations(this.Display);

    var note = this.NoteIterator.Previous();
    // change this so the NotesWidget dows not display the note in the
    // view. Trigger an update the notes widget.
    // TODO: Clean this up. Is a call to display SetNote enough?
    if (SA.DualDisplay) {
        SA.DualDisplay.SetNote(note);
    } else {
        note.DisplayView(this.Display);
    }
}

NavigationWidget.prototype.NextNote = function() {
    SA.StackCursorFlag = false;

    var current = this.NoteIterator.GetNote();
    if (current.Type == "Stack") {
        if (current.StartIndex >= current.ViewerRecords.length - 1) {
            return;
        }
        // Copy viewer annotation to the viewer record.
        current.RecordAnnotations(this.Display);
        // Move camera
        // Hard coded for dual display.
        var viewer0 = this.Display.GetViewer(0);
        var viewer1 = this.Display.GetViewer(1);
        var cam = viewer1.GetCamera();
        viewer0.SetCamera(cam.GetFocalPoint(),
                          cam.GetRotation(),
                          cam.Height);

        ++current.StartIndex;
        current.DisplayStack(this.Display);
        this.Display.SynchronizeViews(0, current);
        // activate or deactivate buttons.
        this.Update();
        if (this.NoteDisplay) {
            this.NoteDisplay.html("" + current.StartIndex);
        }
        return;
    }

    if (this.NoteIterator.IsEnd()) {
        // If we have no more notes, then move to the next slide.
        this.NextSlide();
        return;
    }

    // This is such a good idea I am doing it with children notes too.
    // Before everytime a new child was selected, we lost new annotations.
    // Copy viewer annotation to the viewer record.
    current.RecordAnnotations(this.Display);

    var note = this.NoteIterator.Next();
    // change this so the NotesWidget dows not display the note in the
    // view. Trigger an update the notes widget.
    if (SA.DualDisplay) {
        SA.DualDisplay.SetNote(note);
    } else {
        note.DisplayView(this.Display);
    }
}


NavigationWidget.prototype.PreviousSlide = function() {
    SA.StackCursorFlag = false;
    if (this.SlideIndex <= 0) { return; }
    var check = true;
    if (SA.notesWidget && SA.notesWidget.Modified) {
        check = confirm("Unsaved edits will be lost.  Are you sure you want to move to the next slide?");
    }
    if (check) {
        // TODO: Improve the API here.  Get rid of global access.
        if (SA.notesWidget) {SA.notesWidget.MarkAsNotModified();}
        this.SlideIndex -= 1;
        this.Display.SetNoteFromId(this.Session[this.SlideIndex].id);

        if (this.NoteDisplay) {
            this.NoteDisplay.html("");
        }
    }
}

NavigationWidget.prototype.NextSlide = function() {
    SA.StackCursorFlag = false;
    if (this.SlideIndex >= this.Session.length - 1) { return; }
    var check = true;
    if ( SA.notesWidget && SA.notesWidget.Modified) {
        check = confirm("Unsaved edits will be lost.  Are you sure you want to move to the next slide?");
    }
    if (check) {
        if (SA.notesWidget) {SA.notesWidget.MarkAsNotModified();}
        this.SlideIndex += 1;
        this.Display.SetNoteFromId(this.Session[this.SlideIndex].id);

        if (this.NoteDisplay) {
            this.NoteDisplay.html("");
        }
    }
}

//==============================================================================


//------------------------------------------------------------------------------
// Iterator to perform depth first search through note tree.
// Collapsed branches (children not visible) are not traversed.
// This iterator is a bit over engineered.  I made it so we can subclasses
// that iterate over internal states.  However, internal states require
// notes so I made an array of answers (which are hidden).
function NoteIterator(note) {
    this.Note = note;
    this.ChildIterator = null;
}

// Because of sorting, the child array gets reset on us.
// I need a dynamic way to get the Children array based on the state.
NoteIterator.prototype.GetChildArray = function() {
    if ( ! this.Note) {
        return [];
    }
    return this.Note.Children;
}

// Because of sorting, I have to make the index dynamic
// and it cannot be stored as an ivar.
NoteIterator.prototype.GetChildIndex = function() {
    if (this.ChildIterator == null) {
        return -1;
    }
    return this.GetChildArray().indexOf( this.ChildIterator.Note );
}

// Get the parent note of the current note.
// Notes do not keep a pointer to parents.
// The iterator has this information for active notes.
NoteIterator.prototype.GetParentNote = function() {
    if (this.ChildIterator == null) {
        // We are at the current note.  Let the caller supply the parent.
        return null;
    }

    var parent = this.ChildIterator.GetParentNote();
    if (parent == null) {
        // This level contains the parent.
        parent = this.Note;
    }

    return parent;
}


// We use this to see (peek) if next or previous should be disabled.
NoteIterator.prototype.IsStart = function() {
    if (this.ChildIterator == null) {
        return true;
    }
    return false;
}


NoteIterator.prototype.IsEnd = function() {
    if ( ! this.Note) { return true; }

    // Case note is active.
    if (this.ChildIterator == null) {
        if (this.Note.Children.length > 0 && this.Note.ChildrenVisibility) {
            return false;
        }
        return true;
    }

    // sub answer is active.
    var childIndex = this.GetChildIndex();

    // sub child is active
    if (childIndex == this.GetChildArray().length - 1) {
        return this.ChildIterator.IsEnd();
    }
    return false;
}


// Parent note is traversed before children.
// Move forward one step.  Return the new note. At end the last note returned again.
// IsEnd method used to detect terminal case.
NoteIterator.prototype.Next = function() {
    if ( ! this.Note) { return; }

    // Case 1:  Iterator is on its own node.
    if (this.ChildIterator == null) {
        // Next check for children notes
        if (this.Note.Children.length > 0 && this.Note.ChildrenVisibility) {
            // Move to the first child.
            this.ChildIterator = this.GetChildArray()[0].NewIterator();
            return this.ChildIterator.GetNote();
        }
        // No answers or children: we are at the end.
        return this.Note;
    }

    // Try to advance the child iterator.
    if ( ! this.ChildIterator.IsEnd()) {
        return this.ChildIterator.Next();
    }

    // Child iterator is finished.
    // Try to create a new iterator with the next child in the array.
    var childIndex = this.GetChildIndex();
    if (childIndex < this.GetChildArray().length-1) {
        this.ChildIterator = this.GetChildArray()[childIndex+1].NewIterator();
        return this.ChildIterator.GetNote();
    }

    // We are at the end of the children array.
    return this.ChildIterator.GetNote();
}


// Move backward one step.  See "Next" method comments for description of tree traversal.
NoteIterator.prototype.Previous = function() {
    if ( ! this.Note) { return; }

    if (this.ChildIterator == null) {
        // At start.
        return this.Note;
    }
    if ( ! this.ChildIterator.IsStart()) {
        return this.ChildIterator.Previous();
    }

    // Move to the previous child.
    var childIndex = this.GetChildIndex() - 1;
    if (childIndex >= 0) {
        this.ChildIterator = this.GetChildArray()[childIndex].NewIterator();
        this.ChildIterator.ToEnd();
        return this.ChildIterator.GetNote();
    }

    // No more sub notes left.  Move to the root.
    this.ChildIterator = null;
    return this.Note;
}

// Move the iterator to the start.
NoteIterator.prototype.ToStart = function() {
    if (this.ChildIterator) {
        this.ChildIterator = null;
    }
}

// Move the iterator to the end. Used in Previous method.
NoteIterator.prototype.ToEnd = function() {
    if ( ! this.Note) { return; }

    if (this.Note.Children.length > 0 && this.Note.ChildrenVisibility) {
        this.ChildArray = this.Note.Children;
        var childIndex = this.ChildArray.length - 1;
        this.ChildIterator = this.ChildArray[childIndex].NewIterator();
        return this.ChildIterator.ToEnd();
    }
    // leaf note
    this.ChildArray = null;
    this.ChildIterator = null;
    return this.Note;
}

// If the note is not in the tree, Set the note as root.
// Otherwise, point the iterator to the note in the tree.
NoteIterator.prototype.SetNote = function(note) {
    if (this.GetNote() == note) { return; }
    // See if the note is in the tree.
    this.ToStart();
    while (true) {
        if (this.GetNote() == note) { 
            // Found the note in the tree.
            return; 
        }
        if (this.IsEnd()) {
            // not found.  New tree.
            this.ToStart();
            this.Note = note;
            // BIG Hack here.
            // I got rid of a special SetRootNote call too soon.
            if (SA.notesWidget) {
                SA.notesWidget.SetRootNote(note);
            }
            return;
        }
        this.Next();
    }
}

NoteIterator.prototype.GetNote = function() {
    if (this.ChildIterator != null) {
        return this.ChildIterator.GetNote();
    }
    return this.Note;
}

// VCR like buttons to get to next/previous note/slide.
// entwined with the notes widget at the moment.


//------------------------------------------------------------------------------
// I intend to have only one object
// display is an array of viewers (dualViewWidget now).
function FavoritesWidget(parent, display) {

    this.Tab = new Tab(parent,
                       SA.ImagePathUrl+"star.png",
                       "favorites");
    this.Tab.Div
        .css({'position':'absolute',
              'bottom':'0px',
              'left':'10px'})
        .prop('title', "Annotation");

    this.Tab.Panel
        .css({'position':'absolute',
              'right': '-400px',
              'left' : '-5px',
              'height':'160px'});
        //.addClass("sa-view-favorites-div");

    this.FavoritesBar = new FavoritesBar(this.Tab.Panel, display);

    this.FavoritesBar.LoadFavorites();
}

// Hack: Tabs panels are children of the tab div.
// If I make the tab div width 100%, The other tabs do not receive events.
// The hack solution is to keep the resize.
FavoritesWidget.prototype.HandleResize = function(width){
    this.Tab.Panel
        .css({'left':'-5px',
              'width': (width-20)+'px'});
}











function FavoritesBar(parent, display){
    var self = this;
    this.FavoritesGUI = this;
    this.Display = display;

    this.FavoritesList = parent;

    this.SaveFavoriteButton =
        $('<img>')
        .appendTo(this.FavoritesList)
        .addClass("sa-view-favorites-icon")
        .attr('src',SA.ImagePathUrl+"saveNew.png")
        .click(function(){self.SaveFavorite();});
    this.SaveFavoriteButton.prop('title', "Save Favorite");

    if(MOBILE_DEVICE){
        this.SaveFavoriteButton
            .addClass("sa-view-favorites-button");
    }

    this.ImageList =
        $('<div>')
        .appendTo(this.FavoritesList)
        .addClass("sa-view-favorites-img-list");

    this.LoadFavorites();
}


FavoritesBar.prototype.Hide = function(){
    if( ! this.hidden){
        this.FavoritesList.fadeOut();
        this.hidden = true;
    }
}


FavoritesBar.prototype.ShowHideFavorites = function(){
    if(this.hidden){
        this.FavoritesList.show();
        this.hidden = false;
        var self = this;
        for (var i = 0; i < this.Display.GetNumberOfViewers(); ++i) {
            this.Display.GetViewer(i).OnInteraction( function () { self.Hide();} );
        }
    } else {
        this.FavoritesList.fadeOut();
        this.hidden = true;
    }
}


FavoritesBar.prototype.SaveFavorite = function() {
    SA.notesWidget.SaveBrownNote();
    // Hide shifts the other buttons to the left to fill the gap.
    var button = FAVORITES_WIDGET.FavoritesBar.SaveFavoriteButton;
    button.addClass("sa-inactive");
    setTimeout(function(){ button.removeClass("sa-inactive");},
               500); // one half second
}

FavoritesBar.prototype.LoadFavorites = function () {
    var self = this;
    $.ajax({
        type: "get",
        url: "/webgl-viewer/getfavoriteviews",
        success: function(data,status){
            if (status == "success") {
                self.LoadFavoritesCallback(data);
            } else { saDebug("ajax failed - get favorite views"); }
        },
        error: function() { saDebug( "AJAX - error() : getfavoriteviews" ); },
    });
}

FavoritesBar.prototype.LoadFavoritesCallback = function(sessionData) {
    //var sessionItem = $("[sessid="+sessionData.sessid+"]");
    //var viewList = $('<ul>').appendTo(sessionItem)
    var self = this;

    this.Favorites = sessionData.viewArray;

    this.FavoritesGUI.ImageList.html("");

    //for (var i = 0; i < sessionData.viewArray.length; ++i) {
    for (var i = sessionData.viewArray.length-1; i >= 0; --i) {
        var favorite = $('<div>').appendTo(this.FavoritesGUI.ImageList)
            .addClass("sa-view-favorites-callback-div");

        var thumb = sessionData.viewArray[i].Thumb;

        var view = $('<img>').appendTo(favorite)
            .attr('src', thumb)
            .attr('height', '110px')
            .addClass("sa-view-favorites-callback-img")
            .attr('index', i)
            .click(function(){ self.LoadFavorite(this); });

        var del = $('<div>').appendTo(favorite)
            .html("X")
            .addClass("sa-view-favorites-callback-del")
            .attr('index', i)
            .click(function(){ self.DeleteFavorite(this); });
    }
}

FavoritesBar.prototype.LoadFavorite = function(img){
    var note = new SA.Note();
    var index = $(img).attr('index');
    note.Load(this.Favorites[index]);

    note.DisplayView(SA.DualDisplay);
}

FavoritesBar.prototype.DeleteFavorite = function(img){
    var index = $(img).attr('index');

    $.ajax({
        type: "post",
        url: "/webgl-viewer/deleteusernote",
        data: {"noteId": this.Favorites[index]._id,
               "col" : "views"},//"favorites"
        success: function(data,status) {
        },
        error: function() {
            saDebug( "AJAX - error() : deleteusernote" );
        },
    });
    this.FavoritesGUI.ImageList.html("");

    this.LoadFavorites();
}

// Testing annotation widget with touch events.


//------------------------------------------------------------------------------
// I intend to have only one object
function MobileAnnotationWidget() {
    var size = '80px';
    //var left = '620px';
    var right = '0px';
    var bottom = '170px';
    if (MOBILE_DEVICE == "iPhone") {
        size = '100px';
        bottom = '80px';
        left = '80px';
    }

    // TODO: The css style is not working for mobile devices. fix it.
    // for now, hack back in the size dependancies.

    var self = this;
    this.Div =
        $('<div>').appendTo(VIEWERS[0].GetDiv())
        .css({'position':'absolute',
              'right':'0px',
              'bottom':'0px',
              'z-index':'5'});

    //.addClass("sa-view-annotation-div ui-responsive")

    // I cannot get touch events that start in the image to continue in
    // the document / viewer.  Press to place, then interact to position.
    this.CircleButton = $('<img>')
        .appendTo(this.Div)
        .css({'height': size,
              'width': size,
              'opacity': '0.6',
              'margin': '1px',
              'padding': '5px'})
        //.addClass("sa-view-annotation-button")
        .attr('src',SA.ImagePathUrl+"Circle128.jpg")
        .on('touchend', function(){self.CircleCallback();});
    this.CircleButton.prop('title', "Circle Annotation");

    this.TextButton = $('<img>')
        .appendTo(this.Div)
        .css({'height': size,
              'width': size,
              'opacity': '0.6',
              'margin': '1px',
              'padding': '5px'})
        //.addClass("sa-view-annotation-button")
        .attr('src',SA.ImagePathUrl+"Text128.jpg")
        .on('touchend', function(){self.TextCallback();});
    this.TextButton.prop('title', "Text Annotation");

    this.Visibility = false;

    var self = this;
    //SA.OnStartInteraction( function () { self.SetVisibility(false);} );
}


MobileAnnotationWidget.prototype.CircleCallback = function() {
    console.log("New circle");

    // Hard code only a single view for now.
    this.Layer = VIEWERS[0].AnnotationLayer;

    if ( this.Layer.ActiveWidget != undefined && widget ) {
        this.Layer.ActiveWidget.Deactivate();
    }
    var widget = new CircleWidget(this.Layer, false);
    var cam = this.Layer.GetCamera();
    var x = cam.FocalPoint[0];
    var y = cam.FocalPoint[1];

    widget.Shape.Origin = [x, y];
    widget.Shape.Radius = cam.Height / 4.0;
    widget.Shape.UpdateBuffers();
    eventuallyRender();

    this.Layer.SetVisibility(true);
}

MobileAnnotationWidget.prototype.TextCallback = function() {
    this.Layer = VIEWERS[0].AnnotationLayer;
    var widget = this.Layer.ActiveWidget;
    if ( widget ) {
        widget.Deactivate();
    }

    this.Layer.SetVisibility(true);
    var widget = new TextWidget(this.Layer, "");
    var cam = this.Layer.GetCamera();
    var x = cam.FocalPoint[0];
    var y = cam.FocalPoint[1];
    widget.Text.Anchor[0] = x;
    widget.Text.Anchor[1] = y;
    this.Layer.EventuallyDraw();

    this.Layer.ActivateWidget(widget);

    // The dialog is used to set the initial text.
    widget.ShowPropertiesDialog();
}

// Show the tool gui.
MobileAnnotationWidget.prototype.SetVisibility = function(v) {
    this.Visibility = v;
    if (v) {
        this.Div.show();
    } else {
        this.Div.hide();
    }
}

// Toggle the tool gui.
MobileAnnotationWidget.prototype.ToggleVisibility = function() {
    this.SetVisibility( ! this.Visibility);
    if (FAVORITES_WIDGET) { 
        FAVORITES_WIDGET.FavoritesBar.ShowHideFavorites();
    }
}








//==============================================================================
// saElement: borders, shadow, drag and resize
// saRectangle: BackgroundColor / gradient.
// saText: padding, textSize, Line spacing, (in future font)
// saLightBox, click to expand.
// saLightBoxViewer, expand to a viewer. Manage turning events on and off.

// Abstracting the question.  It will not be editable text, but can be
// changed from a properties dialog. Subclass of rectangle.
// TODO:
// Bug: Pasting into textEditor leaves edit buttons hanging around. 

// Clean up the whole editable / clickable / lock state.
//    Browser slides are completely passive.

// Modes:
// Edit:
//    Editable: on, off
//    draggable, deletable, properties menu, resizable, record viewer, text
//    click to edit, cursor changing.
// Student:
//    Interactive: on, off.
//    Click to expand viewer and image.
//    Interactive border.
// Thumb:
//    Both Editable and Interactive off.







// Insert / copy html note into presentation.
// Display html note "Text" in the view browser.
// LoadViewChildren has to tolerate notes with no viewer record (get rid of
//   image db stuff?


// make sure html notes still work.
// Copyright management not working for dual display.
// Open dual viewer: overview bounds different (foot)
// Open lightbox viewers do not consume key events.
// Save changes to a stack.
// Resize puts edit buttons in the wrong location.


// bug: question buttons div are active on load

// Make sure the active border stays on during resize.
// Finish pan zoom of presentation.
// Stack viewer / lightbox
// Question: Interactive

// Edit questions/
// Convert text to an saElement.
// Option to hide with answers.
// Interactive question.
// Shuffle questions as note Text. No shuffle when answers are off.

// Replace an image. presesntation will not save.Intertent
//   WHen you delete an image, the next image should go where the last was.
// Menu when not logged in.


//==============================================================================
// Sort of a superclass for all presentation elements.
// Start with draggable, resizable, deletable and click.
// Highlight border to indicate an active element.
// args = {click: function (dom) {...}
//         delete: function (dom) {...}
//         editable: true,
//         interactive: true,
//         aspectRatio: false}
// args = "dialog" => open the dialog.
 
jQuery.prototype.saElement = function(arg1) { // 'arguments' handles extras.
    for (var i = 0; i < this.length; ++i) {
        if ( ! this[i].saElement) {
            var helper = new saElement($(this[i]));
            // Add the helper as an instance variable to the dom object.
            this[i].saElement = helper;
            $(this[i]).addClass('sa-element');
        }
        this[i].saElement.ProcessArguments(arguments);
    }
    return this;
}

// TODO: Rename Edit
function saElement(div) {
    var self = this;

    this.Position = 'absolute';
    this.Editable = false;
    this.Interactive = true;
    this.Div = div;
    this.ClickCallback = null;
    this.DeleteCallback = null;
    // Hack to keep the element active.
    this.LockActive = false;
    this.Div
        .css({'overflow': 'hidden'}) // for borderRadius 
        .hover(
            function () { self.ActiveOn(); },
            function () { self.ActiveOff(); });

    // I cannot move this to EditOn because we need the mouse down event
    // to detect clicks.
    this.Div
        .on('mousedown.element',
              function (event) {
                  return self.HandleMouseDown(event);
              })
        .on('tap.element',
            function (event) {
                if (this.ClickCallback) {
                    (this.ClickCallback)(this.Div[0]);
                    return false;
                }
                return true;
            });


    // I could not get the key events working.  I had to restart the browser.
    this.ButtonDiv = $('<div>')
        .addClass('sa-edit-gui') // Remove before saHtml save.
        .css({'height':'20px',
              'position':'absolute',
              'top':'0px',
              'left':'0px',
              'cursor':'auto',
              'z-index':'1000'})
        // Block the expand event when the delete button is pressed.
        .mousedown(function(){return false;});
    this.DeleteButton = $('<img>')
        .appendTo(this.ButtonDiv)
        .addClass('editButton')
        .css({'height':'16px',
              // static put the buttons out of parent???????
              // Hack the positions with absolute
              'position':'absolute',
              'top':'0px',
              'left':'0px'})
        .attr('src', SA.ImagePathUrl+'remove.png')
        .prop('title', "delete");
    this.MenuButton = $('<img>')
        .appendTo(this.ButtonDiv)
        .addClass('editButton')
        .css({'height':'16px',
              // static put the buttons out of parent???????
              // Hack the positions with absolute
              'position':'absolute',
              'top':'0px',
              'left':'20px'})
        .attr('src',SA.ImagePathUrl+'Menu.jpg')
        .prop('title', "properties");

    this.InitializeDialog();
}

// This changes the border to active color.
saElement.prototype.ActiveOn = function () {
    var self = this;
    if ( ! this.Interactive) {return true;}
    if ( ! this.SavedBorder) {
        this.SavedBorder = this.Div[0].style.border;
    }
    this.Div.css({'border-color':'#7BF'});
    if (this.Editable) {
        this.ButtonDiv.appendTo(this.Div);
        // Remove an element destroys bindings.
        this.MenuButton
            .on('mousedown',
                function () {
                    self.OpenDialog();
                    return false;
                });
        this.DeleteButton
            .on('mousedown',
                function () {
                    if (self.DeleteCallback) {
                        (self.DeleteCallback)(self.Div[0]);
                    }
                    self.Div.remove();
                    return false;
                });
    }
}

saElement.prototype.ActiveOff = function () {
    if ( ! this.Interactive) {return true;}
    if ( this.SavedBorder) {
        this.Div[0].style.border = this.SavedBorder;
        delete this.SavedBorder;
    }
    this.ButtonDiv.remove();
}

saElement.prototype.InitializeDialog = function () {
    var self = this;
    this.Dialog = new SAM.Dialog(function () {self.DialogApplyCallback();});
    this.Dialog.Title.text('Properties');
    // Open callbacks allow default values to be set in the dialog.
    this.DialogInitializeFunctions = [];
    this.DialogApplyFunctions = [];

    // Indicate that this item should be hidden when in quize mode.
    this.Dialog.QuizPanel = this.AddAccordionTab(
        "Quiz",
        function () {
            self.Dialog.QuizCheck.prop('checked', self.Div.hasClass('sa-quiz-hide'));
        },
        function () {
            if (self.Dialog.QuizCheck.is(':checked')) {
                self.Div.addClass('sa-quiz-hide');
            } else {
                self.Div.removeClass('sa-quiz-hide');
            }
        });
    this.Dialog.QuizLabel = $('<div>')
        .appendTo(this.Dialog.QuizPanel)
        .css({'display': 'inline-block'})
        .text("Hide for quiz:");
    this.Dialog.QuizCheck = $('<input type="checkbox">')
        .appendTo(this.Dialog.QuizPanel);

    // Initialize the dialog with properties of border and shadow.
    // Border
    this.Dialog.BorderPanel = this.AddAccordionTab(
        "Border",
        function () {self.DialogInitialize();},
        function () {self.DialogApply();});

    // Border width and color.
    this.Dialog.BorderLine1 = $('<div>')
        .appendTo(this.Dialog.BorderPanel)
        .css({'width':'100%'});
    this.Dialog.BorderCheck = $('<input type="checkbox">')
        .appendTo(this.Dialog.BorderLine1)
        .change(function() {
            if($(this).is(":checked")) {
                self.Dialog.BorderWidth.prop('disabled', false);
                self.Dialog.BorderColor.spectrum('enable');
            } else {
                self.Dialog.BorderWidth.prop('disabled', true);
                self.Dialog.BorderColor.spectrum('disable');
            }
        });
    this.Dialog.BorderWidthLabel = $('<div>')
        .appendTo(this.Dialog.BorderLine1)
        .css({'display': 'inline-block',
              'padding':'0px 5px',
              'width':'4em',
              'height':'20px',
              'text-align': 'right'})
        .text("Width");
    this.Dialog.BorderWidth = $('<input type="number">')
        .appendTo(this.Dialog.BorderLine1)
        .addClass("sa-view-annotation-modal-input")
        .css({'display': 'inline-block',
              'width':'3em'})
        .prop('disabled', true)
        .val(1)
        // Consume all events except return
        .keypress(function(event) { return event.keyCode != 13; });
    this.Dialog.BorderColorDiv = $('<div>')
        .appendTo(this.Dialog.BorderLine1)
        .css({'float':'right',
              'height':'18px'});
    this.Dialog.BorderColor = $('<input type="text">')
        .appendTo(this.Dialog.BorderColorDiv)
        .spectrum({showAlpha: true});

    // Rounded corners
    this.Dialog.BorderLine2 = $('<div>')
        .appendTo(this.Dialog.BorderPanel)
        .css({'width':'100%'});
    this.Dialog.BorderRadiusCheck = $('<input type="checkbox">')
        .appendTo(this.Dialog.BorderLine2)
        .change(function() {
            if($(this).is(":checked")) {
                self.Dialog.BorderRadius.prop('disabled', false);
            } else {
                self.Dialog.BorderRadius.prop('disabled', true);
            }
        });
    this.Dialog.BorderRadiusLabel = $('<div>')
        .appendTo(this.Dialog.BorderLine2)
        .css({'display': 'inline-block',
              'padding':'0px 5px',
              'width':'4em',
              'height':'20px',
              'text-align': 'right'})
        .text("Radius");
    this.Dialog.BorderRadius = $('<input type="number">')
        .appendTo(this.Dialog.BorderLine2)
        .addClass("sa-view-annotation-modal-input")
        .prop('disabled', true)
        .css({'display': 'inline-block',
              'width':'3em'})
        .val(5)
        // Consume all events except return
        .keypress(function(event) { return event.keyCode != 13; });

    // Shadow
    this.Dialog.BorderLine3 = $('<div>')
        .appendTo(this.Dialog.BorderPanel)
        .css({'width':'100%'});
    this.Dialog.ShadowCheck = $('<input type="checkbox">')
        .appendTo(this.Dialog.BorderLine3)
        .change(function() {
            if($(this).is(":checked")) {
                self.Dialog.ShadowOffset.prop('disabled', false);
                self.Dialog.ShadowBlur.prop('disabled', false);
                self.Dialog.ShadowColor.spectrum('enable');
            } else {
                self.Dialog.ShadowOffset.prop('disabled', true);
                self.Dialog.ShadowBlur.prop('disabled', true);
                self.Dialog.ShadowColor.spectrum('disable');
            }
        });
    this.Dialog.ShadowLabel = $('<div>')
        .appendTo(this.Dialog.BorderLine3)
        .css({'display': 'inline-block',
              'padding':'0px 5px',
              'width':'4em',
              'height':'20px',
              'text-align': 'right'})
        .text("Shadow");
    this.Dialog.ShadowOffset = $('<input type="number">')
        .appendTo(this.Dialog.BorderLine3)
        .addClass("sa-view-annotation-modal-input")
        .prop('disabled', true)
        .css({'display': 'inline-block',
              'width':'3em'})
        .val(10)
        // Consume all events except return
        .keypress(function(event) { return event.keyCode != 13; });
    this.Dialog.ShadowBlurLabel = $('<div>')
        .appendTo(this.Dialog.BorderLine3)
        .css({'display': 'inline-block',
              'padding':'0px 5px',
              'width':'3em',
              'height':'20px',
              'text-align': 'right'})
        .text("Blur");
    this.Dialog.ShadowBlur = $('<input type="number">')
        .appendTo(this.Dialog.BorderLine3)
        .addClass("sa-view-annotation-modal-input")
        .prop('disabled', true)
        .css({'display': 'inline-block',
              'width':'3em'})
        .val(5)
        // Consume all events except return
        .keypress(function(event) { return event.keyCode != 13; });
    this.Dialog.ShadowColorDiv = $('<div>')
        .appendTo(this.Dialog.BorderLine3)
        .css({'float':'right',
              'height':'18px'});
    this.Dialog.ShadowColor = $('<input type="text">')
        .appendTo(this.Dialog.ShadowColorDiv)
        .val('#AAAAAA')
        .prop('disabled', true)
        .css({'float':'right',
              'height':'18px'})
        .spectrum({showAlpha: true});
}

saElement.prototype.AddAccordionTab = function(title, open, apply) {
    if (open) {
        this.DialogInitializeFunctions.push(open)
    }
    if (apply) {
        this.DialogApplyFunctions.push(apply)
    }

    var tabDiv = $('<div>')
        .appendTo(this.Dialog.Body)
        .attr('title',title)
        .css({'width':'100%'});
    var tab = $('<div>')
        .appendTo(tabDiv)
        .text(title)
        .addClass('sa-accordion-tab');
    var panel = $('<div>')
        .appendTo(tabDiv)
        .css({'width':'100%',
              'padding':'5px',
              'border':'1px solid #AAA',
              'box-sizing': 'border-box'})
        .hide();
    var self = this;
    tab.click(function () {
        if (self.OpenAccordionPanel) {
            self.OpenAccordionPanel.hide(200);
        }
        if (self.OpenAccordionPanel == panel) {
            // Just closing the open panel.
            self.OpenAccordionPanel = null;
            return;
        }
        // Opening a new panel.
        panel.show(200);
        self.OpenAccordionPanel = panel;
    });
    // The last tab created is visible by default.
    // This should have worked, but did not.
    //tab.trigger("click");
    if (this.OpenAccordionPanel) {
        this.OpenAccordionPanel.hide();
    }
    this.OpenAccordionPanel = panel;
    panel.show();

    return panel;
}

saElement.prototype.HideAccordionTab = function(title) {
    this.Div[0].saElement.Dialog.Body.children('[title=Quiz]').hide();
}

saElement.prototype.OpenDialog = function(callback) {
    if ( ! this.DialogInitialized) {
        // Give 'subclasses' a chance to initialize their tabs.
        for (var i = 0; i < this.DialogInitializeFunctions.length; ++i) {
            (this.DialogInitializeFunctions[i])(this.Dialog);
        }
        this.DialogInitialized = true;
    }
    // Keep this onetime callback separate from DialogApplyCallbacks.
    this.OpenDialogCallback = callback;
    this.Dialog.Show(true);
}

saElement.prototype.DialogInitialize = function() {
    // TODO: Does this work when 'border' is used?
    var str = this.Div[0].style.borderWidth;
    if (str != "") {
        this.Dialog.BorderCheck.prop('checked', true);
        this.Dialog.BorderWidth.prop('disabled', false);
        this.Dialog.BorderColor.spectrum('enable');
        this.Dialog.BorderWidth.val(parseInt(str));
        // Current border is highlighted.  Use the saved color.
        //str = this.Div[0].style.borderColor;
        str = this.SavedBorder;
        if ( ! str || str == "") {
            // Called programatically
            str = this.Div[0].style.border;
        }
        if (str != "") {
            str = str.substr(str.indexOf('rgb'));
            this.Dialog.BorderColor.spectrum('set',str);
        }
    }

    // Border Radius
    str = this.Div[0].style.borderRadius;
    if (str != "") {
        this.Dialog.BorderRadiusCheck.prop('checked', true);
        this.Dialog.BorderRadius.prop('disabled', false);
        this.Dialog.BorderRadius.val(parseInt(str));
    }

    // Shadow
    str = this.Div[0].style.boxShadow;
    if (str != "") {
        this.Dialog.ShadowCheck.prop('checked', true);
        var idx = str.indexOf(')')+1;
        var color = str.substr(str.indexOf('rgb'), idx);
        this.Dialog.ShadowColor.spectrum('set', color);
        this.Dialog.ShadowColor.spectrum('enable');
        str = str.substr(idx+1); // 1 more to skip the space
        var params = str.split(' ');
        this.Dialog.ShadowOffset.prop('disabled', false);
        this.Dialog.ShadowOffset.val(parseInt(params[0]));
        this.Dialog.ShadowBlur.prop('disabled', false);
        this.Dialog.ShadowBlur.val(parseInt(params[2]));
    }
}

saElement.prototype.DialogApplyCallback = function() {
    // Giv 'subclasses' a chance to apply parameters in their tabs.
    for (var i = 0; i < this.DialogApplyFunctions.length; ++i) {
        (this.DialogApplyFunctions[i])(this.Dialog);
    }

    // External callback
    // I am not sure if I should put this here or in DialogApply.
    if ( this.OpenDialogCallback) {
        (this.OpenDialogCallback)(this);
        delete this.OpenDialogCallback;
    }
}

saElement.prototype.DialogApply = function() {
    // ActiveOff was setting border back after dialog changed it.
    delete this.SavedBorder;
    if (this.Dialog.BorderCheck.is(":checked")) {
        var color = this.Dialog.BorderColor.spectrum('get');
        var width = parseFloat(this.Dialog.BorderWidth.val());
        this.Div.css({'border': width+'px solid ' + color});
    } else {
        this.Div.css('border', '');
    }

    // Border Radius
    if (this.Dialog.BorderRadiusCheck.is(":checked")) {
        var width = parseFloat(this.Dialog.BorderRadius.val());
        this.Div.css({'borderRadius': width+'px'});
    } else {
        this.Div.css('borderRadius', '');
    }

    // Shadow
    if (this.Dialog.ShadowCheck.is(":checked")) {
        var hexcolor = this.Dialog.ShadowColor.spectrum('get');
        var offset = parseInt(this.Dialog.ShadowOffset.val());
        var blur = parseInt(this.Dialog.ShadowBlur.val());
        this.Div.css({'box-shadow': offset+'px '+offset+'px '+blur+'px '+hexcolor});
    } else {
        this.Div.css('box-shadow', '');
    }
}


saElement.prototype.ProcessArguments = function(args) {
    // No superclass

    // aspect ratio does something even with no arguments.
    if (args.length > 0) {
        // generic method call. Give jquery ui access to all this objects methods.
        if (typeof(this[args[0]]) == 'function') {
            // first list item is the method name,
            // the rest are arguments to the method.
            return this[args[0]].apply(this, Array.prototype.slice.call(args,1));
        }
        // Handle the legacy behavior.
        // One argument: an object (like jqueryUI).
        args = args[0];
    } else {
        // looks like aspect processing wiht no args ...  Cannot just return?
        args = {};
    }

    var self = this;

    if (args.position) {
        this.Position = args.position;
    }

    // It is important to set aspect ratio before EditOn is called.
    // AspectRatio is a boolean.
    if (args.aspectRatio !== undefined) {
        if (args.apsectRatio == "") {
            // Actively remove the aspect ratio.
            delete this.AspectRatio;
            this.Div.removeAttr('sa-aspect-ratio');
        } else {
            // Set a new aspect ratio
            this.AspectRatio = args.aspectRatio;
            this.Div.attr('sa-aspect-ratio', args.aspectRatio);
        }
    } else {
        // try and get a saved aspect ratio.
        this.AspectRatio = this.Div.attr('sa-aspect-ratio');
    }

    if (args.editable !== undefined) {
        if (args.editable) {
            this.EditableOn();
        } else {
            this.EditableOff();
            // hack hack hack (for view browser).
            // Trying to make slide thumbnails completly passive.
            this.Div.attr('contenteditable', 'false')
                .addClass('sa-noselect');
            this.Div.find('div').attr('contenteditable', 'false')
                .addClass('sa-noselect');
        }
    }

    if (args.interactive !== undefined) {
        this.Interactive = args.interactive;
        if (this.Interactive) {
            this.Div.removeClass("sa-noselect");
        } else {
            this.Div.addClass("sa-noselect");
        }
    }

    if (args.click !== undefined) {
        this.ClickCallback = args.click;
        this.Clickable = true;
    }

    if (args.delete !== undefined) {
        this.DeleteCallback = args.delete;
    }

    this.ConvertToPercentages();
}

saElement.prototype.SetClickCallback = function(callback) {
    this.ClickCallback = callback;
    this.Clickable = true;
}


// Not the best function name.  Editable => draggable, expandable and deletable.
saElement.prototype.EditableOn = function() {
    this.Editable = true;
    this.Clickable = true;
    // I cannot get jqueryUI draggable to work.  Use my own events.
    var self = this;
    this.Div.on(
        'mousewheel.element',
        function(event){
            // Resize from the middle.
            return self.HandleMouseWheel(event.originalEvent);
        });
    // NOTE: I could not get key events working for delete key.
    // Just had to restart chrome. Delete key is oldschool anyway.

    // Manage the cursor for drag versus resize.
    if (this.Position == 'absolute') {
        this.Div.on(
            'mousemove.elementCursor',
            function (event) {
                return self.HandleMouseMoveCursor(event);
            });
    }
}

saElement.prototype.EditableOff = function() {
    this.Editable = false;
    this.Div.css({'cursor':'auto'});
    // TODO: Remove wheel event.
    this.Div.off('mousewheel.element');
    this.Div.off('keyup.element');
    this.Div.off('mousemove.elementCursor');

    this.ButtonDiv.remove();
}


saElement.prototype.HandleMouseDown = function(event) {
    if ( ! this.Interactive) { return true;}
    if (event.which == 1) {
        // Hack tp allow content editable to work with text editor.
        // This event does not let content editable receive events
        // if we return false.
        if ( ! this.Clickable) {
            return true;
        }

        var self = this;
        // To detect quick click for expansion.
        this.ClickStart = Date.now();
        $('body').on(
            'mouseup.element',
            function(e) {
                return self.HandleMouseUp(e);
            });

        if (this.Editable && this.Position == "absolute") {
            // Setup dragging.
            this.DragLastX = event.screenX;
            this.DragLastY = event.screenY;
            // Add the event to stop dragging
            $('body').on(
                'mousemove.element',
                function (event) {
                    return self.HandleMouseMove(event);
                });
            $('body').on(
                'mouseleave.element',
                function(e) {
                    return self.HandleMouseUp(e);
                });
            // Hack to keep active even when mouse leaves the div.
            this.Div[0].saElement.LockActive = true;
        }
        return false;
    }
    return true;
}

// raise to the top of the draw order.
// Note: it will not override z-index
saElement.prototype.RaiseToTop = function() {
    var parent = this.Div.parent();
    this.Div.detach();
    this.Div.appendTo(parent);
}


saElement.prototype.HandleMouseMoveCursor = function(event) {
    if (! this.Interactive) { return true;}
    saFirefoxWhich(event);
    if (event.which == 0) {
        // Is it dangerous to modify the event object?
        while (event.srcElement && event.srcElement != this.Div[0]) {
            event.offsetX += event.srcElement.offsetLeft;
            event.offsetY += event.srcElement.offsetTop;
            event.srcElement = event.srcElement.parentElement;
        }
        var x = event.offsetX;
        var y = event.offsetY;
        var width = this.Div.outerWidth();
        var height = this.Div.outerHeight();
        var handleSize = (width+height) / 100;
        if (handleSize < 6) {
            handleSize = 6;
        }
        var xMax = width-handleSize;
        var yMax = height-handleSize;
        if ( x < handleSize && y < handleSize) {
            this.Div.css({'cursor':'nwse-resize'});
            this.MoveState = 5;
        } else if ( x > xMax && y > yMax) {
            this.Div.css({'cursor':'nwse-resize'});
            this.MoveState = 6;
        } else if ( x < handleSize && y > yMax) {
            this.Div.css({'cursor':'nesw-resize'});
            this.MoveState = 7;
        } else if ( x > xMax && y < handleSize) {
            this.Div.css({'cursor':'nesw-resize'});
            this.MoveState = 8;
        } else if ( x < handleSize) {
            this.Div.css({'cursor':'ew-resize'});
            this.MoveState = 1;
        } else if ( x > xMax) {
            this.Div.css({'cursor':'ew-resize'});
            this.MoveState = 2;
        } else if ( y < handleSize) {
            this.Div.css({'cursor':'ns-resize'});
            this.MoveState = 3;
        } else if ( y > yMax) {
            this.Div.css({'cursor':'ns-resize'});
            this.MoveState = 4;
        } else {
            this.Div.css({'cursor':'move'});
            this.MoveState = 0;
        }
    }
    return true;
}


saElement.prototype.HandleMouseMove = function(event) {
    saFirefoxWhich(event);
    if (event.which == 1) {
        // Wait for the click duration to start dragging.
        if (Date.now() - this.ClickStart < 200) {
            return true;
        }

        if ( ! this.Dragging) {
            this.RaiseToTop();
            this.Dragging = true;
        }

        var dx = event.screenX - this.DragLastX;
        var dy = event.screenY - this.DragLastY;
        this.DragLastX = event.screenX;
        this.DragLastY = event.screenY;

        // Maybe we should not let the object leave the page.
        var pos  = this.Div.position();
        // It is odd.  First setting width has the same value as getting
        // outerWidth. Now it behaves as expected (consistent outer set / get).
        var width = this.Div.outerWidth();
        var height = this.Div.outerHeight();
        // Hack,  I cannot figure out how jquery deals with box-sizing.
        var sizing = this.Div.css('box-sizing');
        if (this.AspectRatio && typeof(this.AspectRatio) != 'number') {
            this.AspectRatio = width / height;
        }
        if (this.MoveState == 0) {
            var left = pos.left + dx;
            var top  = pos.top + dy;
            this.Div[0].style.top  = top.toString()+'px';
            this.Div[0].style.left = left.toString()+'px';
            return false;
        } else if (this.MoveState == 1) {
            var left = pos.left + dx;
            width = width - dx;
            this.Div[0].style.left = left.toString()+'px';
            if (sizing == 'border-box') {
                this.Div.width(width);
            } else {
                this.Div.outerWidth(width);
            }
            if (this.AspectRatio) {
                this.Div.innerHeight(this.Div.innerWidth/this.AspectRatio);
            }
            this.Div.trigger('resize');
            return false;
        } else if (this.MoveState == 2) {
            width = width + dx;
            if (sizing == 'border-box') {
                this.Div.width(width);
            } else {
                this.Div.outerWidth(width);
            }
            if (this.AspectRatio) {
                this.Div.innerHeight(this.Div.innerWidth()/this.AspectRatio);
            }
            this.Div.trigger('resize');
            return false;
        } else if (this.MoveState == 3) {
            var top = pos.top + dy;
            height = height - dy;
            this.Div[0].style.top = top.toString()+'px';
            if (sizing == 'border-box') {
                this.Div.height(height);
            } else {
                this.Div.outerHeight(height);
            }
            if (this.AspectRatio) {
                this.Div.innerWidth(this.Div.innerHeight()*this.AspectRatio);
            }
            this.Div.trigger('resize');
            return false;
        } else if (this.MoveState == 4) {
            height = height + dy;
            if (sizing == 'border-box') {
                this.Div.height(height);
            } else {
                this.Div.outerHeight(height);
            }
            if (this.AspectRatio) {
                this.Div.innerWidth(this.Div.innerHeight()*this.AspectRatio);
            }
            this.Div.trigger('resize');
            return false;



        } else if (this.MoveState == 5) {
            // upper left corner resize
            var left = pos.left + dx;
            var top  = pos.top + dy;
            width = width - dx;
            height = height - dy;
            this.Div[0].style.top  = top.toString()+'px';
            this.Div[0].style.left = left.toString()+'px';
            if (sizing == 'border-box') {
                this.Div.width(width);
                this.Div.height(height);
            } else {
                this.Div.outerWidth(width);
                this.Div.outerHeight(height);
            }
            if (this.AspectRatio) {
                this.Div.innerWidth(this.Div.innerHeight()*this.AspectRatio);
            }
            this.Div.trigger('resize');
            return false;
        } else if (this.MoveState == 6) {
            // lower right corner resize
            width = width + dx;
            height = height + dy;
            if (sizing == 'border-box') {
                this.Div.width(width);
                this.Div.height(height);
            } else {
                this.Div.outerWidth(width);
                this.Div.outerHeight(height);
            }
            if (this.AspectRatio) {
                this.Div.innerWidth(this.Div.innerHeight()*this.AspectRatio);
            }
            this.Div.trigger('resize');
            return false;
        } else if (this.MoveState == 7) {
            // lower left corner resize
            var left = pos.left + dx;
            width = width - dx;
            height = height + dy;
            this.Div[0].style.left = left.toString()+'px';
            if (sizing == 'border-box') {
                this.Div.width(width);
                this.Div.height(height);
            } else {
                this.Div.outerWidth(width);
                this.Div.outerHeight(height);
            }
            if (this.AspectRatio) {
                this.Div.innerWidth(this.Div.innerHeight()*this.AspectRatio);
            }
            this.Div.trigger('resize');
            return false;
        } else if (this.MoveState == 8) {
            // upper right corner resize
            var top  = pos.top + dy;
            width = width + dx;
            height = height - dy;
            this.Div[0].style.top  = top.toString()+'px';
            if (sizing == 'border-box') {
                this.Div.width(width);
                this.Div.height(height);
            } else {
                this.Div.outerWidth(width);
                this.Div.outerHeight(height);
            }
            if (this.AspectRatio) {
                this.Div.innerWidth(this.Div.innerHeight()*this.AspectRatio);
            }
            this.Div.trigger('resize');
            return false;
        }
    }
    return true;
}

saElement.prototype.HandleMouseUp = function(event) {
    // mouse up is not conditional on edit because it
    // is also used tio trigger click callback.
    $('body').off('mouseup.element');

    if (this.Editable) {
        if (this.Dragging) {
            this.Dragging = false;
            this.ConvertToPercentages();
        }
        $('body').off('mousemove.element');
        $('body').off('mouseleave.element');
        // hack
        this.Div[0].saElement.LockActive = false;
        this.Div[0].saElement.ActiveOff();
    }

    // Quick click...
    var clickDuration = Date.now() - this.ClickStart;
    if (clickDuration < 200 && this.ClickCallback) {
        (this.ClickCallback)(this.Div[0]);
    }

    return false;
}

saElement.prototype.HandleMouseWheel = function(event) {
    var width = this.Div.width();
    var height = this.Div.height();
    var dWidth = 0;
    var dHeight = 0;

    var tmp = 0;
    if (event.deltaY) {
        tmp = event.deltaY;
    } else if (event.wheelDelta) {
        tmp = event.wheelDelta;
    }
    // Wheel event seems to be in increments of 3.
    // depreciated mousewheel had increments of 120....
    // Initial delta cause another bug.
    // Lets restrict to one zoom step per event.
    if (tmp > 0) {
        dWidth = 0.05 * width;
        dHeight = 0.05 * height;
    } else if (tmp < 0) {
        dWidth = width * (-0.0476);
        dHeight = height * (-0.0476);
    }

    width += dWidth;
    this.Div[0].style.width = width.toString()+'px';
    height += dHeight;
    this.Div[0].style.height = height.toString()+'px';

    // We have to change the top and left ot percentages too.
    // I might have to make my own resizable to get the exact behavior
    // I want.
    var pos  = this.Div.position();
    var left = pos.left - (dWidth / 2);
    var top  = pos.top - (dHeight / 2);
    this.Div[0].style.top  = top.toString()+'px';
    this.Div[0].style.left = left.toString()+'px';

    // the resize callback might deal with converting to percentages.
    //this.ConvertToPercentages();
    this.Div.trigger('resize');
    return false;
}


// Change left, top, widht and height to percentages.
saElement.prototype.ConvertToPercentages = function() {
    // I had issues with previous slide shows that had images with no width
    // set. Of course it won't scale right but they will still show up.
    // NOTE: this.Div.width() also misbehaves when the div is not visible.
    // It does not convert percent to pixels (returns percent).
    var width = this.Div[0].style.width;
    if (width.indexOf('%') == -1) {
        width = parseFloat(width);
        width = 100 * width / this.Div.parent().width();
        this.Div[0].style.width = width.toString()+'%';
    }
    var height = this.Div[0].style.height;
    if (height.indexOf('%') == -1) {
        height = parseFloat(height);
        height = 100 * height / this.Div.parent().height();
        this.Div[0].style.height = height.toString()+'%';
    }

    // Note: We cannot use this.Div.position() when the div is hidden.
    var top = this.Div.css('top');
    if (top.indexOf('%') == -1) {
        top = parseFloat(top);
        top  = 100 * top / this.Div.parent().height();
        this.Div[0].style.top  = top.toString()+'%';
    }
    var left = this.Div.css('left');
    if (left.indexOf('%') == -1) {
        left = parseFloat(left);
        left = 100 * left / this.Div.parent().width();
        this.Div[0].style.left = left.toString()+'%';
    }
}

//==============================================================================
// Just editing options to a rectangle.  I could make the text editor a 
// "subclass" of this rectangle object.

jQuery.prototype.saRectangle = function(arg1) { // 'arguments' handles extras.
    // Setup the superclass saElement.
    this.saElement();
    this.addClass('sa-presentation-rectangle');
    for (var i = 0; i < this.length; ++i) {
        dom = this[i];
        if ( ! dom.saRectangle) {
            dom.saRectangle = new saRectangle($(dom));
        }
        dom.saRectangle.ProcessArguments(arguments);
    }

    return this;
}

function saRectangle(div) {
    var self = this;
    this.Div = div;
    var element = div[0].saElement;
    this.BackgroundPanel = element.AddAccordionTab(
        "Background",
        function () {self.DialogInitialize();},
        function () {self.DialogApply();});

    // Background with gradient option.
    this.BackgroundLine1 = $('<div>')
        .appendTo(this.BackgroundPanel)
        .css({'width':'100%'});
    this.BackgroundCheck = $('<input type="checkbox">')
        .appendTo(this.BackgroundLine1)
        .change(function() {
            if($(this).is(":checked")) {
                self.BackgroundColor.spectrum('enable');
            } else {
                self.BackgroundColor.spectrum('disable');
            }
        });
    this.BackgroundColorLabel = $('<div>')
        .appendTo(this.BackgroundLine1)
        .css({'display': 'inline-block',
              'padding':'0px 5px',
              'width':'4em',
              'height':'20px',
              'text-align': 'right'})
        .text("Color");
    this.BackgroundColorDiv = $('<div>')
        .appendTo(this.BackgroundLine1)
        .css({'display':'inline-block',
              'height':'18px',
              'margin-left':'1em'});
    this.BackgroundColor = $('<input type="text">')
        .appendTo(this.BackgroundLine1)
        .val('#005077')
        .spectrum({showAlpha: true});
    this.BackgroundColor.spectrum('disable');

    // Gradient
    this.BackgroundLine2 = $('<div>')
        .appendTo(this.BackgroundPanel)
        .css({'width':'100%'});
    this.GradientCheck = $('<input type="checkbox">')
        .appendTo(this.BackgroundLine2)
        .change(function() {
            if($(this).is(":checked")) {
                self.GradientColor.spectrum('enable');
                self.GradientColor.spectrum('show');
            } else {
                self.GradientColor.spectrum('disable');
                self.GradientColor.spectrum('hide');
            }
        });
    this.GradientLabel = $('<div>')
        .appendTo(this.BackgroundLine2)
        .css({'display': 'inline-block',
              'padding':'0px 5px',
              'width':'4em',
              'height':'20px',
              'text-align': 'right'})
        .text("Gradient");
    this.GradientColorDiv = $('<div>')
        .appendTo(this.BackgroundLine2)
        .css({'display':'inline-block',
              'height':'18px',
              'margin-left':'1em'});
    this.GradientColor = $('<input type="text">')
        .appendTo(this.GradientColorDiv)
        .val('#005077')
        .spectrum({showAlpha: true});
}

saRectangle.prototype.ProcessArguments = function(args) {
    if (args.length == 0) { return; }

    // Superclass
    this.Div[0].saElement.ProcessArguments(args);

    // generic method call. Give jquery ui access to all this objects methods.
    if (typeof(this[args[0]]) == 'function') {
        // first list item is the method name,
        // the rest are arguments to the method.
        return this[args[0]].apply(this, Array.prototype.slice.call(args,1));
    }
}

saRectangle.prototype.DialogInitialize = function () {
    var color = this.Div[0].style.background;
    if (color == '') {
        color = this.Div[0].style.backgroundColor;
    }
    if (color == '') {
        this.BackgroundCheck.prop('checked', false);
        this.BackgroundColor.spectrum('disable');
        this.GradientCheck.prop('checked', false);
        this.GradientColor.spectrum('disable');
        this.GradientColor.spectrum('hide');
        return;
    }
    if (color.substring(0,3) == 'rgb') {
        // Single color in background (no 'linear-gradient')
        this.BackgroundCheck.prop('checked', true);
        this.BackgroundColor.spectrum('set',color);
        this.BackgroundColor.spectrum('enable');
        this.GradientCheck.prop('checked', false);
        this.GradientColor.spectrum('disable');
        this.GradientColor.spectrum('hide');
        return;
    }
    // parsing the gradient is a bit harder.
    if (color.substring(0,15) == 'linear-gradient') {
        var idx0 = color.indexOf('rgb');
        var idx1 = color.indexOf(')') + 1;
        this.BackgroundCheck.prop('checked', true);
        this.BackgroundColor.spectrum('enable');
        this.BackgroundColor.spectrum('set',color.substring(idx0,idx1));
        idx0 = color.indexOf('rgb', idx1);
        idx1 = color.indexOf(')', idx1) + 1;
        this.GradientCheck.prop('checked', true);
        this.GradientColor.spectrum('enable');
        this.GradientColor.spectrum('show');
        this.GradientColor.spectrum('set',color.substring(idx0,idx1));
        return;
    }
    saDebug("parse error: " + color);
}

saRectangle.prototype.DialogApply = function () {
    if ( ! this.BackgroundCheck.is(":checked")) {
        this.Div.css('background', '');
        return;
    }
    var color = this.BackgroundColor.spectrum('get');
    if ( ! this.GradientCheck.is(":checked")) {
        this.Div.css({'background': color});
        return;
    }
    var color2 = this.GradientColor.spectrum('get');
    this.Div.css({'background': 'linear-gradient('+color+','+color2+')'});
}

//==============================================================================
// Text: dialog to set margin, text size, spacing, (font in the future)

jQuery.prototype.saText = function(arg1) { // 'arguments' handles extras.
    // Setup the superclass saElement.
    this.saRectangle();
    this.addClass('sa-text');
    for (var i = 0; i < this.length; ++i) {
        dom = this[i];
        if ( ! dom.saText) {
            dom.saText = new saText($(dom));
        }
        dom.saText.ProcessArguments(arguments);
    }

    return this;
}

function saText(div) {
    var self = this;
    this.Div = div;
    var element = div[0].saElement;
    this.PaddingPanel = element.AddAccordionTab(
        "Margins",
        function () {self.DialogPaddingInitialize();},
        function () {self.DialogPaddingApply();});
    // Padding (text margins)
    // Left
    this.PaddingLeftLine = $('<div>')
        .appendTo(this.PaddingPanel)
        .css({'width':'100%'});
    this.PaddingLeftLabel = $('<div>')
        .appendTo(this.PaddingLeftLine)
        .css({'display': 'inline-block',
              'padding':'0px 5px',
              'width':'4em',
              'height':'20px',
              'text-align': 'right'})
        .text("Left:");
        this.PaddingLeft =
            $('<input type="number">')
            .appendTo(this.PaddingLeftLine)
            .keypress(function(event) { return event.keyCode != 13; });
    // Top
    this.PaddingTopLine = $('<div>')
        .appendTo(this.PaddingPanel)
        .css({'width':'100%'});
    this.PaddingTopLabel = $('<div>')
        .appendTo(this.PaddingTopLine)
        .css({'display': 'inline-block',
              'padding':'0px 5px',
              'width':'4em',
              'height':'20px',
              'text-align': 'right'})
        .text("Top:");
        this.PaddingTop =
            $('<input type="number">')
            .appendTo(this.PaddingTopLine)
            .keypress(function(event) { return event.keyCode != 13; });
    // Right
    this.PaddingRightLine = $('<div>')
        .appendTo(this.PaddingPanel)
        .css({'width':'100%'});
    this.PaddingRightLabel = $('<div>')
        .appendTo(this.PaddingRightLine)
        .css({'display': 'inline-block',
              'padding':'0px 5px',
              'width':'4em',
              'height':'20px',
              'text-align': 'right'})
        .text("Right:");
        this.PaddingRight =
            $('<input type="number">')
            .appendTo(this.PaddingRightLine)
            .keypress(function(event) { return event.keyCode != 13; });
    // Bottom
    this.PaddingBottomLine = $('<div>')
        .appendTo(this.PaddingPanel)
        .css({'width':'100%'});
    this.PaddingBottomLabel = $('<div>')
        .appendTo(this.PaddingBottomLine)
        .css({'display': 'inline-block',
              'padding':'0px 5px',
              'width':'4em',
              'height':'20px',
              'text-align': 'right'})
        .text("Bottom:");
        this.PaddingBottom =
            $('<input type="number">')
            .appendTo(this.PaddingBottomLine)
            .keypress(function(event) { return event.keyCode != 13; });

}

saText.prototype.ProcessArguments = function(args) {
    if (args.length == 0) { return; }

    // Superclass
    this.Div[0].saRectangle.ProcessArguments(args);

    // generic method call. Give jquery ui access to all this objects methods.
    if (typeof(this[args[0]]) == 'function') {
        // first list item is the method name, 
        // the rest are arguments to the method.
        return this[args[0]].apply(this, Array.prototype.slice.call(args,1));
    }
}

saText.prototype.DialogPaddingInitialize = function () {
    var txt;

    txt = this.Div[0].style.paddingLeft;
    // Convert to something like pixels.
    this.PaddingLeft.val(8*parseFloat(txt)); // window 800 pixels high

    txt = this.Div[0].style.paddingTop;
    // Convert to something like pixels.
    this.PaddingTop.val(8*parseFloat(txt)); // window 800 pixels high

    txt = this.Div[0].style.paddingRight;
    // Convert to something like pixels.
    this.PaddingRight.val(8*parseFloat(txt)); // window 800 pixels high

    txt = this.Div[0].style.paddingBottom;
    // Convert to something like pixels.
    this.PaddingBottom.val(8*parseFloat(txt)); // window 800 pixels high
}

saText.prototype.DialogPaddingApply = function () { 
    this.Div[0].style.paddingLeft = (this.PaddingLeft.val()/8)+'%';
    this.Div[0].style.paddingTop = (this.PaddingTop.val()/8)+'%';
    this.Div[0].style.paddingRight = (this.PaddingRight.val()/8)+'%';
    this.Div[0].style.paddingBottom = (this.PaddingBottom.val()/8)+'%';
}

//==============================================================================
// Questions
//
jQuery.prototype.saQuestion = function(arg1) { // 'arguments' handles extras.
    // Setup the superclass saRectangle.
    this.saText();
    for (var i = 0; i < this.length; ++i) {
        if ( ! this[i].saQuestion) {
            // Add the helper as an instance variable to the dom object.
            this[i].saQuestion = new saQuestion($(this[i]));;
            this[i].saElement.HideAccordionTab('Quiz');
        }
        this[i].saQuestion.ProcessArguments(arguments);
    }

    return this;
}

function saQuestion(div) {
    var self = this;
    this.Div = div;
    this.Div.addClass('sa-question');

    var element = div[0].saElement;
    element.Dialog.Dialog.css({'width':'500px'});

    this.QuestionPanel = element.AddAccordionTab(
        "Question",
        function () { self.DialogInitialize(); },
        function () { self.DialogApply(); });

    this.DialogInitialize();
}

// Meant to be acll externally.
// Assumes multiple choice for now.
saQuestion.prototype.SetQuestionText = function(text) {
    var question = this.Div.find('.sa-q');
    if (question.length == 0) {
        question = $('<div>').addClass('sa-q').appendTo(this.Div);
    }
    question.text(text);
    this.Div.attr('type','multiple-choice');
}
saQuestion.prototype.AddAnswerText = function(text, correct) {
    var answerText = text;
    // get rid of bullets
    if (text[0] == '-') {
        answerText = text.substring(1);
    } else if (text[1] == '.' || text[1] == ':') {
        answerText = text.substring(2);
    }
    // Get rid of whitespace
    answerText = answerText.trim();

    var answers = this.Div.find('ol');
    if (answers.length == 0) {
        answers = $('<ol>').appendTo(this.Div);
    }
    var answer = $('<li>').appendTo(answers).addClass('sa-answer');
    answer.text(answerText);
    if (correct) {
        answer.addClass('sa-true');
    }
}

saQuestion.prototype.ProcessArguments = function(args) {
    if (args.length == 0) { return; }

    // Superclass
    this.Div[0].saText.ProcessArguments(args);

    // generic method call. Give jquery ui access to all this objects methods.
    if (typeof(this[args[0]]) == 'function') {
        // first list item is the method name, 
        // the rest are arguments to the method.
        return this[args[0]].apply(this, Array.prototype.slice.call(args,1));
    }
}

saQuestion.prototype.SetMode = function(mode) {
    // Clear wrong answers selected by user.
    this.Div.find('.sa-answer').css({'color':'#000'});
    if (mode == 'answer-show') {
        this.Div.find('.sa-quiz-hide').show();
        this.Div.find('.sa-true').css({'font-weight':'bold'});
    } else {
        this.Div.find('.sa-quiz-hide').hide();
        this.Div.find('.sa-true').css({'font-weight':'normal'});
    }

    if (mode == 'answer-interactive') {
        // Bind response to the user selecting an answer.
        this.Div.find('.sa-answer')
            .css({'cursor':'pointer',
                  'color':'#057'})
            .hover(function(){$(this).css({'background':'#DDD'});},
                   function(){$(this).css({'background':'#FFF'});})
            .on('click.answer',
                function () {
                    if ($(this).hasClass('sa-true')) {
                        $(this).css({'font-weight':'bold',
                                     'color':'#000'});
                    } else {
                        $(this).css({'color':'#C00'});
                    }
                });
    } else {
        this.Div.find('.sa-answer')
            .css({'color':'#000'})
            .css('cursor','')
            .off('hover')
            .off('click.answer');
    }
}

saQuestion.prototype.AddAnswerTo = function(parent, answerList, text, checked) {
    var self = this;

    // Make a new answer box;
    var answerDiv = $('<div>')
        .appendTo(parent)
        .css({'width':'100%',
              'position':'relative'});
    var check = $('<input type="checkbox">')
        .appendTo(answerDiv);
    var answer = $('<div>')
        .appendTo(answerDiv)
        .css({'border':'1px solid #AAA',
              'position':'absolute',
              'left':'30px',
              'right':'2px',
              'top':'2px'})
        .attr('contenteditable', 'true');
    check.change(
        function() {
            if($(this).is(":checked")) {
                answer.css({'font-weight':'bold'});
            } else {
                answer.css({'font-weight':'normal'});
            }
        });

    if (text) {
        answer.text(text);
        if (checked) {
            check.attr('checked','true');
            answer.css({'font-weight':'bold'});
        }
    }

    // Answers are complicated enough that I am going to have to break down
    // and create differt gui object.
    var answerObj = {Div   : answerDiv,
                     Check : check,
                     Input : answer};
    answerList.push(answerObj);
    return answerObj;
}

saQuestion.prototype.DialogInitialize = function () {
    var self = this;
    // Create/recreate the question dialog panel.
    var panel = this.QuestionPanel;
    panel.empty();

    this.QuestionTypeSelect = $('<select>')
        .appendTo(panel);
    this.QuestionTypeMultipleChoice = $('<option>')
        .appendTo(this.QuestionTypeSelect)
        .text("Multiple Choice");
    //this.QuestionTypeSortAnswer = $('<option>')
    //    .appendTo(this.QuestionTypeSelect)
    //    .text("Short Answer");
    //this.QuestionTypeTrueFalse = $('<option>')
    //    .appendTo(this.QuestionTypeSelect)
    //    .text("True or False");
    this.QuestionTypeSelect.change(
        function (){
            if ($(this).val() == "Multiple Choice") {
                self.MultipleChoiceDiv.show();
                self.TrueFalseDiv.hide();
                self.ShortAnswerDiv.hide();
            }
            if ($(this).val() == "True or False") {
                self.MultipleChoiceDiv.hide();
                self.TrueFalseDiv.show();
                self.ShortAnswerDiv.hide();
            }
            if ($(this).val() == "Short Answer") {
                self.MultipleChoiceDiv.hide();
                self.TrueFalseDiv.hide();
                self.ShortAnswerDiv.show();
            }
        });

    this.QuestionLabel = $('<div>')
        .appendTo(panel)
        .text("Question:");
    this.Question = $('<div>')
        .appendTo(panel)
        .css({'border':'1px solid #AAA',
              'margin':'2px'})
        .attr('contenteditable', 'true');

    // The div itself is the answer input.
    this.ShortAnswerDiv = $('<div>')
        .appendTo(panel)
        .css({'border':'1px solid #AAA',
              'width':'100%',
              'height':'3em',
              'margin':'1px'})
        .attr('contenteditable', 'true')
        .hide();

    this.TrueFalseDiv = $('<div>')
        .appendTo(panel)
        .hide();
    this.TrueFalseAnswers = [];
    this.AddAnswerTo(this.TrueFalseDiv, this.TrueFalseAnswers, "True");
    this.AddAnswerTo(this.TrueFalseDiv, this.TrueFalseAnswers, "False");

    this.MultipleChoiceDiv = $('<div>')
        .appendTo(panel);
    this.MultipleChoiceAnswerLabel = $('<div>')
        .appendTo(this.MultipleChoiceDiv)
        .addClass('sa-mutliple-choice-answer')
        .text("Answers:");
    this.MultipleChoiceAnswers = [];

    // Initialize the question panel values from a question div (saQuestion).

    // Get the question information from the html.
    var questionDiv = this.Div.find('.sa-q');
    if (questionDiv.length > 0) {
        this.Question.text(questionDiv.text());
        var type = this.Div.attr('type');
        if (type == 'multiple-choice') {
            this.QuestionTypeSelect.val("Multiple Choice");
            var options = this.Div.find('.sa-answer');
            for (var i = 0; i < options.length; ++i) {
                var item = $(options[i]);
                var checked = item.hasClass('sa-true');
                this.AddAnswerTo(this.MultipleChoiceDiv,
                                 this.MultipleChoiceAnswers,
                                 item.text(), checked);
            }
        }
    }

    // Empty answer that adds another when it is filled.
    this.AddBlankMultipleChoiceAnswer();
}

saQuestion.prototype.AddBlankMultipleChoiceAnswer = function () {
    var self = this;
    var answerObj = this.AddAnswerTo(this.MultipleChoiceDiv,
                                   this.MultipleChoiceAnswers);
    answerObj.Input.on('focus.answer',
                       function() {
                           self.AddBlankMultipleChoiceAnswer();
                       });
}

saQuestion.prototype.DialogApply = function () {
    this.Div.find('.sa-q').remove();
    this.Div.find('ol').remove();

    var tmp = $('<div>')
        .appendTo(this.Div)
        .addClass('sa-q')
        .text(this.Question.text());

    if (this.QuestionTypeSelect.val() == "Multiple Choice") {
        this.Div.attr('type','multiple-choice');
        tmp = $('<ol>')
            .appendTo(this.Div)
            .css({'margin':'0px 0px 0px 0.5em'});

        // Shuffle the answers.
        var shuffled = [];
        while (this.MultipleChoiceAnswers.length > 0) {
            var idx = Math.floor(Math.random() * this.MultipleChoiceAnswers.length);
            var answer = this.MultipleChoiceAnswers.splice(idx, 1)[0];
            shuffled.push(answer);
        }
        this.MultipleChoiceAnswers = shuffled;

        // Convert to html
        for (var i = 0; i < this.MultipleChoiceAnswers.length; ++i) {
            var answer = this.MultipleChoiceAnswers[i];
            if (answer.Input.text() != "") {
                var a = $('<li>')
                    .appendTo(tmp)
                    .addClass('sa-answer')
                    .text(answer.Input.text());
                if (answer.Check.is(':checked')) {
                    a.css({'font-weight':'bold'});
                    a.addClass('sa-true');
                }
            }
        }
    }
    if (this.QuestionTypeSelect.val == "True or False") {
        this.Div.attr('type','true-false');
        // TODO: Share code with multiple choice
        // TODO: Make true false be mutually exclusive (radio button).
        tmp = $('<ol>')
            .appendTo(this.Div)
            .css({'margin':'0px 0px 0px 0.5em'});
        for (var i = 0; i < this.TrueFalseAnswers.length; ++i) {
            var answer = this.TrueFalseAnswers[i];
            if (answer.Input.text() != "") {
                var a = $('<li>')
                    .appendTo(tmp)
                    .addClass('sa-true-false-answer')
                    .text(answer.Input.text());
                if (answer.Check.is(':checked')) {
                    a.css({'font-weight':'bold'});
                    a.addClass('sa-true');
                }
            }
        }
    }
    if (this.QuestionTypeSelect.val == "Short Answer") {
        this.Div.attr('type','short-answer');
        var tmp = $('<div>')
            .appendTo(this.Div)
            .addClass('sa-short-answer')
            .text(this.ShortAnswerDiv.text());
    }
}


//==============================================================================
// Make any div into a text editor.
// Will be used for the presentation html editor.
// Note,  scalable font should be set before text editor if you want scale buttons.
// TODO: 
// - The editor is position 'absolute' and is placed with percentages.
//   Make pixel positioning an option

// args: {dialog: true}
jQuery.prototype.saTextEditor = function(args) {
    for (var i = 0; i < this.length; ++i) {
        if ( ! this[i].saTextEditor) {
            var textEditor = new saTextEditor($(this[i]), args);
            // Add the viewer as an instance variable to the dom object.
            this[i].saTextEditor = textEditor;
            // TODO: Hide any dialog tabs?
        }
        this[i].saTextEditor.ProcessArguments(args);
    }

    return this;
}

// TODO: Figure out a way to get rid of this.
// content editable in divs do not consume key events.
// They propagate to parents. i.e. space causes a slide to advance.
//SA.ContentEditableHasFocus = false;

function saTextEditor(div) {
    var self = this;
    this.Div = div;
    this.Div.addClass('sa-text-editor');

    div.saText({click: function() {
        self.EditingOn();
    }});

    // Dialog tab
    var element = div[0].saElement;
    this.TextPanel = element.AddAccordionTab(
        "Text",
        function () {self.DialogInitialize();},
        function () {self.DialogApply();});

    // Font Size
    this.FontSizeDiv = $('<div>')
        .appendTo(this.TextPanel)
        .css({'height':'32px'})
        .addClass("sa-view-annotation-modal-div");
    this.FontSizeLabel = $('<div>')
        .appendTo(this.FontSizeDiv)
        .text("Font Size:")
        .addClass("sa-view-annotation-modal-input-label");
    this.FontSize = $('<input type="number">')
        .appendTo(this.FontSizeDiv)
        .addClass("sa-view-annotation-modal-input")
        .keypress(function(event) { return event.keyCode != 13; });

    // Font Color
    this.FontColorDiv = $('<div>')
        .appendTo(this.TextPanel)
        .css({'height':'32px'})
        .addClass("sa-view-annotation-modal-div");
    this.FontColorLabel = $('<div>')
        .appendTo(this.FontColorDiv)
        .text("Color:")
        .addClass("sa-view-annotation-modal-input-label");
    this.FontColor =
        $('<input type="text">')
        .appendTo(this.FontColorDiv)
        .val('#050505')
        .spectrum({showAlpha: true});

    // Line Height
    this.LineHeightDiv = $('<div>')
        .appendTo(this.TextPanel)
        .css({'height':'32px'})
        .addClass("sa-view-annotation-modal-div");
    this.LineHeightLabel = $('<div>')
        .appendTo(this.LineHeightDiv)
        .text("Line Height %:")
        .addClass("sa-view-annotation-modal-input-label");
    this.LineHeight = $('<input type="number">')
        .appendTo(this.LineHeightDiv)
        .addClass("sa-view-annotation-modal-input")
        .val(1)
        .keypress(function(event) { return event.keyCode != 13; });


    // Create a div for the editor options.
    // These will only become visible when you click / select
    this.Div.css({'overflow':'visible'}); // so the buttons are not cut off
    this.EditButtonDiv = $('<div>')
        .appendTo(this.Div.parent())
        .addClass('sa-edit-gui') // Remove before saHtml save.
        .css({'height':'20px',
              'position':'absolute',
              'width':'275px',
              'cursor':'auto'})
        .hide()
        // Block the saElement click event.
        .mousedown(function(){return false;});

    this.AddButton(SA.ImagePathUrl+"link.png", "link URL",
                   function() {self.InsertUrlLink();});
    this.AddButton(SA.ImagePathUrl+"font_bold.png", "bold",
                   function() {
                       document.execCommand('bold',false,null);});
    this.AddButton(SA.ImagePathUrl+"text_italic.png", "italic",
                   function() {document.execCommand('italic',false,null);});
    this.AddButton(SA.ImagePathUrl+"edit_underline.png", "underline",
                   function() {document.execCommand('underline',false,null);});
    this.AddButton(SA.ImagePathUrl+"list_bullets.png", "unorded list",
                   function() {document.execCommand('InsertUnorderedList',false,null);});
    this.AddButton(SA.ImagePathUrl+"list_numbers.png", "ordered list",
                   function() {document.execCommand('InsertOrderedList',false,null);});
    this.AddButton(SA.ImagePathUrl+"indent_increase.png", "indent",
                   function() {document.execCommand('indent',false,null);});
    this.AddButton(SA.ImagePathUrl+"indent_decrease.png", "outdent",
                   function() {document.execCommand('outdent',false,null);});
    this.AddButton(SA.ImagePathUrl+"alignment_left.png", "align left",
                   function() {document.execCommand('justifyLeft',false,null);});
    this.AddButton(SA.ImagePathUrl+"alignment_center.png", "align center",
                   function() {document.execCommand('justifyCenter',false,null);});
    this.AddButton(SA.ImagePathUrl+"alignment_full.png", "align full",
                   function() {document.execCommand('justifyFull',false,null);});
    this.AddButton(SA.ImagePathUrl+"edit_superscript.png", "superscript",
                   function() {document.execCommand('superscript',false,null);});
    this.AddButton(SA.ImagePathUrl+"edit_subscript.png", "subscript",
                   function() {document.execCommand('subscript',false,null);});
}

saTextEditor.prototype.EditingOn = function() {
    // Keep text editors from stepping on eachothers events.
    // Only one text editor can edit at a time.
    // I could look if body has the binding 'mousedown.textEditor', but the
    // is now a pain.
    if ($('body')[0].saTextEditing) {
        $('body')[0].saTextEditing.EditingOff();
    }
    $('body')[0].saTextEditing = this;

    var offset = 20;
    var pos = this.Div.position();
    var width = this.Div.outerWidth();
    if (width < 275) {width = 275;}
    var height = this.Div.outerHeight() + offset;
    this.EditButtonDiv
        .css({'left'  : pos.left+'px',
              'top'   :(pos.top-offset)+'px',
              'width' : width+'px',
              'height': height+'px'})
        .show();

    // mouse up because it should always propagate.
    var self = this;


    $('body').on(
        'mousedown.textEditor',
        function (e) {
            // We do not want click in the text box (or buttons) to turn
            // off editing.
            if ( self.Div[0] != e.srcElement &&
                 self.EditButtonDiv[0] != e.srcElement &&
                 ! $.contains(self.Div[0], e.srcElement) &&
                 ! $.contains(self.EditButtonDiv[0], e.srcElement)) {
                self.EditingOff();
            }
        });

    // Bad name. Actually movable.
    // TODO: Change this name.
    // hack
    this.Div[0].saElement.LockActive = true;
    this.SavedMovable = this.Div[0].saElement.Editable;
    this.Div[0].saElement.EditableOff();
    this.Div[0].saElement.Clickable = false;

    var self = this;
    this.Div
        .attr('contenteditable', 'true')
        .css({'cursor':'text'});

    SA.ContentEditableHasFocus = true;
}

saTextEditor.prototype.EditingOff = function() {
    delete $('body')[0].saTextEditing;
    $('body').off('mousedown.textEditor');

    // Convert the line heights of pasted text to percentages.
    // It will over ride line height set in the properties, maybe I can
    // clear the decendant line heights when the text line height is set
    // explicitly.  I could also ally line height to selected text, but
    // that would be messy.
    var decendants = this.Div.find('*');
    for (var i = 0; i < decendants.length; ++i) {
        if (decendants[i].style.lineHeight.indexOf('px') > -1) {
            var percentage = parseFloat(decendants[i].style.lineHeight);
            percentage = 100*percentage / parseFloat($(decendants[i]).css('font-size'))
            decendants[i].style.lineHeight = percentage.toString() + '%'; 
        }
    }

    // Grow the parent div to contain the text.
    var textHeight = this.Div[0].scrollHeight;
    if (textHeight > this.Div.outerHeight()) {
        if (this.Div.css('box-sizing') == 'border-box') {
            this.Div.height(textHeight + 4);
        } else {
            this.Div.outerHeight(textHeight + 4);
        }
        // Aspect ratio on TextEditor is not supported.
        this.Div.trigger('resize');
        this.Div[0].saElement.ConvertToPercentages();
    }

    this.EditButtonDiv.hide();
    // hack
    this.Div[0].saElement.LockActive = false;
    this.Div[0].saElement.ActiveOff();

    if (this.SavedMovable) {
        this.Div[0].saElement.EditableOn();
    }
    this.Div[0].saElement.Clickable = true;
    this.Div
        .attr('contenteditable', 'false')
        .off('mouseleave.textEditor');

    SA.ContentEditableHasFocus = false;
}

saTextEditor.prototype.AddButton = function(src, tooltip, callback, prepend) {
    var buttonsDiv = this.EditButtonDiv;

    var button = $('<img>')
        .addClass('editButton')
        .css({'height':'16px'})
        .attr('src',src);
    if (callback) {
        button.click(callback);
    }

    if (tooltip) {
        button.prop('title', tooltip);
    }

    if ( prepend) {
        button.prependTo(buttonsDiv);
    } else {
        button.appendTo(buttonsDiv);
    }

    return button;
}

saTextEditor.prototype.ProcessArguments = function(args) {
    args = args || {dialog : true};
    this.Div[0].saText.ProcessArguments(args);
}

saTextEditor.prototype.DialogInitialize = function() {
    var str;

    // iniitalize the values.
    if (this.Div[0].saScalableFont) {
        var scale = this.Div[0].saScalableFont.scale;
        var fontSize = Math.round(scale * 800);
        this.FontSize.val(fontSize);
    }

    var color = '#000000';
    str = this.Div[0].style.color;
    if (str != "") {
        color = SAM.ConvertColorToHex(str);
    }
    this.FontColor.spectrum('set',color);

    var lineHeight = 120; // default value?
    var str = this.Div[0].style.lineHeight;
    if (str != "") {
        if (str.substring(str.length-1) == "%") {
            lineHeight = parseFloat(str.substr(0,str.length-1));
        }
    }
    this.LineHeight.val(lineHeight);
}

saTextEditor.prototype.DialogApply = function() {
    //this.Div.css({'padding'      : '1%',
    //              'border-radius': '3px'});

    if (this.FontSize) {
        var scale = parseFloat(this.FontSize.val()) / 800;
        var jSel = this.Div;
        // It is contained in a parent scalable font, so just set the attribute.
        //jSel.setAttribute('sa-font-scale', scale.toString());
        jSel.saScalableFont({scale:scale});
    }

    if (this.LineHeight) {
        var lineHeight = parseFloat(this.LineHeight.val());
        this.Div[0].style.lineHeight = lineHeight + "%";
    }

    if (this.FontColor) {
        var color = this.FontColor.spectrum('get');
        this.Div[0].style.color = color;
    }
    
    var color = '#000000';
    str = this.Div[0].style.color;
    if (str != "") {
        color = str;
    }
    this.FontColor.spectrum('set',color);
}

saTextEditor.prototype.Delete = function() {
    this.Div.remove();
}

saTextEditor.prototype.InsertUrlLink = function() {
    var self = this;
    var sel = window.getSelection();
    // This call will clear the selected text if it is not in this editor.
    var range = SA.GetSelectionRange(this.Div);
    var selectedText = sel.toString();

    if ( ! this.UrlDialog) {
        var self = this;
        var dialog = new SAM.Dialog(
            function() {
                self.InsertUrlLinkAccept();
            });
        this.UrlDialog = dialog;
        dialog.Dialog.css({'width':'40em'});
        dialog.Title.text("Paste URL link");
        dialog.TextDiv =
            $('<div>')
            .appendTo(dialog.Body)
            .css({'display':'table-row',
                  'width':'100%'});
        dialog.TextLabel =
            $('<div>')
            .appendTo(dialog.TextDiv)
            .text("Text to display:")
            .css({'display':'table-cell',
                  'height':'2em',
                  'text-align': 'left'});
        dialog.TextInput =
            $('<input>')
            .appendTo(dialog.TextDiv)
            .val('#30ff00')
            .css({'display':'table-cell',
                  'width':'25em'});

        dialog.UrlDiv =
            $('<div>')
            .appendTo(dialog.Body)
            .css({'display':'table-row'});
        dialog.UrlLabel =
            $('<div>')
            .appendTo(dialog.UrlDiv)
            .text("URL link:")
            .css({'display':'table-cell',
                  'text-align': 'left'});
        dialog.UrlInput =
            $('<input>')
            .appendTo(dialog.UrlDiv)
            .val('#30ff00')
            .css({'display':'table-cell',
                  'width':'25em'})
            .on('input', function () {
                var url = self.UrlDialog.UrlInput.val();
                if (self.UrlDialog.LastUrl == self.UrlDialog.TextInput.val()) {
                    // The text is same as the URL. Keep them synchronized.
                    self.UrlDialog.TextInput.val(url);
                }
                self.UrlDialog.LastUrl = url;
                // Deactivate the apply button if the url is blank.
                if (url == "") {
                    self.UrlDialog.ApplyButton.attr("disabled", true);
                } else {
                    self.UrlDialog.ApplyButton.attr("disabled", false);
                }
            });

    }

    // We have to save the range/selection because user interaction with
    // the dialog clears the text entry selection.
    this.UrlDialog.SelectionRange = range;
    this.UrlDialog.TextInput.val(selectedText);
    this.UrlDialog.UrlInput.val("");
    this.UrlDialog.LastUrl = "";
    this.UrlDialog.ApplyButton.attr("disabled", true);
    this.UrlDialog.Show(true);
}

saTextEditor.prototype.InsertUrlLinkAccept = function() {
    var sel = window.getSelection();
    var range = this.UrlDialog.SelectionRange;
    if ( ! range) {
        range = SA.MakeSelectionRange(this.Div);
    }

    // Simply put a span tag around the text with the id of the view.
    // It will be formated by the note hyperlink code.
    var link = document.createElement("a");
    link.href = this.UrlDialog.UrlInput.val();
    link.target = "_blank";

    // It might be nice to have an id to get the href for modification.
    //span.id = note.Id;

    // Replace or insert the text.
    if ( ! range.collapsed) {
        // Remove the seelcted text.
        range.extractContents(); // deleteContents(); // cloneContents
        range.collapse(true);
    }
    var linkText = this.UrlDialog.TextInput.val();
    if (linkText == "") {
        linkText = this.UrlDialog.UrlInput.val();
    }
    link.appendChild( document.createTextNode(linkText) );

    range.insertNode(link);
    if (range.noCursor) {
        // Leave the selection the same as we found it.
        // Ready for the next link.
        sel.removeAllRanges();
    }
}

// This does not work yet.!!!!!!!!!!!!!!!
// Returns the jquery object selected.  If a partial object is selected,
// the dom is split up into fragments.
saTextEditor.prototype.GetSelection = function() {
    var sel = window.getSelection();
    var range;
    var parent = null;

    // Two conditions when we just return the top level div:
    // nothing selected, and something selected in wrong parent.
    // use parent as a flag.
    if (sel.rangeCount > 0) {
        // Something is selected
        range = sel.getRangeAt(0);
        range.noCursor = false;
        // Make sure the selection / cursor is in this editor.
        parent = range.commonAncestorContainer;
        // I could use jquery .parents(), but I bet this is more efficient.
        while (parent && parent != this.Div[0]) {
            //if ( ! parent) {
                // I believe this happens when outside text is selected.
                // We should we treat this case like nothing is selected.
                //console.log("Wrong parent");
                //return;
            //}
            if (parent) {
                parent = parent.parentNode;
            }
        }
    }
    if ( ! parent) {
        return this.Div;
    }

    // Insert the fragments without a container.
    var children = range.extractContents().children;
    for (var i = 0; i < children.length; ++i) {
        range.insertNode(children[i]);
    }
    return $(children);
    
    // Create a new span around the fragment.
    //var newNode = document.createElement('span');    
    //newNode.appendChild(range.extractContents()); 
    //range.insertNode(newNode)
    //return $(newNode);
}

// Set in position in pixels
saTextEditor.prototype.SetPositionPixel = function(x, y) {
    if (this.Percentage) {
        x = 100 * x / this.Div.parent().width();
        y = 100 * y / this.Div.parent().height();
        this.Div[0].style.left = x.toString()+'%';
        this.Div[0].style.top = y.toString()+'%';
    } else {
        this.Div[0].style.left = x+'px';
        this.Div[0].style.top = y+'px';
    }
}



//==============================================================================
// a "subclass" of saElement.
// Click expands the element.
// TODO:
// Do not expand images larger than their native resolution (double maybe?)
// Change answer to question in the properties menu.
// Camera gets restored on shrink (even in edit mode) 
//   Maybe push pin or camera icon to capture changes


jQuery.prototype.saLightBox = function(arg1) { // 'arguments' handles extras.
    // Superclass constructor.
    this.saElement();
    this.addClass('sa-light-box');
    for (var i = 0; i < this.length; ++i) {
        if ( ! this[i].saLightBox) {
            var helper = new saLightBox($(this[i]));
            // Add the helper as an instance variable to the dom object.
            this[i].saLightBox = helper;
        }
        this[i].saLightBox.ProcessArguments(arguments);
    }

    return this;
}

function saLightBox(div) {
    var self = this;
    div[0].saElement.SetClickCallback(function() {self.Expand(true);});

    this.Div = div;
    this.Expanded = false;
    this.ExpandCallback = null;
    this.AspectRatio = false;
    this.Interactive = true;

    // Mask is to gray out background and consume events.
    // All lightbox items in this parent will share a mask.
    var parent = div.parent();
    this.Mask = parent.find('.sa-light-box-mask');
    if ( this.Mask.length == 0) {
        this.Mask = $('<div>')
            .appendTo(parent)
            .addClass('sa-light-box-mask') // So it can be retrieved.
            .addClass('sa-edit-gui') // Remove before saHtml save.
            .hide()
            .css({'position':'absolute',
                  'left':'0px',
                  'top':'0px',
                  'width':'100%',
                  'height':'100%',
                  'z-index':'99',
                  'opacity':'0.5',
                  'background-color':'#000'});
    }
}

saLightBox.prototype.ProcessArguments = function(args) {
    if (args.length == 0) { return; }

    // Superclass
    this.Div[0].saElement.ProcessArguments(args);

    // generic method call. Give jquery ui access to all this objects methods.
    if (typeof(this[args[0]]) == 'function') {
        // first list item is the method name, 
        // the rest are arguments to the method.
        return this[args[0]].apply(this, Array.prototype.slice.call(args,1));
    }

    // Handle the legacy behavior. 
    // One argument: an object (like jqueryUI).
    args = args[0];


    if (args.aspectRatio !== undefined) {
        this.AspectRatio = args.aspectRatio;
    }

    // lightbox and element editable flags are not always the same.
    // When expanded, The element editable is turned off.
    if (args.editable !== undefined) {
        this.Editable = args.editable;
    }

    // External control of expanding or shrinking.
    if (args.expand !== undefined) {
        this.Expand(args.expand, args.animate);
    }

    if (args.Interactive !== undefined) {
        this.Interactive = args.interactive;
    }

    // Callback when expanded state changes.
    // Viewer interaction is only enabled when the element expands.
    if (args.onExpand) {
        this.ExpandCallback = args.onExpand;
    }
}

// I cannot put this directly as a callback because it 
// overwrites the viewer resize method.
saLightBox.prototype.UpdateSize = function() {
    if ( ! this.Expanded) { return; }

    var self = this;
    var left = '5%';
    var top = '5%';
    var width = '90%';
    var height = '90%';
    if (this.AspectRatio) {
        // Hack to get expanded images to resize.
        if ( ! this.Div[0].onresize) {
            this.Div[0].onresize =
                function() {
                    self.UpdateSize();
                };
            this.Div.addClass('sa-resize');
        }

        // Compute the new size.
        var ratio = this.Div.width() / this.Div.height();
        var pWidth = this.Div.parent().width();
        var pHeight = this.Div.parent().height();
        width = Math.floor(pWidth * 0.9);
        height = Math.floor(pHeight * 0.9);
        if (width / height > ratio) {
            width = Math.floor(height * ratio);
        } else {
            height = Math.floor(width / ratio);
        }
        left = Math.floor(0.5*(pWidth-width)) + 'px';
        top = Math.floor(0.5*(pHeight-height)) + 'px';
        width = width + 'px';
        height = height + 'px';
    }

    // Make the image big
    // Not resize handles have z-index 1000 !
    // I am close to just implementing my own resize feature.
    this.Div.css({'z-index':'1001'});
    this.Div.css({'left'  : left,
                  'top'   : top,
                  'width' : width,
                  'height': height});
}

saLightBox.prototype.Expand = function(flag, animate) {
    if ( ! this.Interactive) {return;}
    if (flag == this.Expanded) { return; }
    var self = this;
    if (flag) {
        this.Div.saElement({editable:false});
        // We have to disable teh expand behavior too.
        this.Expanded = true;
        
        // Save the current position and size.
        this.SavedTop = this.Div[0].style.top;
        this.SavedLeft = this.Div[0].style.left;
        this.SavedWidth = this.Div[0].style.width;
        this.SavedHeight = this.Div[0].style.height;
        this.SavedZIndex = this.Div[0].style.zIndex;

        // Make the image big
        // Not resize handles have z-index 1000 !
        // I am close to just implementing my own resize feature.
        this.Div.css({'z-index':'1001'});
        this.UpdateSize();
        this.Div.trigger('resize');

        // Show the mask.
        this.Mask.show();
        // Clicking outside the div will cause the div to shrink back to
        // its original size.
        this.Mask.on(
            'mousedown.lightbox',
            function () {
                self.Expand(false, true);
            });
    } else {
        // Reverse the expansion.
        // hide the mask
        this.Mask.hide();
        // remove event to shrink div.
        this.Mask.off('mousedown.lightbox');
        if (animate) {
            this.Div.animate({'top':self.SavedTop,
                              'left':self.SavedLeft,
                              'width':self.SavedWidth,
                              'height':self.SavedHeight,
                              'z-index':self.SavedZIndex},
                             {step: function () {self.Div.trigger('resize');}});

        } else {
            this.Div.css({'top':self.SavedTop,
                          'left':self.SavedLeft,
                          'width':self.SavedWidth,
                          'height':self.SavedHeight,
                          'z-index':self.SavedZIndex});
        }
        this.Expanded = false;
        if (this.Editable) {
            this.Div.saElement({editable:true});
        }
    }

    // External changes with editability (viewer interaction).
    if (this.ExpandCallback) {
        (this.ExpandCallback)(flag);
    }
    this.Div.trigger('resize');
}


//==============================================================================
// Combination of lightbox and viewer.
// This simply manages the switch betweenlight box interaction and viewer
// interaction.

jQuery.prototype.saLightBoxViewer = function(args) {
    if ( ! args.hideCopyright) {
        args.hideCopyright = true;
    }
    // No zoom widget when minimized.
    if ( ! args.zoomWidget) {
        args.zoomWidget = false;
    }
    if ( ! args.dualWidget) {
        args.dualWidget = false;
    }
    if ( ! args.navigation) {
        args.navigation = false;
    }
    if ( args.interaction === undefined) {
        args.interaction = false;
    }

    // Small viewer does not have overview
    args.overview = false;

    // sa viewer is separate.  We need to pass the args to saLightBoxToo.
    this.saViewer(args);
    // sa viewer is separate.  We need to pass the args to saLightBoxToo.
    args.onExpand = 
        function (expanded) {
            this.Div.saViewer({interaction:expanded});
            if (expanded) {
                this.Div.saViewer({overview  : true,
                                   navigation: true,
                                   menu      : true,
                                   zoomWidget: true,
                                   dualWidget: true,
                                   drawWidget: true});
            } else {
                this.Div.saViewer({overview  : false,
                                   navigation: false,
                                   menu      : false,
                                   zoomWidget: false,
                                   dualWidget: false,
                                   drawWidget: false});
                // This is here to restore the viewer to its
                // initial state when it shrinks
                // TODO: Formalize this hack. Viewer formally needs a note.
                // If not editable, restore the note.
                var display = this.Div[0].saViewer;
                var note = display.saNote;
                if ( ! this.Div[0].saLightBox.Editable && note) {
                    var index = display.saViewerIndex || 0;
                    display.SetNote(note, index);
                }
            }
        };
    this.saLightBox(args);

    this.addClass('sa-lightbox-viewer');

    return this;
}



//==============================================================================
// A common dialog class for all sa objects.
// Abstraction of text dialog for rectangles.
// Internal helper.
function saGetDialog(domElement, showCallback, applyCallback) {
    if ( ! domElement.saDialog) {
        var helper = new SAM.Dialog(function () {saDialogApplyCallback(domElement);});
        if ( ! helper.ShowCallbacks) { helper.ShowCallbacks = []; }
        if ( ! helper.ApplyCallbacks) { helper.ApplyCallbacks = []; }
        saAddButton(domElement, SA.ImagePathUrl+"Menu.jpg", "properties",
                    function() { saDialogShowCallback(domElement); });
        domElement.saDialog = helper;
    }
    // I assume that the users will add variables to the dialog.
    if (showCallback) {domElement.saDialog.ShowCallbacks.push(showCallback);}
    if (applyCallback) {domElement.saDialog.ApplyCallbacks.push(applyCallback);}
    return domElement.saDialog;
}

// Remove the dialog.
// Incomplete. I need to remove the dialog button.
var saDialogDelete = function(element) {
    if ( ! element.saDialog) { return; }
    element.saDialog.Dialog.Body.empty;
    delete element.saDialog;
    //element.saDelete.ButtonsDiv.remove();
}

var saDialogShowCallback = function(element) {
    var callbacks = element.saDialog.ShowCallbacks;
    for (var i = 0; i < callbacks.length; ++i) {
        (callbacks[i])(element);
    }
    element.saDialog.Show(true);
}


var saDialogApplyCallback = function(element) {
    var callbacks = element.saDialog.ApplyCallbacks;
    for (var i = 0; i < callbacks.length; ++i) {
        (callbacks[i])(element);
    }
}




//==============================================================================
// This is legacy and not used anymore.
// A common parent for all sa buttons (for this element).
// Handle showing and hiding buttons.  Internal helper.

// Just for enabling and disabling the edit buttons
// cmd: "enable" or "disable"

// Only one set of buttons are visible at a time.
var SA_BUTTONS_VISIBLE = null;

jQuery.prototype.saButtons = function(cmd) {
    if (cmd == 'enable') {
        for (var i = 0; i < this.length; ++i) {
            saButtonsEnable(this[i]);
        }
    }
    if (cmd == 'disable') {
        for (var i = 0; i < this.length; ++i) {
            saButtonsDisable(this[i]);
        }
    }
}


function saGetButtonsDiv(domElement) {
    if ( ! domElement.saButtons) {
        // Edit buttons.
        var helper = new saButtons($(domElement));
        domElement.saButtons = helper;
    }
    return domElement.saButtons.ButtonsDiv;
}

function saButtons (div) {
    this.Enabled = true;
    this.Div = div;
    this.TimerId = -1;
    var pos = div.position();
    this.ButtonsDiv = $('<div>')
        .appendTo(div.parent())
        .addClass('sa-edit-gui') // So we can remove it when saving.
        .hide()
        .css({'position':'absolute',
              'left'  :(pos.left+10)+'px',
              'top'   :(pos.top-20) +'px',
              'width' :'360px', // TODO: see if we can get rid of the width.
              'z-index': '10'});
    // Make it easy to enable and disable these edit buttons.
    this.ButtonsDiv[0].saButtons = this;
    // Show the buttons on hover.
    var self = this;
    this.ButtonsDiv
        .mouseenter(function () { self.ShowButtons(2); })
        .mouseleave(function () { self.HideButtons(); });

    this.Div
        .mouseenter(function () { self.ShowButtons(1); })
        .mouseleave(function () { self.HideButtons(); });
}

saButtons.prototype.PlaceButtons = function () {
    var pos = this.Div.position();
    this.ButtonsDiv
        .css({'left'  :(pos.left+10)+'px',
              'top'   :(pos.top-20) +'px'});
}

saButtons.prototype.ShowButtons = function (level) {
    if (this.TimerId >= 0) {
        clearTimeout(this.TimerId);
        this.TimerId = -1;
    }
    if (this.Enabled) {
        if (SA_BUTTONS_VISIBLE && SA_BUTTONS_VISIBLE != this.ButtonsDiv) {
            SA_BUTTONS_VISIBLE.fadeOut(200);
            SA_BUTTONS_VISIBLE = this.ButtonsDiv;
        }
        this.PlaceButtons();
        if (level == 1) {
            this.ButtonsDiv
                .fadeIn(400);
            this.ButtonsDiv.children()
                .css({'opacity':'0.4'});
        } else {
            this.ButtonsDiv
                .show();
            this.ButtonsDiv.children()
                .css({'opacity':'1.0'});
        }
    }
}

saButtons.prototype.HideButtons = function () {
    if (this.TimerId < 0) {
        var self = this;
        this.TimerId =
            setTimeout(function () {
                if (SA_BUTTONS_VISIBLE == self.ButtonsDiv) {
                    SA_BUTTONS_VISIBLE = null;
                }
                self.ButtonsDiv.fadeOut(200);
            }, 200);
    }
}


function saAddButton (domElement, src, tooltip, callback, prepend) {
    var buttonsDiv = saGetButtonsDiv(domElement);

    var button = $('<img>')
        .addClass('editButton')
        .css({'height':'16px'})
        .attr('src',src);
    if (callback) {
        button.click(callback);
    }

    if (tooltip) {
        button.prop('title', tooltip);
    }

    if ( prepend) {
        button.prependTo(buttonsDiv);
    } else {
        button.appendTo(buttonsDiv);
    }

    return button;
}

// private functions.
// TODO: Make an api through jquery to do this.
function saButtonsDisable (element) {
    if ( ! element.saButtons) { return; }
    element.saButtons.Enabled = false;
    element.saButtons.ButtonsDiv.hide();
}

function saButtonsEnable (element) {
    if ( ! element.saButtons) { return; }
    element.saButtons.Enabled = true;
}

// Remove the buttons div.
function saButtonsDelete (element) {
    if ( ! element.saButtons) { return; }
    element.saButtons.ButtonsDiv.remove();
}



//==============================================================================
// Load html into a div just like .html, but setup slide atlas jquery
// extensions.  The state of these extensions is saved in attributes.
// The extension type is saved as a class.

jQuery.prototype.saHtml = function(string) {
    if (string) {
        this.html(string);
        this.find('.sa-scalable-font').saScalableFont();
        //this.find('.sa-full-window-option').saFullWindowOption();
        // TODO: Move this out of this file.
        this.find('.sa-presentation-rectangle').saRectangle();
        // Change legacy sa-presentation-view into sa-lightbox-viewer
        this.find('.sa-presentation-view')
            .addClass('sa-lightbox-viewer')
            .removeClass('sa-presentation-view');
        // Get rid of the extra handles we no longer use.
        // the ui-resiable was flakey.  It was eaiser just to code the
        // behavior myself.
        this.find('.ui-resizable-handle').remove();
        this.find('.ui-resizable').removeClass('ui-resizable');

        // We need to load the note.
        viewDivs = this.find('.sa-lightbox-viewer');
        viewDivs.saLightBoxViewer({'hideCopyright': true,
                                   'interaction':   false});

        for (var i = 0; i < viewDivs.length; ++i) {
            var display = viewDivs[i].saViewer;
            var noteId = $(viewDivs[i]).attr('sa-note-id');
            var viewerIdx = $(viewDivs[i]).attr('sa-viewer-index') || 0;
            viewerIdx = parseInt(viewerIdx);
            // TODO: This should not be here.
            // The saViewer should handle this internally.
            if (noteId) {
                display.SetNoteFromId(noteId, viewerIdx);
            }
        }

        if (SA.Edit) {
            var items = this.find('.sa-resizable');
            // temporary to make previous editors draggable.
            items = this.find('.sa-text-editor');
            items.saTextEditor({editable:true});

            items = this.find('.sa-presentation-rectangle');
            items.saRectangle({editable:true});

            items = this.find('.sa-question');
            items.saQuestion({editable:true});

            items = this.find('.sa-presentation-image');
            items.saLightBox({aspectRatio: true,
                              editable   : true});

            items = this.find('.sa-lightbox-viewer');
            items.saViewer({drawWidget: false});
        } else {
            // I need the text to show when the bounds are too small.
            items = this.find('.sa-text-editor');
            items.css({'overflow':'visible'});
        }

        return;
    }

    // Shrink any light box elements that are expanded.
    this.find('.sa-light-box').saLightBox({'expand':false, 'animate':false});

    // Items that are not visible loos their position.
    this.find('.sa-quiz-hide').show();
    this.find('.sa-presentation-title').show();

    // Get rid of the <gui elements when returning the html.
    var copy = this.clone();
    copy.find('.sa-edit-gui').remove();
    copy.find('.sa-standin').remove();
    copy.find('.ui-resizable').resizable('destroy');
    //copy.find('.ui-resizable-handle').remove();

    // Get rid of the children of the sa-presentation-view.
    // They will be recreated by viewer when the html is loaded.
    copy.find('.sa-lightbox-viewer').empty();

    return copy.html();
}


//==============================================================================
// LEGACY
// Just add the feature of setting width and height as percentages.

jQuery.prototype.saResizable = function(args) {
    args = args || {};
    args.start = function (e, ui) {
        if ( this.saViewer) {
            // Translate events were being triggered in the viewer.
            this.saViewer.DisableInteraction();
        }
    };
    args.stop = function (e, ui) {
        // change the width to a percentage.
        var width = $(this).width();
        width = 100 * width / $(this).parent().width();
        this.style.width = width.toString()+'%';
        // change the height to a percentage.
        var height = $(this).height();
        height = 100 * height / $(this).parent().height();
        this.style.height = height.toString()+'%';

        // We have to change the top and left ot percentages too.
        // I might have to make my own resizable to get the exact behavior
        // I want.
        var pos  = $(this).position();
        var top  = 100 * pos.top / $(this).parent().height();
        var left = 100 * pos.left / $(this).parent().width();
        this.style.top  = top.toString()+'%';
        this.style.left = left.toString()+'%';
    };

    this.addClass('sa-resizable');

    return this;
}




//==============================================================================
// Attempting to make the viewer a jqueryUI widget.
// Note:  It does not make sense to call this on multiple divs at once when
//        the note/view is being set.
// args = {interaction:true,
//         overview:true,
//         menu:true, 
//         drawWidget:true,
//         zoomWidget:true,
//         viewId:"55f834dd3f24e56314a56b12", note: {...}
//         viewerIndex: 0,
//         hideCopyright: false}
// viewId (which loads a note) or a preloaded note can be specified.
// the viewId has precedence over note if both are given.
// viewerIndex of the note defaults to 0.
// Note: hideCopyright will turn off when a new note is loaded.
jQuery.prototype.saViewer = function(args) {
    // default
    args = args || {};
    // This is ignored if there is not viewId or note.
    args.viewerIndex = args.viewerIndex || 0;
    // get the note object if an id is specified.
    if (args.viewId) {
        args.note = GetNoteFromId(args.viewId);
        if (args.note == null) {
            // It has not been loaded yet.  Get if from the server.
            args.note = new SA.Note();
            var self = this;
            args.note.LoadViewId(
                args.viewId,
                function () {
                    saViewerSetup(self, args);
                });
            return this;
        }
    }
    saViewerSetup(this, args);
    return this;
}

// I am struggling for an API to choose between single view and dual view.
// - I considered saDualViewer, but it is nearly identical to saViewer and
// saLightBoxViewer does not know which to create because it does not have
// the note early enough.
// - I consider hinging it on the existence of sa-viewer-index but that is
// hidden and not obvious.
// I choose to pass an argument flag "dual", but am sure how to store the
// flag in html. I could have an attribute "dual", but I think I like to 
// change the class from sa-viewer to sa-dual-viewer better. 
// TODO: Make the argument calls not dependant on order.
function saViewerSetup(self, args) {
    //TODO: Think about making this viewer specific rather than a global.
    if (args.prefixUrl) {
        SA.ImagePathUrl = args.prefixUrl;
        SAM.ImagePathUrl = args.prefixUrl;
    }

    $(window)
        .off('resize.sa')
        .on('resize.sa', saResizeCallback);

    for (var i = 0; i < self.length; ++i) {
        if (args == 'destroy') {
            $(self[i]).removeClass('sa-resize');
            // This should not cause a problem.
            // Only one resize element should be using this element.
            $(self[i]).removeClass('sa-resize');
            $(self[i]).removeClass('sa-viewer');
            if (self[i].saViewer) {
                self[i].saViewer.Delete();
                delete self[i].saViewer;
            }
            continue;
        }

        if ( ! self[i].saViewer) {
            if (args.dual == undefined) {
                // look for class name.
                if (self.hasClass('sa-dual-viewer')) {
                    args.dual = true;
                }
            }

            // Add the viewer as an instance variable to the dom object.
            if (args.dual) {
                // TODO: dual has to be set on the first call.  Make this
                // order independant. Also get rid of args here. We should
                // use process arguments to setup options.
                self[i].saViewer = new SA.DualViewWidget($(self[i]));
            } else {
                self[i].saViewer = new SA.Viewer($(self[i]));
            }

            // When the div resizes, we need to synch the camera and
            // canvas.
            self[i].onresize =
                function () {
                    this.saViewer.UpdateSize();
                }
            // Only the body seems to trigger onresize.  We need to trigger
            // it explicitly (from the body onresize function).
            $(self[i]).addClass('sa-resize');
        }
        self[i].saViewer.ProcessArguments(args);
    }
}

// This put changes from the viewer in to the note.
// Is there a better way to do this?
// Maybe a save method?
jQuery.prototype.saRecordViewer = function() {
    for (var i = 0; i < this.length; ++i) {
        if (this[i].saViewer && this[i].saViewer.saNote) {
            var idx = this[i].saViewer.saViewerIndex || 0;
            var note = this[i].saViewer.saNote;
            this[i].saViewer.Record(note, idx);
        }
    }
}





//==============================================================================
// JQuery items are not responding to resize events.  This fixes the
// problem by using window resize event for all
// NOTE: This depends on saFullSize callbacks.
jQuery.prototype.saOnResize = function(callback) {
    this.addClass('sa-resize');
    for (var i = 0; i < this.length; ++i) {
        this[i].onresize = callback;
    }

    return this;
}

jQuery.prototype.saTriggerResize = function() {
     $(window).trigger('resize');
}


//==============================================================================
// jQuery extension for a full window div.
// parent must be the body?  Maybe not.  Lets see if a full height is better.
// I think position should be set to fixed or absolute.

// TODO: Convert the viewer to use this.

function saResizeCallback() {
    var height = window.innerHeight;
    var width = window.innerWidth;
    var top = 0;
    var left = 0;
    items = $('.sa-full-height');
    for (var i = 0; i < items.length; ++i) {
        item = items[i];
        $(item).css({'top': '0px',
                     'height': height+'px'});
    }
    // Hack until I can figure out why the resize event is not
    // firing for descendants.
    // This did not work.  It also triggered resize on the window
    // causeing infinite recusion.
    //$('.sa-resize').trigger('resize');
    // call onresize manually.
    var elements = $('.sa-resize');
    for (var i = 0; i < elements.length; ++i) {
        if (elements[i].onresize) {
            elements[i].onresize();
        }
    }
}

// Args: not used
jQuery.prototype.saFullHeight = function(args) {
    this.css({'top':'0px'});
    this.addClass('sa-full-height');
    for (var i = 0; i < this.length; ++i) {
        // I want to put the resize event on "this[i]",
        // but, I am afraid it might not get trigerend always, or
        // setting the height would cause recursive calls to resize.
        this[i].saFullHeight = args;
    }

    $(window)
        .off('resize.sa')
        .on('resize.sa', saResizeCallback)
        .trigger('resize');

    return this;
}


//==============================================================================
// Make this window as large as possible in parent, but keep the aspect
// ratio. This is for presentation windows.
// Note:  Position of parent has to be not static.
//        Should I make the position relative rather than absolute?
jQuery.prototype.saPresentation = function(args) {
    this.addClass('sa-presentation');
    this.addClass('sa-resize');

    $(window)
        .off('resize.sa')
        .on('resize.sa', saResizeCallback)
        .trigger('resize');

    for (var i = 0; i < this.length; ++i) {
        var item = this[i];
        if ( ! item.saPresentation) {
            item.saPresentation = new saPresentation($(item),args);
            item.onresize =
                function () {
                    this.saPresentation.Resize();
                };
        }
        // Trouble if their is more than 1.  Maybe trigger
        // a window resize?
        setTimeout(function(){ item.saPresentation.Resize(); }, 300);
    }

    return this;
}

function saPresentation(div, args) {
    this.Div = div;
    this.AspectRatio = args.aspectRatio;
    this.Zoom = 1.0;
    this.ShiftX = 0;
    this.ShiftY = 0;

    // Setup events to pan and zoom the presentation window.
    var self = this;
    /*this.Div.on(
        'mousedown.presentation',
        function (e) {
            return self.HandleMouseDown(e);
        });
    */
    //Text is not scaling properly
    /*
    this.Div.on(
        'mousewheel.presentation',
        function(event){
            // Resize from the middle.
            return self.HandleMouseWheel(event.originalEvent);
        });
        */
}

saPresentation.prototype.Resize = function () {
    var ar = this.AspectRatio;
    var parent = this.Div.parent();
    var pWidth = parent.innerWidth();
    var pHeight = parent.innerHeight();
    var width = pWidth;
    var height = pHeight
    if (width / height > ar) {
        // Window is too wide.
        width = height * ar;
    } else {
        // Window is too tall.
        height = width / ar;
    }
    width = width * this.Zoom;
    height = height * this.Zoom;
    var left = (pWidth - width)*0.5 + this.ShiftX;
    var top = (pHeight - height)*0.5 + this.ShiftY;

    this.Div.css({
        'position': 'absolute',
        'top': top+'px',
        'height': height+'px',
        'left': left+'px',
        'width': width+'px'});
}

saPresentation.prototype.HandleMouseDown = function (event) {
    var self = this;
    // For tap/click rather than drag.
    this.ClickStart = Date.now();

    if (event.which == 1 || event.which == 3) {
        $('body').on(
            'mouseup.presentation',
            function (e) {
                return self.HandleMouseUp(e);
            });
    }

    if (event.which == 1) {
        $('body').on(
            'mousemove.presentation',
            function (e) {
                return self.HandleMouseMove(e);
            });
        $('body').on(
            'mouseleave.presentation',
            function(e) {
                return self.HandleMouseUp(e);
            });
        this.DragLastX = event.screenX;
        this.DragLastY = event.screenY;

        return false;
    }
}

// TODO: rethink offset/zoom.  Scale from the middle. Offset should
// be in percentages maybe
saPresentation.prototype.HandleMouseWheel = function(event) {
    var tmp = 0;
    if (event.deltaY) {
        tmp = event.deltaY;
    } else if (event.wheelDelta) {
        tmp = event.wheelDelta;
    }
    if (tmp == 0) { return;}
    // Wheel event seems to be in increments of 3.
    // depreciated mousewheel had increments of 120....
    // Initial delta cause another bug.
    // Lets restrict to one zoom step per event.
    if (tmp > 0) {
        this.Zoom *= 1.01;
    } else if (tmp < 0) {
        this.Zoom *= .99;
    }
    this.Resize();

    return false;
}

saPresentation.prototype.HandleMouseMove = function (event) {
    // Wait for the click duration to start dragging.
    if (Date.now() - this.ClickStart < 200) {
        return true;
    }

    if (event.which == 1) {
        var dx = event.screenX - this.DragLastX;
        var dy = event.screenY - this.DragLastY;
        this.DragLastX = event.screenX;
        this.DragLastY = event.screenY;

        this.ShiftX += dx;
        this.ShiftY += dy;
        this.Resize();
        return false;
    }
    return true;
}

saPresentation.prototype.HandleMouseUp = function (event) {
    $('body').off('mouseup.presentation');
    if (event.which == 1) {
        $('body').off('mousemove.presentation');
        $('body').off('mouseleave.presentation');
    }

    return true;
}



//==============================================================================
// Font is set as a percentage of the parent height.
// args.size: string i.e. "12%" More work would be needed to make this
// units in pixels.
jQuery.prototype.saScalableFont = function(args) {
    this.addClass('sa-scalable-font');
    this.addClass('sa-resize');

    $(window)
        .off('resize.sa')
        .on('resize.sa', saResizeCallback);

    for (var i = 0; i < this.length; ++i) {
        var text = this[i];
        if ( ! text.saScalableFont) {
            text.onresize =
                function () {
                    scale = this.saScalableFont.scale;
                    // Scale it relative to the window.
                    var height = $(this).parent().innerHeight();
                    fontSize = Math.round(scale * height) + 'px';
                    this.style.fontSize = fontSize;
                    // Getting and setting the html creates text chidlren
                    // with their own font size.
                    $(this).children('font').css({'font-size':fontSize});
                };
            text.saScalableFont = {};
            text.saScalableFont.scale = 0.1;
        }
        var scale = text.saScalableFont.scale;
        // html() saves this attribute.
        // this will restore the scale.
        var scaleStr = text.getAttribute('sa-font-scale');
        if (scaleStr) {
            scale = parseFloat(scaleStr);
        }
        // This overrides the previous two.
        if (args && args.scale) {
            // convert to a decimal.
            scale = args.scale;
            if (typeof(scale) == "string") {
                if (scale.substring(-1) == "%") {
                    scale = parseFloat(scale.substr(0,str.length-1))/100;
                } else {
                    scale = parseFloat(scale);
                }
            }
        }
        // I can either keep this up to date or set it when the
        // saHtml is called. Keeping it set is more local.
        text.setAttribute('sa-font-scale', scale.toString());
        text.saScalableFont.scale = scale;
        text.onresize();
    }

    return this;
}



//==============================================================================
// legacy: not used anymore
// draggable with a handle
// TODO: This uses percentages now.  Exxtend with the option to position
// with pixel units.
// args = {grid: [xDivisions, yDivisions]}
jQuery.prototype.saDraggable = function(args) {
    args = args || {grid:[30,39]};
    this.addClass('sa-draggable');
    for (var i = 0; i < this.length; ++i) {
        if ( ! this[i].saDraggable) {
            var helper = new saDraggable($(this[i]));
            // Add the helper as an instance variable to the dom object.
            this[i].saDraggable = helper;
        }
        this[i].saDraggable.ProcessArguments(args);
    }

    return this;
}

function saDraggable(div) {
    this.XStops = null;
    this.YStops = null;
    this.Percentage = true;
    this.Div = div;

    var self = this;
    var d = saAddButton(div[0], SA.ImagePathUrl+'fullscreen.png',
                        'drag', null, true);
    d.mousedown(
        function (e) {
            // raise to the top of the layers.
            // this did not work for text boxes on top of views.
            // it did work for mutiple views.
            var parent = self.Div.parent();
            self.Div.detach();
            self.Div.appendTo(parent);


            self.Div.css({'z-index':'5'});


            self.OldX = e.pageX;
            self.OldY = e.pageY;

            var pos = self.Div.position();
            var x = pos.left;
            var y = pos.top;
            var width = self.Div.parent().width();
            var height = self.Div.parent().height();
            if (self.XStops) { self.XStops.Start(x,width);}
            if (self.YStops) { self.YStops.Start(y,height);}
            $('body').on('mousemove.saDrag',
                      function (e) {
                          self.Drag(e.pageX-self.OldX, e.pageY-self.OldY);
                          self.OldX = e.pageX;
                          self.OldY = e.pageY;
                          return false;
                      });
            $('body').on('mouseup.saDrag',
                      function (e) {
                          self.Div.css('z-index', '');
                          $('body').off('mousemove.saDrag');
                          $('body').off('mouseup.saDrag');
                          return false;
                      });
            return false;
        });
}

saDraggable.prototype.ProcessArguments = function(args) {
    if (args.grid) {
        // The grid is not shared.
        this.XStops = new saStops(args.grid[0]);
        this.YStops = new saStops(args.grid[1]);
    }
}

// (dx, dy) drag vector in pixels.
saDraggable.prototype.Drag = function(dx, dy) {
    var pos = this.Div.position();
    var x = pos.left;
    var y = pos.top;

    var width = this.Div.parent().width();
    var height = this.Div.parent().height();
    var nx = x + dx;
    var ny = y + dy;
    if (this.XStops) {
        nx = this.XStops.Drag(dx);
    }
    if (this.YStops) {
        ny = this.YStops.Drag(dy);
    }

    if (this.Percentage) {
        nx  = nx / width;
        ny  = ny / height;
        nx = nx*100;
        ny = ny*100;
        this.Div[0].style.left = nx+'%';
        this.Div[0].style.top  = ny+'%';
    } else {
        this.Div[0].style.left = nx+'px';
        this.Div[0].style.top  = ny+'px';
    }

    this.Div[0].saButtons.PlaceButtons();
}


function saStops(divisions) {
    // How far do we hve to pass a stop before the item snaps to the mouse.
    this.Threshold = 25;
    // Current Stop
    this.Stopped = false;
    this.Stop = 0;  // TODO: This is not necessary.  Just use last.
    // The amount of drag saved up so far to get out of a stop.
    this.Delta = 0;

    // For speed up factor to account for stopped regions.
    this.Target = 0;
    this.Gap = 100.0;

    // Even positioning of the division.
    this.Divisions = divisions;
    // The current position of the item.
    this.Last = 0;
}


saStops.prototype.Start = function(last, size) {
    this.Stopped = false;
    this.Delta = 0;
    this.Last = last;
    this.Size = size;

    this.Target = last;
    this.Gap = size / this.Divisions;
}


// last and size could have changed since the last time this was called,
// so pass them in again.
// return:
//   the new position of the item (same units as args).
// arguments (all in the same units):
//   size: width of window
//   last: The current position of the item.
//   delta: The distance the mouse has moved.
saStops.prototype.Drag = function(delta) {
    // Put a compensation factor so item follows mouse.
    this.Target += delta;
    delta = delta + 3*(this.Target - this.Last) / this.Gap;

    // Where we should be without the stop.
    var next = this.Last + delta;

    if (this.Stopped) {
        // Acculilate the movement.
        this.Delta = this.Delta + delta;
        // Have we passed the threshold to exit?
        if (Math.abs(this.Delta) > this.Threshold) {
            // yes
            this.Stopped = false;
            this.Delta = 0;
            this.Last = next;
            return next;
        }
        // no
        return this.Stop;
    }

    // We are note stopped yet.
    // Have we passed a stop?  Get the nearest stop value.
    var stop = this.GetStop(this.Last, next);

    if (stop < this.Last && stop < next) {
        // We did not pass a stop.
        this.Delta = 0;
        this.Last = next;
        return next;
    }
    if (stop > this.Last && stop > next) {
        // We did not pass a stop.
        this.Delta = 0;
        this.Last = next;
        return next;
    }

    // Stop is in middle.  Start the Stopped behavior.
    this.Delta = next - stop;
    this.Last = stop;
    this.Stop = stop;
    this.Stopped = true;

    return stop;
}


saStops.prototype.GetStop = function(last, next) {
    // Put the stops at integer values.
    var last2 = last * this.Divisions / this.Size;
    var next2 = next * this.Divisions / this.Size;
    // transform motion to be positive;
    if (next2 < last2) {
        var tmp = last2;
        last2 = next2;
        next2 = tmp;
    }
    // Find the last stop passed.
    var stop = Math.floor(next2);
    stop = stop * this.Size / this.Divisions;

    return stop;
}




//==============================================================================
// Option to go full window.  This is intended for viewers, but might be
// made general.

// TODO: We need callbacks when it goes full and back.

// args: "off"  turns full window off.
jQuery.prototype.saFullWindowOption = function(args) {
    this.addClass('sa-full-window-option');
    for (var i = 0; i < this.length; ++i) {
        if ( ! this[i].saFullWindowOption) {
            var helper = new saFullWindowOption($(this[i]));
            // Add the helper as an instance variable to the dom object.
            this[i].saFullWindowOption = helper;
        }
        if (args == 'off') {
            this[i].saFullWindowOption.SetFullWindow($(this[i]), false);
        }
    }

    return this;
}

function saFullWindowOption(div) {
    var self = this;
    this.FullWindowOptionButton = $('<img>')
        .appendTo(div)
        .attr('src',SA.ImagePathUrl+"fullscreenOn.png")
        .prop('title', "full window")
        .css({'position':'absolute',
              'width':'12px',
              'left':'-5px',
              'top':'-5px',
              'opacity':'0.5',
              'z-index':'-1'})
        .hover(function(){$(this).css({'opacity':'1.0'});},
               function(){$(this).css({'opacity':'0.5'});})
        .click(function () {
            self.SetFullWindow(div, true);
        });

    this.FullWindowOptionOffButton = $('<img>')
        .appendTo(div)
        .hide()
        .attr('src',SA.ImagePathUrl+"fullscreenOff.png")
        .prop('title', "full window off")
        .css({'position':'absolute',
              'background':'#FFF',
              'width':'16px',
              'left':'1px',
              'top':'1px',
              'opacity':'0.5',
              'z-index':'1'})
        .hover(function(){$(this).css({'opacity':'1.0'});},
               function(){$(this).css({'opacity':'0.5'});})
        .click(function () {
            self.SetFullWindow(div, false);
        });
}

// TODO: Turn off other editing options: drag, delete, resize.
saFullWindowOption.prototype.SetFullWindow = function(div, flag) {
    if (flag) {
        // TODO: Put this in a call back.
        saButtonsDisable(div[0]);
        this.FullWindowOptionOffButton.show();
        this.FullWindowOptionButton.hide();
        // Save the css values to undo.
        this.Left = div[0].style.left;
        this.Width = div[0].style.width;
        this.Top = div[0].style.top;
        this.Height = div[0].style.height;
        this.ZIndex = div[0].style.zIndex;
        div.css({'left'   : '0px',
                 'width'  : '100%',
                 'top'    : '0px',
                 'height' : '100%',
                 'z-index': '10'});
    } else {
        saButtonsEnable(div[0]);
        this.FullWindowOptionOffButton.hide();
        this.FullWindowOptionButton.show();
        div.css({'left'   : this.Left,
                 'width'  : this.Width,
                 'top'    : this.Top,
                 'height' : this.Height,
                 'z-index': this.ZIndex});
    }
    // The viewers need a resize event to change their cameras.
    $(window).trigger('resize');
}


//==============================================================================
// LEGACY
// Add a delete button to the jquery objects.

jQuery.prototype.saDeletable = function(args) {
    this.addClass('sa-deletable');
    for (var i = 0; i < this.length; ++i) {
        var domItem = this[i];
        if ( ! domItem.saDeletable) {
            // for closure (save element)
            domItem.saDeletable = new saDeletable(domItem);
        }
    }
    return this;
}

// check dom
function saDeletable(domItem) {
    this.Button = saAddButton(
        domItem, SA.ImagePathUrl+'remove.png', 'delete',
        function () {
            // if we want to get rid of the viewer records,
            if (item.saViewer) { saPruneViewerRecord(item.saViewer);}
            saButtonsDelete(domItem);
            $(domItem).remove();},
        true);
}

function saPruneViewerRecord(viewer) {
    // In order to prune, we will need to find the other viewers associated
    // with records in the notes.
    // This is sort of hackish.
    var viewerIdx = viewer.saViewerIndex;
    var note = viewer.saNote;
    var items = $('.sa-lightbox-viewer');
    // Shift all the larger indexes down one.
    for (var i = 0; i < items.length; ++i) {
        if (items[i].saViewer &&
            items[i].saViewer.saNote == note &&
            items[i].saViewer.saViewerIndex > viewerIdx) {
            --items[i].saViewer.saViewerIndex;
        }
    }
    // Remove the viewer record for this viewer.
    note.ViewerRecords.splice(viewerIdx,1);
}

//==============================================================================
// I am having such troubles setting the right panel width to fill.
// Solution is to have this element control too divs (panel and main).
// If the panel overlaps the main, we do not need to manage the main panel.
// It would have to be implemented on the panel div, not the parent div.

// TODO: Verify this works in a stand alone page.
// args
// option to specify the handle.
// option to place panel: left, right, top, bottom.
// Use it for the Notes panel.
// Use it for the presentation edit panel
// use it for dual view.

function ResizePanel(parent) {
    var self = this;

    // For animating the display of the notes window (DIV).
    this.Width = 353;

    this.PanelDiv = $('<div>').appendTo(parent)
        .css({
            'background-color': 'white',
            'position': 'absolute',
            'top' : '0px',
            'bottom':'0px',
            'left' : '0px',
            'width': this.Width+'px'})
        .attr('draggable','false')
        .on("dragstart", function() {return false;});
    this.MainDiv = $('<div>').appendTo(parent)
        .css({
            'position': 'absolute',
            'top' : '0px',
            'bottom':'0px',
            'left' : this.Width+'px',
            'right':'0px',
            'border-left':'1px solid #AAA'})
        .attr('draggable','false')
        .on("dragstart", function() {return false;});

    this.OpenButton = $('<img>')
        .appendTo(this.MainDiv)
        .css({'position': 'absolute',
              'height': '20px',
              'width': '20px',
              'top' : '0px',
              'left' : '1px',
              'opacity': '0.6',
              '-moz-user-select': 'none',
              '-webkit-user-select': 'none',
              'z-index': '6'})
        .attr('src',SA.ImagePathUrl+"dualArrowRight2.png")
        .click(function(){self.SetVisibility(true);})
        .attr('draggable','false')
        .hide()
        .on("dragstart", function() {
            return false;});

    // I have no idea why the position right does not work.
    this.CloseButton = $('<img>')
        .appendTo(this.MainDiv)
        .css({'position': 'absolute',
              'height': '20px',
              'top' : '0px',
              'left' : '-22px',
              'opacity': '0.6',
              '-moz-user-select': 'none',
              '-webkit-user-select': 'none',
              'z-index': '6'})
        //.hide()
        .attr('src',SA.ImagePathUrl+"dualArrowLeft2.png")
        .click(function(){self.SetVisibility(false);})
        .attr('draggable','false')
        .on("dragstart", function() {
            return false;});


    this.Visibility = true;
    this.Dragging = false;

    this.ResizeEdge = $('<div>')
        .appendTo(parent)
        .css({'position': 'absolute',
              'height': '100%',
              'width': '3px',
              'top' : '0px',
              'left' : this.Width+'px',
              'background': '#BDF',
              'z-index': '10',
              'cursor': 'col-resize'})
        .hover(function () {$(this).css({'background':'#9BF'});},
               function () {$(this).css({'background':'#BDF'});})
        .mousedown(function () {
            self.StartDrag();
            return false;
        });
}

// TODO: Remove reference to body directly
// Maybe use parent.
ResizePanel.prototype.StartDrag = function () {
    this.Dragging = true;
    var self = this;
    this.TmpDrag = function (e) {return self.ResizeDrag(e);}
    this.TmpStop = function (e) {return self.ResizeStopDrag(e);}
    $('body').on('mousemove', this.TmpDrag);
    $('body').on('mouseup', this.TmpStop);
    $('body').css({'cursor': 'col-resize'});
}

ResizePanel.prototype.ResizeDrag = function (e) {
    this.SetWidth(e.pageX - 1);
    if (this.Width < 200) {
        this.ResizeStopDrag();
        this.SetVisibility(false);
    }

    return false;
}

ResizePanel.prototype.ResizeStopDrag = function () {
    $('body').off('mousemove', this.TmpDrag);
    $('body').off('mouseup', this.TmpDrag);
    $('body').css({'cursor': 'auto'});
    return false;
}

// TODO: Notes widget should just follow the parent.
// Get rid of this.
ResizePanel.prototype.SetWidth = function(width) {
    this.Width = width;
    this.PanelDiv.css({'width': this.Width+'px'});
    this.MainDiv.css({'left' : this.Width+'px'});
    this.ResizeEdge.css({'left' : (this.Width-2)+'px'});

    // Needed for viewers to sync canvas size.
    $(window).trigger('resize');
}

ResizePanel.prototype.AnimateNotesWindow = function() {
    var animationTime = new Date().getTime() - this.AnimationStartTime;
    if (animationTime > this.AnimationDuration || this.AnimationDuration <= 0) {
        // end the animation.
        this.SetWidth(this.AnimationTarget);

        if (this.Visibility) {
            this.CloseButton.show();
            this.OpenButton.hide();
            this.PanelDiv.fadeIn();
        } else {
            this.CloseButton.hide();
            this.OpenButton.show();
        }
        clearInterval(this.AnimationId);
        delete this.AnimationId;
        delete this.AnimationStartTime;
        delete this.AnimationDuration;
        delete this.AnimationTarget;
        
        return;
    }

    var k = animationTime / this.AnimationDuration;

    // update
    this.SetWidth(this.Width + (this.AnimationTarget-this.Width) * k);

    var self = this;
}

// Open and close the panel
ResizePanel.prototype.SetVisibility = function(visibility, duration) {
    if (duration === undefined) { duration = 1000.0;}
    if (this.Visibility == visibility) { return; }
    this.Visibility = visibility;

    this.AnimationCurrent = this.Width;
    if (this.Visibility) {
        this.AnimationTarget = 353;
    } else {
        this.PanelDiv.hide();
        this.AnimationTarget = 0;
    }

    this.AnimationDuration = duration;
    this.AnimationStartTime = new Date().getTime();
    // NOTE: tiles are not requestAnimFrame does not let the image tiles get drawn.
    // Do the same animation with setInterval
    var self = this;
    this.AnimationLastTime = new Date().getTime();
    this.AnimationId = setInterval(function(){self.AnimateNotesWindow(); }, 10);
}

// Show / hide the panel and handles.
// I keep the "visibility" state and restore it.
ResizePanel.prototype.Show = function() {
    this.Visibility = true;
    this.ResizeEdge.show();
    if (this.Visibility) {
        this.Visibility = false; // hack
        this.SetVisibility(true);
    } else {
        this.OpenButton.show();
    }
}

ResizePanel.prototype.Hide = function() {
    this.Visibility = false;
    // Do not use "SetVisibility" because we need to instantly close the panel.
    // arg:duration = 0 works but is not perfect.
    this.PanelDiv.hide();
    this.SetWidth(0);
    this.OpenButton.hide();
    this.CloseButton.hide();
    this.ResizeEdge.hide();

    $(window).trigger('resize');
}



//==============================================================================

//args: { label: function, ...}
jQuery.prototype.saMenuButton = function(args) {
    if (this.length == 0) { return this;}
    var item = this[0];

    if ( ! item.saMenuButton) {
        item.saMenuButton = new saMenuButton(args, this);
    }

    return this;
}

function saMenuButton(args, menuButton) {
    this.InsertMenuTimer = 0;
    this.InsertMenu = $('<ul>')
        .appendTo( menuButton )
        // How do I customize the menu location?
        .css({'position': 'absolute',
              'left'    : '-110px',
              'top'     : '25px',
              'width'   : '150px',
              'font-size':'18px',
              'box-shadow': '10px 10px 5px #AAA',
              'z-index' : '5'})
        .hide();

    for (label in args) {
        this.AddMenuItem(label, args[label]);
    }
    // Jquery UI formatting
    this.InsertMenu.menu();

    // Make it easy to select the first item
    var self = this;
    label = Object.keys(args)[0];
    menuButton.click(function() {
        (args[label])();
        self.InsertMenu.hide();
    });

    var self = this;
    menuButton.mouseover(
        function () { self.ShowInsertMenu(); });
    this.InsertMenu.mouseover(
        function () { self.ShowInsertMenu(); });

    menuButton.mouseleave(
        function () { self.EventuallyHideInsertMenu(); });
    this.InsertMenu.mouseleave(
        function () { self.EventuallyHideInsertMenu(); });
}

saMenuButton.prototype.AddMenuItem = function(label, callback) {
    var self = this;

    this[label] = $('<li>')
        .appendTo(this.InsertMenu)
        .text(label)
        .addClass('saButton') // for hover effect
        .click(function() {
            (callback)();
            self.InsertMenu.hide();
            return false;
        });
}

saMenuButton.prototype.ShowInsertMenu = function() {
    if (this.InsertMenuTimer) {
        clearTimeout(this.InsertMenuTimer);
        this.InsertMenuTimer = 0;
    }
    this.InsertMenu.show();
}

saMenuButton.prototype.EventuallyHideInsertMenu = function() {
    if (this.InsertMenuTimer) {
        clearTimeout(this.InsertMenuTimer);
        this.InsertMenuTimer = 0;
    }
    var self = this;
    this.InsertMenuTimer = setTimeout(
        function () {
            self.InsertMenuTimer = 0;
            self.InsertMenu.fadeOut();
            this.InsertMenuTimer = 0;
        }, 500);
}


//==============================================================================
// Although this is only an option for saViewers,  Make it separate to keep
// it clean. NOTE: .saViewer has to be setup before this call.

// This is not compatable with the dual viewer.  We need two widgets (one
// per viewer).  Legacy now.

//args: 
jQuery.prototype.saAnnotationWidget = function(args) {
    for (var i = 0; i < this.length; ++i) {
        var item = this[i];
        if ( ! item.saViewer) {
            return this;
        } else if ( ! item.saAnnotationWidget) {
            $(item).addClass("sa-annotation-widget")
            item.saAnnotationWidget = new AnnotationWidget(item.saViewer);
            item.saAnnotationWidget.SetVisibility(2);
        }
        // This hides and shows the button/tools but does not change the
        // visibility of the annotations in the viewer.
        if (args == "hide") {
            item.saAnnotationWidget.hide();
        } else if (args == "show") {
            item.saAnnotationWidget.show();
        }       
    }

    return this;
}

function saMenuButton(args, menuButton) {
    this.InsertMenuTimer = 0;
    this.InsertMenu = $('<ul>')
        .appendTo( menuButton )
        // How do I customize the menu location?
        .css({'position': 'absolute',
              'left'    : '-110px',
              'top'     : '25px',
              'width'   : '150px',
              'font-size':'18px',
              'box-shadow': '10px 10px 5px #AAA',
              'z-index' : '5'})
        .hide();

    for (label in args) {
        this.AddMenuItem(label, args[label]);
    }
    // Jquery UI formatting
    this.InsertMenu.menu();

    // Make it easy to select the first item
    var self = this;
    label = Object.keys(args)[0];
    menuButton.click(function() {
        (args[label])();
        self.InsertMenu.hide();
    });

    var self = this;
    menuButton.mouseover(
        function () { self.ShowInsertMenu(); });
    this.InsertMenu.mouseover(
        function () { self.ShowInsertMenu(); });

    menuButton.mouseleave(
        function () { self.EventuallyHideInsertMenu(); });
    this.InsertMenu.mouseleave(
        function () { self.EventuallyHideInsertMenu(); });
}

saMenuButton.prototype.AddMenuItem = function(label, callback) {
    var self = this;

    this[label] = $('<li>')
        .appendTo(this.InsertMenu)
        .text(label)
        .addClass('saButton') // for hover effect
        .click(function() {
            (callback)();
            self.InsertMenu.hide();
            return false;
        });
}

saMenuButton.prototype.ShowInsertMenu = function() {
    if (this.InsertMenuTimer) {
        clearTimeout(this.InsertMenuTimer);
        this.InsertMenuTimer = 0;
    }
    this.InsertMenu.show();
}

saMenuButton.prototype.EventuallyHideInsertMenu = function() {
    if (this.InsertMenuTimer) {
        clearTimeout(this.InsertMenuTimer);
        this.InsertMenuTimer = 0;
    }
    var self = this;
    this.InsertMenuTimer = setTimeout(
        function () {
            self.InsertMenuTimer = 0;
            self.InsertMenu.fadeOut();
            this.InsertMenuTimer = 0;
        }, 500);
}







//==============================================================================




//==============================================================================






// CME
// TODO:


// Bugs:
// Get short answer questions working.

// Question resizable only after reload.
// Images have a minimum size.

// My feature requests from creating poster:
// Snap to objects.
// Text background options like rectange (gradient)
//   option to enter css text, or select color gui
// Group objects.
// Copy and paste object or group.
// Select objects.
// Move selected objects with arrow.
// Undo edits
// padding option in text dialog (conversion for px to %?)


// Feature Requests
// Text should selectively resize.
//    This is hard.  I cannot change a selection into a dom that can be manipulated.
// Full window should have overview window and dual view option.
// True false / short answer question.
// Mobile users: first view in session is off the edge.


// Snap 
//    to objects.
//    some indication of snap.
//    look at google.
// Slide menu/edit buttons
// Stack and subnotes.
// Improve session browser:
//   Close sessions.
//   Open notes with children.
//   Show multiple viewer records.
//   Choose Images and Notes
//   Merge search with browser.


//   Allow for relative font sizes in a saScalableFontDiv.
// Add GUI to add slides and slide items.
// Background of thumbs should be white.
// Embed option of viewer.




// TODO:

//==============================================================================
// TODO:
// - Resize the view area to fit the note text.
// - Edit mode: resize views
// - Allow views to go full screen.
// - Sortable slides in slide div.
// - Stop the timer when we leave full screen. Turn editing back on if EDIT.



(function () {
    "use strict";


//==============================================================================
function Presentation(rootNote, edit) {
    var self = this;
    this.RootNote = rootNote;
    this.Edit = edit;
    // We need this to know what to return to when a view goes full screen.
    this.FullScreen = false;

    // Setup default global properties.
    if ( typeof(rootNote.TypeData) == "undefined") {
        rootNote.TypeData = {};
    }
    if (! rootNote.TypeData.Background) {
        rootNote.TypeData.Background = '#EEEEEE';
    }
    if (! rootNote.TypeData.AspectRatio) {
        rootNote.TypeData.AspectRatio = 1.3333;
    }

    // Eliminate the GUI in the viewers.
    //MOBILE_DEVICE = "Simple";
    $(body).css({'overflow-x':'hidden'});

    // Hack.  It is only used for events.
    // TODO: Fix events and get rid of this.
    CANVAS = $('<div>')
            .appendTo('body')
            .css({
                'position': 'absolute',
                'width': '100%',
                'height': '100%',
                'top' : '0px',
                'left' : '0px',
                'z-index': '-1'
            });

    this.WindowDiv = $('<div>')
        .appendTo('body')
        .css({
            'position':'fixed',
            'left':'0px',
            'width': '100%'})
        .saFullHeight();

    // Hack so all viewers will shar the same browser.
    // We should really use the brower tab in the left panel.
    VIEW_BROWSER = new ViewBrowser(this.WindowDiv);

    this.ResizePanel = new ResizePanel(this.WindowDiv);

    //this.PresentationDiv = $('<div>')
    //    .appendTo(this.WindowDiv)
    //    .css({'position':'absolute',
    //          'top':'0px',
    //          'left':'0px',
    //          'width':'100%',
    //          'height':'100%'});
    this.PresentationDiv = this.ResizePanel.MainDiv;

    // Wow, really?  Timing caused the swipe bug?
    this.WindowDiv.on(
        'swipeleft',
        function (e) { 
            if ( self.ResizePanel.Visibility &&
                 e.swipestop.coords[0] < self.ResizePanel.Width) {
                self.ResizePanel.SetVisibility(false);
                return false;
            }
            self.GotoSlide(self.Index+1);
        });
    this.WindowDiv.on(
        'swiperight',
        function (e) { 
            if ( ! self.ResizePanel.Visibility &&
                 e.swipestart.coords[0] < 10) {
                self.ResizePanel.Show();
                return false;
            }
            self.GotoSlide(self.Index-1);
        });

    // A window with a constant aspect ratio that fits in
    // the PresentationDiv.
    this.AspectDiv = $('<div>')
        .css({'border' :'1px solid #AAA'})
        .appendTo(this.PresentationDiv)
        .saPresentation({aspectRatio : this.RootNote.TypeData.AspectRatio});

    this.LeftPanel = this.ResizePanel.PanelDiv;
    this.InitializeLeftPanel(this.LeftPanel);
    // Left panel is closed by default on mobile devices.
    if (detectMobile()) {
        this.ResizePanel.Hide();
    }

    // Float the two slide show buttons in the upper right corner.
    this.ShowButton = $('<img>')
        .appendTo(this.PresentationDiv)
        .prop('title', "present")
        .addClass('editButton')
        .attr('src',SA.ImagePathUrl+'slide_show.png')
        .css({'position':'absolute',
              'top':'2px',
              'right':'20px',
              'width':'20px',
              'z-index':'5'})
        .click(function () {
            self.StartFullScreen();
        });
    this.TimerButton = $('<img>')
        .appendTo(this.PresentationDiv)
        .prop('title', "present timed")
        .addClass('editButton')
        .attr('src',SA.ImagePathUrl+'timer.png')
        .css({'position':'absolute',
              'top':'2px',
              'right':'46px',
              'width':'20px',
              'z-index':'5'})
        .click(function () {
            self.StartTimerShow();
        });


    // TODO: Fix this.  At least hide the button for the title page,
    // or get rid of the title page.
    if (edit) {
        // Temporary way to delete a this.
        this.DeleteSlideButton = $('<img>')
            .appendTo(this.AspectDiv)
            .attr('src',SA.ImagePathUrl+"remove.png")
            .prop('title', "delete slide")
            .addClass('editButton')
            .css({'position':'absolute',
                  'width':'12px',
                  'height':'12px',
                  'left':'0px',
                  'top':'0px',
                  'z-index':'5'})
            .click(function () {
                // Hack to reload viewer records.
                self.DeleteCurentSlide();
            });
    }

    this.TitlePage = new TitlePage(this.AspectDiv, edit);
    this.SlidePage = new SlidePage(this.AspectDiv, edit);
    this.HtmlPage  = new HtmlPage(this.AspectDiv, edit,
                                  rootNote.TypeData.Background);

    this.GotoSlide(0);

    // Keep the browser from showing the left click menu.
    document.oncontextmenu = cancelContextMenu;

    $('body').on(
        'keydown',
        function(e) {
            return self.HandleKeyDown(e);
        });

    this.UpdateSlidesTab();
}


Presentation.prototype.StartTimerShow = function () {
    var self = this;
    // hack to turn off key events.

    SA.ContentEditableHasFocus = true;
    var dialog = $('<div>')
        .dialog({
            modal: false,
            resizable:false,
            position: {
                my: "left top",
                at: "left top",
                of: window
            },
            beforeClose: function() {
                SA.ContentEditableHasFocus = false;
            },
            buttons: {
                "Start": function () {
                    self.StartFullScreen();
                    // Change seconds to milliseconds
                    var duration = parseInt(self.DurationInput.val())*1000;
                    // Also linger on the current slide.
                    setTimeout(function(){ self.TimerCallback(duration);}, duration);
                    // Should we just close and resuse the dialog?
                    $(this).dialog("destroy");
                }
            }
        });
    this.DurationLabel = $('<label>')
        .appendTo(dialog)
        .text("Seconds:");
    this.DurationInput = $('<input type="number" min="1" step="1">')
        .appendTo(dialog)
        .val(30)
        .css({'width':'4em'});
}


Presentation.prototype.StartFullScreen = function () {
    var elem = document.body;

    this.ResizePanel.Hide();
    this.EditOff();
    $(window).trigger('resize');
    this.ShowButton.hide();
    this.TimerButton.hide();

    if (elem.requestFullscreen) {
        elem.requestFullscreen();
    } else if (elem.msRequestFullscreen) {
        elem.msRequestFullscreen();
    } else if (elem.mozRequestFullScreen) {
        elem.mozRequestFullScreen();
    } else if (elem.webkitRequestFullscreen) {
        elem.webkitRequestFullscreen();
    }

    this.FullScreen = true;

    // detect when we leave full screen.
    var self = this;
    $(elem).bind(
        'webkitfullscreenchange mozfullscreenchange fullscreenchange',
        function(e) {
            var state = document.fullScreen || document.mozFullScreen ||
                document.webkitIsFullScreen;
            //var event = state ? 'FullScreenOn' : 'FullScreenOff';
            
            self.FullScreen = state;
            if ( ! self.FullScreen) {
                self.ResizePanel.Show();
                self.EditOn();
                self.ShowButton.show();
                self.TimerButton.show();
                // TODO: Stop the timer when we leave full screen.
            }
        });
}


Presentation.prototype.EditOff = function () {
    if (SA.Edit && this.Edit) {
        this.Edit = false;

        this.SaveButton.hide();
        this.InsertMenuButton.hide();
        this.DeleteSlideButton.hide();
        // QuizMenu / label?
        this.EditTabs.DisableTabDiv(this.BrowserDiv);
        this.EditTabs.DisableTabDiv(this.SearchDiv);
        this.EditTabs.DisableTabDiv(this.ClipboardDiv);

        this.TitlePage.EditOff();
        this.SlidePage.EditOff();
        this.HtmlPage.EditOff();
    }
}


Presentation.prototype.EditOn = function () {
    if (this.FullScreen) { return; }
    if (SA.Edit && ! this.Edit) {
        this.Edit = true;

        this.SaveButton.show();
        this.InsertMenuButton.show();
        this.DeleteSlideButton.show();
        this.EditTabs.EnableTabDiv(this.BrowserDiv);
        this.EditTabs.EnableTabDiv(this.SearchDiv);
        this.EditTabs.EnableTabDiv(this.ClipboardDiv);

        this.TitlePage.EditOn();
        this.SlidePage.EditOn();
        this.HtmlPage.EditOn();
        this.DeleteSlideButton.show();
    }
}


Presentation.prototype.InitializeLeftPanel = function (parent) {
    this.EditTabs = new TabbedDiv(parent);
    this.EditTabs.Div.css({'width':'100%',
                          'height':'100%'})

    this.SlidesDiv = this.EditTabs.NewTabDiv("Slides");
    this.SlidesDiv
        .css({'text-align': 'left',
              'color': '#303030',
              'font-size': '18px'});
    // The div that will hold the list of slides.
    this.SlideList = $('<div>')
        .appendTo(this.SlidesDiv)
        .css({'position':'absolute',
              'width':'100%',
              'top':'32px',
              'bottom':'3px',
              'overflow-y':'auto'});

    if (SA.Edit) {
        this.BrowserDiv = this.EditTabs.NewTabDiv("Browse");
        this.SearchDiv = this.EditTabs.NewTabDiv("Search");
        this.ClipboardDiv = this.EditTabs.NewTabDiv("Clipboard");
        var self = this;

        this.SaveButton = $('<img>')
            .appendTo(this.SlidesDiv)
            .prop('title', "save")
            .addClass('editButton')
            .attr('src',SA.ImagePathUrl+'save22.png')
            .css({'float':'right'})
            .click(function () { self.Save();});
        this.InsertMenuButton = $('<div>')
            .appendTo(this.SlidesDiv)
            .addClass('editButton')
            .css({'float':'right',
                  'position':'relative'})
            .saMenuButton( {
                'New Slide'       : function () {
                    self.InsertNewSlide("HTML");},
                'Copy Slide'      : function () {self.InsertSlideCopy();},
                'Insert Text'     : function () {
                    self.HtmlPage.InsertTextBox()
                        .css({'height':'25%'});},
                'Insert Question' : function () {self.HtmlPage.InsertQuestion();},
                'Insert Rectangle': function () {
                    self.HtmlPage.InsertRectangle('#073E87','0%','60%','97.5%','14%');},
                'Insert Image'    : function () {self.InsertImage();},
                'Insert MP4'      : function () {self.InsertVideo();},
                'Embed Youtube'   : function () {self.InsertYoutube();}
            });

        $('<img>')
            .appendTo(this.InsertMenuButton)
            .attr('src',SA.ImagePathUrl+'new_window.png');


        this.QuizMenu = $('<select name="quiz" id="quiz">')
            .appendTo(this.SlidesDiv)
            .css({'float':'right',
                  'margin':'3px'})
            .change(function () {
                if (this.value == "review") {
                    self.RootNote.Mode = "answer-show";
                } else if (this.value == "hidden") {
                    self.RootNote.Mode = "answer-hide";
                } else if (this.value == "interactive") {
                    self.RootNote.Mode = "answer-interactive";
                }
                self.UpdateQuestionMode();
            });
        $('<option>')
            .appendTo(this.QuizMenu)
            .text('review');
        $('<option>')
            .appendTo(this.QuizMenu)
            .text('hidden');
        $('<option>')
            .appendTo(this.QuizMenu)
            .text('interactive');
        this.QuizLabel = $('<div>')
            .appendTo(this.SlidesDiv)
            .css({'float':'right',
                  'font-size':'small',
                  'margin-top':'4px'})
            .text("quiz");
        // Set the question mode
        if (this.RootNote.Mode == 'answer-hide') {
            this.QuizMenu.val("hidden");
        } else if (this.RootNote.Mode == 'answer-interactive') {
            this.QuizMenu.val("interactive");
        } else {
            this.RootNote.Mode = 'answer-show';
            this.QuizMenu.val("review");
        }


        this.BrowserPanel = new BrowserPanel(
            this.BrowserDiv,
            function (viewObj) {
                self.AddViewCallback(viewObj);
            });
        this.BrowserDiv.css({'overflow-y':'auto'});

        this.SearchPanel = new SearchPanel(
            this.SearchDiv,
            function (imageObj) {
                self.AddImageCallback(imageObj);
            });
        this.ClipboardPanel = new ClipboardPanel(
            this.ClipboardDiv,
            function (viewObj) {
                self.AddViewCallback(viewObj);
            });

    }

    this.UserTextDiv = this.EditTabs.NewTabDiv("Notes", "private notes");
    // Private notes.
    this.UserNoteEditor = new UserNoteEditor(this.UserTextDiv);

    this.EditTabs.ShowTabDiv(this.SlidesDiv);
}



//==============================================================================
// What should i do if the user starts editing before the note loads?
// Editor will not be active until it has a note.
function UserNoteEditor(parent) {
    this.UpdateTimer = null;
    this.ParentNote = null;
    //this.UserNote = null;
    this.TextEditor = $('<div>')
        .appendTo(parent)
        .css({'display':'inline-block',
              'position':'absolute',
              'overflow-y': 'auto',
              'padding'   : '5px',
              'fontFamily': "Verdana,sans-serif",
              'left' : '2px',
              'right' : '2px',
              'top'  : '20px',
              'bottom':'2px'});
        //.saTextEditor();

    var self = this;
    this.TextEditor.attr('contenteditable', 'false')
        .bind('input', function () {
            // Leave events are not triggering.
            self.EventuallyUpdate();
        })
        .focusin(function() {
            SA.ContentEditableHasFocus = true;
        })
        .focusout(function() {
            SA.ContentEditableHasFocus = false;
            self.UpdateNote();
        })
        // Mouse leave events are not triggering.
        .mouseleave(function() { // back button does not cause loss of focus.
            self.UpdateNote();
        });

    this.TextEditor.change( function () { self.UpdateNote(); });
}

UserNoteEditor.prototype.EventuallyUpdate = function() {
    if (this.UpdateTimer) {
        clearTimeout(this.UpdateTimer);
        this.UpdateTimer = null;
    }
    var self = this;
    this.UpdateTimer = setTimeout(function () { self.UpdateNote() }, 5000);
}


UserNoteEditor.prototype.UpdateNote = function () {
    if (this.ParentNote && this.ParentNote.UserNote) {
        var userNote = this.ParentNote.UserNote;
        userNote.Text = this.TextEditor.html();
        // Do not save the user not until the parent has been saved.
        if (this.ParentNote.Id) {
            // Do not save new empty user notes.
            if(userNote.Id || userNote.Text != "") {
                // Do not save the user not if it has no text.
                userNote.Save();
            }
        }
    }
}


// The parent not is set.  A user not is retrieved or created, and the
// editor is attached to the user note.
// TODO: Get rid of the local iVar UserNote.
// TODO: Make sure this works with temp note ids.
UserNoteEditor.prototype.SetNote = function (parentNote) {
    if (this.ParentNote == parentNote) { return; }

    // Save the previous note incase the user is in mid edit
    // TODO: Do not save it has not been modified.
    this.UpdateNote();
    // clear the editor and make not editable until we have another user note.
    this.ParentNote = null;
    //this.UserNote = null;
    this.TextEditor.html("");
    this.TextEditor
        .attr('contenteditable', 'false')
        .css('border','');

    // Null note means save previous and clear editor and make it no longer editable.
    if ( ! parentNote) {
        return;
    }

    this.ParentNote = parentNote;

    if (parentNote.UserNote) {
        //this.UserNote = parentNote.UserNote;
        this.TextEditor
            .html(parentNote.UserNote.Text)
            .attr('contenteditable', 'true')
            .css({'border':'2px inset #DDD'});
        return;
    }

    if ( ! parentNote.Id) {
        // If the parent does not have an id, it must be new and will not
        // have a user note.  Make a new one (do not try to load user note).
        // A new note.  I do not want to save empty user notes for every
        // note.  The check will be in the save method.
        parentNote.SetUserNote(new SA.Note());
        this.TextEditor
            .attr('contenteditable', 'true')
            .css({'border':'2px inset #DDD'});
        return;
    }

    // NOTE: This is probably not necessary because the server embeds user
    // notes when the parent is sent to the client.
    var self = this;
    $.ajax({
        type: "get",
        url: "/webgl-viewer/getusernotes",
        data: {"parentid": parentNote.Id},
        success: function(data,status) { self.LoadUserNote(data, parentNote.Id);},
        error: function() { saDebug( "AJAX - error() : getusernotes" ); },
    });
}

UserNoteEditor.prototype.LoadUserNote = function(data, parentNoteId) {
    if ( ! this.ParentNote || this.ParentNote.Id != parentNoteId) {
        // Many things could happen while waiting for the note to load.
        return;
    }

    var parentNote = this.ParentNote;
    parentNote.SetUserNote(new SA.Note());

    if (data.Notes && data.Notes.length > 0) {
        if (data.Notes.length > 1) {
            saDebug("Warning: Only showing the first user note.");
        }
        var noteData = data.Notes[0];
        parentNote.UserNote.Load(noteData);
    }

    // Must display the text.
    this.TextEditor.html(parentNote.UserNote.Text);
    this.TextEditor.attr('contenteditable', 'true')
        .css({'border':'2px inset #DDD'});
}


//==============================================================================

Presentation.prototype.UpdateQuestionMode = function() {

    if ( ! this.RootNote) { return;}
    $('.sa-question').saQuestion('SetMode', this.RootNote.Mode);

    // Do not hide the Title page title
    if (this.RootNote.Mode == 'answer-hide' && this.Index != 0) {
        // Experiment with hiding titles too.
        var title = $('.sa-presentation-title');
        var standin = title.clone();
        title.hide();
        standin
            .appendTo(title.parent())
            .html("#" + this.Index)
            .addClass('sa-standin')
            .attr('contenteditable', 'false')
            .saScalableFont();
    } else {
        // Experiment with hiding titles too.
        $('.sa-standin').remove();
        $('.sa-presentation-title').show();
    }
    this.UpdateSlidesTab();
}


Presentation.prototype.TimerCallback = function(duration) {
    if (this.Index == this.GetNumberOfSlides() - 1) {
        // Stop but stay in full screen mode.
        this.GotoSlide(0);
        SA.ContentEditableHasFocus = false;
        return;
    }   

    this.GotoSlide(this.Index+1);

    // Hack to get rid of anwers.
    // Select everything in the editor.
    var editor = this.SlidePage.List.TextEntry[0];
    $(editor).attr('contenteditable', 'true');
    var sel = window.getSelection();
    range = document.createRange();
    range.selectNodeContents(editor);
    sel.removeAllRanges();
    sel.addRange(range);
    // remove bold formating
    document.execCommand('bold',false,null);
    document.execCommand('bold',false,null);
    // Hide annotations
    // legacy
    if (this.SlidePage.AnnotationWidget1) {
        this.SlidePage.AnnotationWidget1.SetVisibility(false);
    }
    if (this.SlidePage.AnnotationWidget2) {
        this.SlidePage.AnnotationWidget2.SetVisibility(false);
    }
    // remove the selection
    range.collapse(false);
    // The collapse has no effect without this.
    sel.removeAllRanges();
    sel.addRange(range);
    $(editor).attr('contenteditable', 'false');

    // Wait before advancing.
    var self = this;
    setTimeout(function(){ self.TimerCallback(duration);}, duration);
}

// Adds a view to the current slide.
Presentation.prototype.AddViewCallback = function(viewObj) {
    if (viewObj.Type == "HTML") {
        // What will happen if you insert a whole presentation (root)?
        // Insert a new slide
        var idx = this.Index+1;
        var note = new SA.Note();
        note.Load(viewObj);
        // Record changes in the note before the copy.
        this.HtmlPage.UpdateEdits();

        this.RootNote.Children.splice(idx-1,0,note);
        this.GotoSlide(idx);
        this.UpdateSlidesTab();
        return;
    }

    if (this.Note.Type == "HTML") {
        // TODO: Change this to pass a viewer record of the view.
        //       Maybe show all the records as options.
        this.HtmlPage.InsertView(viewObj);
        return;
    }

    var record = new SA.ViewerRecord();
    record.Load(viewObj.ViewerRecords[0]);
    this.Note.ViewerRecords.push(record);

    this.SlidePage.DisplayNote(this.Note, SA.Presentation.Index);
}

// Callback from search.
Presentation.prototype.AddImageCallback = function(image) {
    var record = new SA.ViewerRecord();
    record.OverviewBounds = image.bounds;
    record.Image = image;
    record.Camera = {FocalPoint:[(image.bounds[0]+image.bounds[1])/2,
                                 (image.bounds[2]+image.bounds[3])/2, 0],
                     Roll: 0,
                     Height: (image.bounds[3]-image.bounds[2]),
                     Width : (image.bounds[1]-image.bounds[0])};

    if (this.Note.Type == "HTML") {
        // This will be the primar path in the future.
        this.HtmlPage.InsertViewerRecord(record);
        return;
    }
    if (this.Note != this.RootNote) {
        var note = new SA.Note();
        note.ViewerRecords[0] = record;
        this.SlidePage.InsertViewNote(note);
        return;
    }

    // The root needs a record to show up in the session.
    // never executed because I add a presentation icon
    // NOTE: This might be a problem with the new html title page.
    //       Viewers inthe title pages are stored as records.
    if (this.RootNote.ViewerRecords.length == 0) {
        this.RootNote.ViewerRecords.push(record);
    } 
}


Presentation.prototype.HandleKeyDown = function(event) {
    // Hack to keep the slides from changing when editing.
    if ( SA.ContentEditableHasFocus) {
        return true;
    }

    // I cannot get the browser to paste into a new div
    // First, paste is executed before this callback.
    // Second, the execCommand paste does not appear to work.
    //if (event.keyCode == "86" && ! event.ctrlKey) { // check for control v paste
    //    if (this.Note.Type == "HTML") {
    //        this.HtmlPage.Paste();
    //   }
    //}

    if (event.keyCode == "32" || // space
        event.keyCode == "34" || // page down
        event.keyCode == "78" || // n
        event.keyCode == "39" || // right arrow
        event.keyCode == "40" || // down arrow
        event.keyCode == "13") { // enter
        this.GotoSlide(this.Index + 1);
        return false;
    }
    if (event.keyCode == "80" || // p
        event.keyCode == "37" || // back arrow
        event.keyCode == "38" || // up arrow
        event.keyCode == "33") { // page up
        this.GotoSlide(this.Index - 1);
        return false;
    }
    if (event.keyCode == "36") { // home
        this.GotoSetSlide(0);
        return false;
    }
    if (event.keyCode == "35") { // end
        this.GotoSlide(this.GetNumberOfSlides() - 1);
        return false;
    }
}


Presentation.prototype.Save = function () {
    // Get rid of interactive question formating.
    this.HtmlPage.Div.find('.sa-answer')
        .css({'color':'#000'});

    var self = this;
    this.TitlePage.UpdateEdits();
    this.SlidePage.UpdateEdits();
    this.HtmlPage.UpdateEdits();

    // NOTE:  It should not be necessary to differentiate user notes from
    // normal notes anymore because we are generating ids on the client.

    for (var i = 0; i < SA.Notes.length; ++i) {
        note = SA.Notes[i];
        if (note.Type != "UserNote" ) {
            note.Save(function (note) {
                if (note == self.RootNote) {
                    // if this is the first time we are saving the root note, then
                    // add it to the session.
                    $.ajax({
                        type: "post",
                        data: {"sess" : SA.SessionId,
                               "view" : note.Id},
                        url: "webgl-viewer/session-add-view",
                        success: function(data,status){
                            if (status != "success") {
                                saDebug("ajax failed - session-add-view");
                            }
                        },
                        error: function() {
                            saDebug( "AJAX - error() : session-add-view" );
                        },
                    });
                }
            }, true);
        }
    }

    // Save the user notes.  They are not saved with the parent notes like
    // the children are.
    for (var i = 0; i < SA.Notes.length; ++i) {
        note = SA.Notes[i];
        if ( note.Type == "UserNote" ) {
            if (note.Id || note.Text != "") {
                note.Save();
            }
        }
    }

    // TODO:
    // Fix this. Session page needs every member view to have an image.
    // The root needs a record to show up in the session.
    var rootNote = this.RootNote;
    if (rootNote.ViewerRecords.length < 1) {
        var record = new SA.ViewerRecord();
        record.Load(
            {AnnotationVisibility: 2,
             Annotations: [],
             Camera: {FocalPoint: [510, 519],
                      Height: 1009,
                      Roll: 0,
                      Width: 1066},
             Database: "507f34a902e31010bcdb1366",
             Image: {TileSize: 256,
                     _id: "55b4e5c03ed65909a84cd938",
                     bounds: [0, 1020, 15, 1024],
                     components: 3,
                     database: "507f34a902e31010bcdb1366",
                     dimensions: [1020, 1009],
                     filename: "projection-screen.jpg",
                     label: "projection-screen.jpg",
                     levels: 3,
                     origin: [0, 0, 0],
                     spacing: [1, 1, 1],
                     NumberOfLevels: 3,
                     OverviewBounds: [0, 1020, 15, 1024]}
            });
        rootNote.ViewerRecords.push(record);
    }

    //this.SaveButton.css({'color':'#F00'});
    // And finally, we can save the presentation.
    this.RootNote.Save();
}


Presentation.prototype.DeleteSlide = function (index){
    var maxIdx = this.GetNumberOfSlides() - 1;
    if (index < 1 || index > maxIdx) {
        return;
    }
    this.RootNote.Children.splice(index-1,1);
    // The case when we are not deleting the current slide.
    // All slides after the one deleted cahnge their index.
    if (this.Index > index) { this.Index -= 1; }

    // Case where we are deleting the current slide.
    if (index == this.Index) {
        // index becomes the sldie we are going to.
        // Handles the case where we are on the last slide.
        // Move to the previous rather then the next.
        if (index == maxIdx) { --index; }
        // force GotoSlide to
        this.Index = -1;
        this.GotoSlide(index);
    }

    this.UpdateSlidesTab();
}


Presentation.prototype.DeleteCurentSlide = function () {
    this.DeleteSlide(this.Index);
}

Presentation.prototype.InsertNewSlide = function (type){
    var idx = this.Index+1;
    var note = new SA.Note();
    if (type) { note.Type = type; }
    this.RootNote.Children.splice(idx-1,0,note);
    note.Parent = this.RootNote;
    this.GotoSlide(idx);
    this.UpdateSlidesTab();
    if (type == 'HTML') {
        this.HtmlPage.InitializeSlidePage();
    }
    this.UpdateQuestionMode();
}

Presentation.prototype.InsertSlideCopy = function (type){
    var idx = this.Index+1;
    var note = new SA.Note();

    // Record changes in the note before the copy.
    this.HtmlPage.UpdateEdits();
    // Deep copy of note with children.
    note.DeepCopy(this.Note);

    this.RootNote.Children.splice(idx-1,0,note);
    this.GotoSlide(idx);
    this.UpdateSlidesTab();
}

Presentation.prototype.InsertImage = function () {
    var src = prompt("Image URL", "https://slide-atlas.org/static/img/SlideAtlas_home.jpg");
    this.HtmlPage.InsertImage(src);
}

Presentation.prototype.InsertVideo = function () {
    var src = prompt("Video URL", "https://slide-atlas.org/api/v2/sessions/53ac02d5a7a14110d929adcc/attachments/55fef0e6a7a14162dfb4da32");
    this.HtmlPage.InsertVideo(src);
}

Presentation.prototype.InsertYoutube = function () {
    var src = prompt("Video IFrame URL", '<iframe width="420" height="315" src="https://www.youtube.com/embed/9tCafgGZtxQ" frameborder="0" allowfullscreen></iframe>');
    this.HtmlPage.InsertIFrame(src);
}

// 0->Root/titlePage
// Childre/slides start at index 1
Presentation.prototype.GotoSlide = function (index){
    if (index < 0 || index >= this.GetNumberOfSlides() || index == this.Index) {
        return;
    }

    // Clear previous slides settings.
    this.TitlePage.ClearNote();
    this.SlidePage.ClearNote();
    this.HtmlPage.ClearNote();

    this.AspectDiv.show();
    this.Index = index;
    if (index == 0) { // Title page
        this.Note = this.RootNote;
        if (this.Note.Type == "Presentation") {
            // legacy
            this.SlidePage.Div.hide();
            this.HtmlPage.Div.hide();
            this.TitlePage.DisplayNote(this.Note);
        } else if (this.Note.Type == "HTML") {
            this.TitlePage.Div.hide();
            this.SlidePage.Div.hide();
            this.HtmlPage.Div.show();
            this.HtmlPage.DisplayNote(this.Note);
            if (this.Note.Text == "") {
                this.HtmlPage.InitializeTitlePage();
            }
        }
        this.UserNoteEditor.SetNote(this.Note);
    } else { // Slide page
        this.Note = this.GetSlide(index);
        if (this.Note.Type == "HTML") {
            this.TitlePage.Div.hide();
            this.SlidePage.Div.hide();
            this.HtmlPage.Div.show();
            this.HtmlPage.DisplayNote(this.Note);
            this.UserNoteEditor.SetNote(this.Note);
        } else {
            this.TitlePage.Div.hide();
            this.HtmlPage.Div.hide();
            this.SlidePage.DisplayNote(this.Note, index);
        }
    }
    // Start preloading the next slide.
    if (index < this.RootNote.Children.length) {
        var nextNote = this.RootNote.Children[index];
        // TODO: Better arg for LoadTiles.
        // Should I pass in the jquery selection or viewer.
        if (nextNote.ViewerRecords.length > 0) {
            // Hack: What size viewer will we be using?
            nextNote.ViewerRecords[0].LoadTiles([0,0,400,300]);
        }
        if (nextNote.ViewerRecords.length > 1) {
            // Hack: What size viewer will we be using?
            nextNote.ViewerRecords[1].LoadTiles([0,0,400,300]);
        }
    }

    this.UpdateSlidesTab();
    this.UpdateQuestionMode();

    // Font was not scaling when first loaded.
    $(window).trigger('resize');
}

Presentation.prototype.GetNumberOfSlides = function (){
    return this.RootNote.Children.length + 1;
}


Presentation.prototype.GetSlide = function (idx){
    if (idx < 0 || idx > this.RootNote.Children.length) {
        return null;
    }
    if (idx == 0) {
        return this.RootNote;
    }
    return this.RootNote.Children[idx-1];
}


Presentation.prototype.SortCallback = function (){
    // Change the list of GUI items into a list of notes.
    var items = this.SlideList.find('div');
    var newChildren = [];
    var newIndex = 0;
    for (var i = 0; i < items.length; ++i) {
        var idx = parseInt($(items[i]).data('index'));
        if (idx != 0) { // we have to skip the title page because it is
            // root.
            newChildren.push(this.GetSlide(idx));
        }
        if (this.Index == idx) {
            // If the current slide moved, update the index.
            // Note the offset by one to account for the root / title.
            // length is one more than the notes index.
            newIndex = newChildren.length;
        }
    }
    this.RootNote.Children = newChildren;
    this.Index = newIndex;
    this.UpdateSlidesTab();
}


Presentation.prototype.UpdateSlidesTab = function (){
    var self = this;

    if ( ! this.SlideList) { return;}

    // Add the title page 
    this.SlideList.empty();

    if (SA.Edit) {
        this.SlideList
            .sortable({update: function(event,ui){self.SortCallback();},
                       handle: ".ui-icon"});
    }

    for (var i = 0; i < this.GetNumberOfSlides(); ++i) {
        // get a title
        var note = this.GetSlide(i);
        var title;
        var title = note.Text;
        var idx = title.indexOf('sa-presentation-text');
        if (idx == -1) {
            title = note.Title;
            if (title == "") {
                // Nothing i the text / html to use as a title.
                title = "Slide " + i;
            }
        } else {
            title = title.substring(idx);
            idx = title.indexOf('>');
            title = title.substring(idx+1);
            idx = title.indexOf('<');
            // We may have other formating blocks.
            // An xml parser would be nice.
            while (idx == 0) {
                idx = title.indexOf('>');
                title = title.substring(idx+1);
                idx = title.indexOf('<');
            }
            title = title.substring(0,idx);
            if (note.Title == "") {
                note.Title = title;
            }
        }
        // Hide titles
        if (this.RootNote.Mode == 'answer-hide') {
            title = "#"+i;
        }

        var slideDiv = $('<div>')
            .appendTo(this.SlideList)
            .css({'position':'relative',
                  'padding-left':'1.5em',
                  'padding-right':'1.5em',
                  'margin': '5px',
                  'color': '#29C',
                  'cursor':'pointer'})
            .hover(function(){ $(this).css("color", "blue");},
                   function(){ $(this).css("color", "#29C");})
            .text(title)
            .data("index",i)
            .click(function () {
                SA.Presentation.GotoSlide($(this).data("index"));
            });
        var sortHandle = $('<span>')
            .appendTo(slideDiv)
            .css({'position':'absolute',
                  'left':'7px',
                  'top' :'2px',
                  'opacity':'0.5'})
            .addClass('ui-icon ui-icon-bullet');
        if (SA.Edit) {
            sortHandle.addClass('sa-sort-handle');
        }

        if (this.Note == note) {
            slideDiv.css({'background':'#EEE'});
        }
    }
}



//==============================================================================
function SlidePage(parent, edit) {
    var self = this;
    this.FullWindowView = null;
    this.Edit = edit;
    this.Note = null;
    this.Records = []; // views.

    this.Div = $('<div>')
        .appendTo(parent)
        .hide()
        .addClass('sa-resize') // hack to get resize triggered.
        .css({
            'position' : 'absolute',
            'width': '100%',
            'height': '100%',
            'border': '1px solid #AAA'});
    this.Div[0].onresize=
        function(){
            self.ResizeViews();
        };

    this.ViewPanel = $('<div>')
            .appendTo(this.Div)
            .css({'background':'#FFF',
                  'position': 'absolute',
                  'top': '0px',
                  'bottom': '300px',
                  'left': '0px',
                  'width': '100%',
                  'height': 'auto'});

    this.BottomDiv = $('<div>')
        .appendTo(this.Div)
        .css({'position': 'absolute',
              'bottom':'0px',
              'width':'100%',
              'height':'300px'});

    this.TitleBar = $('<div>')
        .appendTo(this.BottomDiv)
        .css({'position':'absolute',
              'top': '0px',
              'height': '80px',
              'line-height': '80px',
              'width':'100%',
              'padding-left': '3.3em',
              'color': 'white',
              'font-size': '160%',
              'background': '#444',
              'font-family': 'Arial'});
    this.Title = $('<span>')
        .appendTo(this.TitleBar)
        .css({'display':'inline-block',
              'vertical-align':'middle',
              'line-height':'normal'})
        .text("Slide: 1");

    this.TextDiv = $('<div>')
        .appendTo(this.BottomDiv)
        .css({'position':'absolute',
              'padding-left':'2em',
              'height': '210px',
              'bottom': '5px',
              'width': '100%'});
    // List of question answers.
    this.List = new SA.TextEditor(this.TextDiv, VIEWERS);
    if ( ! edit) {
        this.List.EditOff();
    }

    // Add the viewers.
    this.ViewerDiv1 = $('<div>')
        .appendTo(this.ViewPanel)
        .css({'position':'absolute',
              'box-shadow': '10px 10px 5px #AAA'});
    // Make the viewer look like jquery
    //this.ViewerDiv1.viewer({overview:false});
    this.ViewerDiv1.saViewer();

    this.ViewerDiv2 = $('<div>')
        .appendTo(this.ViewPanel)
        .css({'position':'absolute',
              'box-shadow': '10px 10px 5px #AAA'});
    // Make the viewer look like jquery
    this.ViewerDiv2.saViewer();

    if (this.Edit) {
        // TODO: Better API (jquery) for adding widgets.
        // TODO: Better placement control for the widget.
        this.AnnotationWidget1 = new AnnotationWidget(
            this.ViewerDiv1[0].saViewer.AnnotationLayer);
        this.AnnotationWidget1.SetVisibility(2);

        this.AnnotationWidget2 = new AnnotationWidget(
            this.ViewerDiv2[0].saViewer.AnnotationLayer);
        this.AnnotationWidget2.SetVisibility(2);

        // TODO: Move this to bind in jquery.  (not sure how to do this yet)
        this.ViewerDiv1[0].saViewer.OnInteraction(function () {self.RecordView1();});
        this.ViewerDiv2[0].saViewer.OnInteraction(function () {self.RecordView2();});
        this.RemoveView1Button = $('<img>')
            .appendTo(this.ViewerDiv1)
            .attr('src',SA.ImagePathUrl+"remove.png")
            .prop('title', "remove view")
            .addClass('editButton')
            .css({'position':'absolute',
                  'right':'0px',
                  'top':'0px',
                  'width':'12px',
                  'height':'12px',
                  'z-index':'5'})
            .click(function () {
                SA.Presentation.Note.ViewerRecords.splice(0,1);
                // Redisplay the viewers
                self.DisplayNote(self.Note, SA.Presentation.Index);
            });
        this.RemoveView2Button = $('<img>')
            .appendTo(this.ViewerDiv2)
            .attr('src',SA.ImagePathUrl+"remove.png")
            .prop('title', "remove view")
            .addClass('editButton')
            .css({'position':'absolute',
                  'right':'0px',
                  'top':'0px',
                  'width':'12px',
                  'height':'12px',
                  'z-index':'5'})
            .click(function () {
                SA.Presentation.Note.ViewerRecords.splice(1,1);
                // Redisplay the viewers
                self.DisplayNote(self.Note, SA.Presentation.Index);
            });

        // Setup view resizing.
        this.ViewerDiv1.resizable();
        // For a method to get called when resize stops.
        // Gets call on other mouse ups, but this is ok.
        this.ViewerDiv1
            .mouseup(function () {
                this.saViewer.EnableInteraction();
                self.UpdateEdits();
                $(window).trigger('resize');
            });
        this.ViewerDiv1
            .resize(function () {
                this.saViewer.DisableInteraction();
                var vp = this.saViewer.GetViewport();
                vp[2] = $(this).width();
                vp[3] = $(this).height();
                this.saViewer.SetViewport(vp);
                this.saViewer.EventuallyRender(true);
                return false;
            });

        this.ViewerDiv2.resizable();
        // For a method to get called when resize stops.
        // Gets call on other mouse ups, but this is ok.
        this.ViewerDiv2
            .mouseup(function () {
                this.saViewer.EnableInteraction();
                self.UpdateEdits();
                $(window).trigger('resize');
            });
        this.ViewerDiv2
            .resize(function () {
                this.saViewer.DisableInteraction();
                var vp = this.saViewer.GetViewport();
                vp[2] = $(this).width();
                vp[3] = $(this).height();
                this.saViewer.SetViewport(vp);
                this.saViewer.EventuallyRender(true);
                return false;
            });
    }
    // Give the option for full screen
    // on each of the viewers.
    this.FullWindowView1Button = $('<img>')
        .appendTo(this.ViewerDiv1)
        .attr('src',SA.ImagePathUrl+"fullscreenOn.png")
        .prop('title', "full window")
        .css({'position':'absolute',
              'width':'12px',
              'left':'-5px',
              'top':'-5px',
              'opacity':'0.5',
              'z-index':'-1'})
        .hover(function(){$(this).css({'opacity':'1.0'});},
               function(){$(this).css({'opacity':'0.5'});})
        .click(function () {
            self.SetFullWindowView(self.ViewerDiv1);
        });
    this.FullWindowView2Button = $('<img>')
        .appendTo(this.ViewerDiv2)
        .attr('src',SA.ImagePathUrl+"fullscreenOn.png")
        .prop('title', "full window")
        .css({'position':'absolute',
              'width':'12px',
              'left':'-5px',
              'top':'-5px',
              'opacity':'0.5',
              'z-index':'-1'})
        .hover(function(){$(this).css({'opacity':'1.0'});},
               function(){$(this).css({'opacity':'0.5'});})
        .click(function () {
            self.SetFullWindowView(self.ViewerDiv2);
        });


    this.FullWindowViewOffButton = $('<img>')
        .appendTo(this.ViewPanel)
        .hide()
        .attr('src',SA.ImagePathUrl+"fullscreenOff.png")
        .prop('title', "full window off")
        .css({'position':'absolute',
              'background':'#FFF',
              'width':'16px',
              'left':'1px',
              'top':'1px',
              'opacity':'0.5',
              'z-index':'1'})
        .hover(function(){$(this).css({'opacity':'1.0'});},
               function(){$(this).css({'opacity':'0.5'});})
        .click(function () {
            self.SetFullWindowView(null);
        });
}


SlidePage.prototype.SetFullWindowView = function (viewerDiv) {
    if (viewerDiv) {
        SA.Presentation.EditOff();
        this.FullWindowViewOffButton.show();
        this.FullWindowView1Button.hide();
        this.FullWindowView2Button.hide();
        this.BottomDiv.hide();
        this.ViewPanel.css({'height':'100%'});
    } else {
        this.FullWindowViewOffButton.hide();
        this.FullWindowView1Button.show();
        this.FullWindowView2Button.show();
        this.BottomDiv.show();
        this.ViewPanel.css({
            'bottom': '300px',
            'height': 'auto'});
        if (SA.Edit) {
            SA.Presentation.EditOn();
        }

    }
    this.FullWindowView = viewerDiv;
    this.ResizeViews();
}


SlidePage.prototype.RecordView1 = function() {
    if (this.Edit && this.Note &&
        this.Note.ViewerRecords.length > 0 &&
        this.Note.ViewerRecords[0]) {
        this.Note.ViewerRecords[0].CopyViewer(this.ViewerDiv1[0].saViewer);
    }
}


SlidePage.prototype.RecordView2 = function() {
    if (this.Edit && this.Note &&
        this.Note.ViewerRecords.length > 1 &&
        this.Note.ViewerRecords[1]) {
        this.Note.ViewerRecords[1].CopyViewer(this.ViewerDiv2[0].saViewer);
    }
}


SlidePage.prototype.EditOff = function () {
    if (SA.Edit && this.Edit) {
        this.Edit = false;
        this.Div.css({'width': '100%', 'left': '0px'});
        this.AnnotationWidget1.hide();
        this.AnnotationWidget2.hide();
        // Clear the event callbacks
        this.ViewerDiv1[0].saViewer.OnInteraction();
        this.ViewerDiv2[0].saViewer.OnInteraction();
        this.RemoveView1Button.hide();
        this.RemoveView2Button.hide();
        this.List.EditOff();
        // This causes the viewers to look transparent.
        //VIEWER.MainView.CanvasDiv.resizable('disable');
    }
}


SlidePage.prototype.EditOn = function () {
    if (SA.Edit &&  ! this.Edit) {
        this.Edit = true;
        //this.Div.css({'width': '100%', 'left': '0px'}); ???
        this.AnnotationWidget1.show();
        this.AnnotationWidget2.show();
        // Set the event callbacks
        var self = this;
        this.ViewerDiv1[0].saViewer.OnInteraction(function () {self.RecordView1();});
        this.ViewerDiv2[0].saViewer.OnInteraction(function () {self.RecordView2();});
        this.RemoveView1Button.show();
        this.RemoveView2Button.show();
        this.List.EditOn();
    }
}


// Adds a margin, and keeps the aspect ratio of view.
SlidePage.prototype.PlaceViewer = function(viewerDiv, record, viewport) {
    var vWidth = viewport[2] * 0.8;
    var vHeight = viewport[3] * 0.8;
    var cam = record.Camera;
    var scale = vHeight / cam.Height;
    var vWidth = scale * cam.Width;
    if (vWidth > viewport[2] * 0.8) {
        vWidth = viewport[2] * 0.8;
        scale = vWidth / cam.Width;
        vHeight = scale * cam.Height;
    }

    var vLeft = viewport[0] + (viewport[2]-vWidth) / 2;
    var vTop =  viewport[1] + (viewport[3]-vHeight) / 2;

    if (viewerDiv) {
        viewerDiv[0].saViewer.SetViewport([vLeft, vTop, vWidth, vHeight]);
        viewerDiv[0].saViewer.EventuallyRender(false);
    }
}


// Records == views.
SlidePage.prototype.ResizeViews = function ()
{
    var width = this.ViewPanel.width();
    var height = this.ViewPanel.height();
    if (this.FullWindowView) {
        this.ViewerDiv1[0].saViewer.SetViewport([0, 0, 0, height]);
        this.ViewerDiv2[0].saViewer.SetViewport([0, 0, 0, height]);
        this.FullWindowView[0].saViewer.SetViewport([0,0,width,height]);
        this.FullWindowView[0].saViewer.EventuallyRender(false);
        return;
    }

    var numRecords = this.Records.length;
    var record;

    if (numRecords == 0) {
        // Poor way to hide a viewer.
        this.ViewerDiv1[0].saViewer.SetViewport([0, 0, 0, height]);
        // Poor way to hide a viewer.
        this.ViewerDiv2[0].saViewer.SetViewport([0, 0, 0, height]);
    }
    if (numRecords == 1) {
        record = this.Records[0];
        this.PlaceViewer(this.ViewerDiv1, record, [0,0,width,height]);
        // Poor way to hide a viewer.
        this.ViewerDiv2[0].saViewer.SetViewport([0, 0, 0, height]);
    }
    if (numRecords > 1) {
        var halfWidth = width / 2;
        record = this.Records[0];
        this.PlaceViewer(this.ViewerDiv1, record, [0,0,halfWidth,height]);
        record = this.Records[1];
        this.PlaceViewer(this.ViewerDiv2, record, [halfWidth,0,halfWidth,height]);
    }
    if (this.Edit) {
        if (numRecords == 0) {
            // TODO: View should have hide/show methods and manage this.
            this.AnnotationWidget1.hide();
            this.AnnotationWidget2.hide();
        }
        if (numRecords == 1) {
            this.AnnotationWidget1.show();
            this.AnnotationWidget2.hide();
        }
        if (numRecords == 2) {
            this.AnnotationWidget1.show();
            this.AnnotationWidget2.show();
        }
    }
}


SlidePage.prototype.ClearNote = function () {
    if (this.Edit && this.Note) {
        this.UpdateEdits();
    }
    this.Note = null;
}


SlidePage.prototype.DisplayNote = function (note, index) {

    this.Div.show();
    this.Note = note;
    this.ViewerDiv1[0].saViewer.Reset();
    this.ViewerDiv2[0].saViewer.Reset();
    this.Records = note.ViewerRecords; // save this for resizing.

    this.Title.text("Slide: " + index)
    // Text
    this.List.LoadNote(note);
    // Views
    if (this.Records.length > 0) {
        this.Records[0].Apply(this.ViewerDiv1[0].saViewer);
    }
    if (this.Records.length > 1) {
        this.Records[1].Apply(this.ViewerDiv2[0].saViewer);
    }
    this.ViewerDiv1[0].saViewer.CopyrightWrapper.hide();
    this.ViewerDiv2[0].saViewer.CopyrightWrapper.hide();
    this.ResizeViews();
}


// We need to copy the annotation (maybe view in the future)
// Interaction does not actach all annotation changes.
SlidePage.prototype.UpdateEdits = function () {
    if (this.Note &&
        this.Note.ViewerRecords.length > 0 &&
        this.Note.ViewerRecords[0]) {
        this.Note.ViewerRecords[0].CopyViewer(this.ViewerDiv1[0].saViewer);
    }

    if (this.Note &&
        this.Note.ViewerRecords.length > 1 &&
        this.Note.ViewerRecords[1]) {
        this.Note.ViewerRecords[1].CopyViewer(this.ViewerDiv2[0].saViewer);
    }
}


SlidePage.prototype.InsertViewNote = function (note) {
    if (note.ViewerRecords.length < 1) { return; }

    // we just use the record for slide pages.
    var record = note.ViewerRecords[0];

    this.Note.ViewerRecords.push(record);

    // Hack: Since GotoSlide copies the viewer to the record,
    // We first have to push the new record to the view.
    if (this.Note.ViewerRecords.length == 1) {
        // TODO: jquery arg
        this.Note.ViewerRecords[0].Apply(this.ViewerDiv1[0].saViewer);
    } else if (this.Note.ViewerRecords.length == 2) {
        this.Note.ViewerRecords[1].Apply(this.ViewerDiv2[0].saViewer);
    }

    this.DisplayNote(this.Note, SA.Presentation.Index);
}



//==============================================================================
function TitlePage (parent, edit) {
    this.Edit = edit;
    this.Note = null;
    this.Div = $('<div>')
        .appendTo(parent)
        .css({
            'background':'#FFF',
            'position' : 'absolute',
            'width': '100%',
            'height': '100%',
            'border': '1px solid #AAA'});

    this.TopBar = $('<div>')
        .appendTo(this.Div)
        .css({'position':'absolute',
              'top': '0%',
              'height': '2%',
              'left': '13%',
              'right': '3%',
              'background':'#DDF1FD'});

    this.Image = $('<img>')
        .appendTo(this.Div)
        .attr('src', 'static/img/SlideAtlas_home.jpg')
        .css({'position':'absolute',
              'top': '46%',
              'height':'50%',
              'left': '13%',
              'box-shadow': '10px 10px 5px #888'});

    this.TitleBar = $('<div>')
        .appendTo(this.Div)
        .css({'position':'absolute',
              'top': '18%',
              'bottom': '58%',
              'left': '0%',
              'right': '3%',
              'background':'#073E87',
              'color':'#FFF'});
    this.Title = $('<span>')
        .appendTo(this.TitleBar)
        .attr('contenteditable', 'true')
        .css({'position':'absolute',
              'top': '1em',
              //'min-height':'3em',
              //'min-width':'10em',
              'left': '13%'})
        .saScalableFont({scale:'0.3'});

    this.AuthorBar = $('<div>')
        .appendTo(this.Div)
        .css({'position':'absolute',
              'top': '42%',
              'bottom': '0%',
              'left': '62%',
              'right': '3%',
              'background':'#E9F5FE',
              'color':'#888',
              'padding-left':'2em'});
    this.AuthorText = $('<span>')
        .appendTo(this.AuthorBar)
        .attr('contenteditable', 'true')
        .css({'position':'absolute',
              //'minimum-height':'4em',
              //'minimum-width':'10em',
              'top': '2em'})
        .saScalableFont({scale:'0.1'});


    if (this.Edit) {
        var self = this;
        this.Title
            .focusin(function() { SA.ContentEditableHasFocus = true;})
            .focusout(function() { SA.ContentEditableHasFocus = false;});
        this.AuthorText
            .focusin(function() { SA.ContentEditableHasFocus = true;})
            .focusout(function() { SA.ContentEditableHasFocus = false;});
    }
}


TitlePage.prototype.EditOff = function () {
    if (SA.Edit && this.Edit) {
        this.Edit = false;
        this.Div.css({'width': '100%', 'left': '0px'});
        this.Title
            .attr('readonly', 'readonly')
            .attr('spellcheck', 'false')
            .unbind('focusin')
            .unbind('focusout')
            .blur();
        this.AuthorText.attr('readonly', 'readonly')
            .attr('readonly', 'readonly')
            .attr('spellcheck', 'false')
            .unbind('focusin')
            .unbind('focusout')
            .blur();
    }
}


TitlePage.prototype.EditOn = function () {
    if (SA.Edit &&  ! this.Edit) {
        this.Edit = true;
        //this.Div.css({'width': '100%', 'left': '0px'}); ???
        this.Title
            .attr('contenteditable', 'true')
            .attr('spellcheck', 'true')
            .focusin(function() { SA.ContentEditableHasFocus = true;})
            .focusout(function() { SA.ContentEditableHasFocus = false;});
        this.AuthorText.attr('readonly', 'readonly')
            .attr('contenteditable', 'true')
            .attr('spellcheck', 'true')
            .focusin(function() { SA.ContentEditableHasFocus = true;})
            .focusout(function() { SA.ContentEditableHasFocus = false;});
    }
}


TitlePage.prototype.ClearNote = function () {
    if (this.Edit && this.Note) {
        this.UpdateEdits();
    }
    this.Note = null;
}


TitlePage.prototype.DisplayNote = function (note) {
    this.Note = note;
    this.Div.show();
    this.Title.html(note.HiddenTitle);
    this.AuthorText.html(note.Text);

    // What is this doing?
    // Select the title?
    var sel = window.getSelection();
    var range;
    range = document.createRange();
    range.noCursor = true;
    range.selectNodeContents(this.Title[0]);
    sel.removeAllRanges();
    sel.addRange(range);
    // Changes it to be bigger and white
    document.execCommand('foreColor', false, "#FFF");
    document.execCommand('fontSize', false, '6');
    document.execCommand('fontName', false, 'Arial');

    // Format the author text.
    // Bad way to format.  Title page should go away and
    // be replaced by HtmlPage.
    range.selectNodeContents(this.AuthorText[0]);
    sel.removeAllRanges();
    sel.addRange(range);

    document.execCommand('fontSize', false, '5');
    document.execCommand('fontName', false, 'Arial');

    sel.removeAllRanges();
    // Remove focus from the two text boxes.
    this.Title.blur();
    this.AuthorText.blur();
}


TitlePage.prototype.UpdateEdits = function () {
    if (this.Note) {
        this.Note.Text = this.AuthorText.html();
        this.Note.HiddenTitle = this.Title.html();
    }
}


//==============================================================================
// How to save css stuff?
// embedded viewers will be children (what to do about multiple records, stacks?).
// Ignore edit for now.
function HtmlPage (parent, edit, background) {
    this.Edit = edit;
    this.Note = null;
    // Should I make another div or just use the parent?
    this.Div = $('<div>')
        .appendTo(parent)
        .hide()
        .css({
            'background-color':background,
            'position' : 'absolute',
            'width': '100%',
            'height': '100%'});
}


HtmlPage.prototype.EditOff = function () {
    if (SA.Edit && this.Edit) {
        this.Edit = false;
        this.Div.css({'width': '100%', 'left': '0px'});
        this.SaEditOff();
    }
}
HtmlPage.prototype.EditOn = function () {
    if (SA.Edit &&  ! this.Edit) {
        this.Edit = true;
        // this.Div.css({'width': '100%', 'left': '0px'}); ???
        this.SaEditOn();
    }
}

// Hide/show the edit gui on all the sa elements
HtmlPage.prototype.SaEditOff = function () {
    $('.sa-edit-gui').saButtons('disable');
    $('.sa-presentation-text').attr('contenteditable', 'false');
    $('.sa-presentation-rectangle').saElement({'editable':false,
                                               'interactive':false});
    $('.sa-light-box').saLightBox({'editable':false,
                                   'interactive':true});
}

HtmlPage.prototype.SaEditOn = function () {
    $('.sa-edit-gui').saButtons('enable');
    $('.sa-presentation-text').attr('contenteditable', 'true');
    $('.sa-presentation-rectangle').saElement({'editable':true,
                                               'interactive':true});
    $('.sa-light-box').saLightBox({'editable':true,
                                   'interactive':true});
}


HtmlPage.prototype.ClearNote = function () {
    if (this.Edit && this.Note) {
        this.UpdateEdits();
    }
    this.Note = null;
}


HtmlPage.prototype.DisplayNote = function (note) {
    // Lets record to position of the previous slides viewers to use
    // as the position of any viewers in the new slide.
    this.DefaultViewerPositions = [];
    var lastViewers = $('.sa-lightbox-viewer');
    for (var i = 0; i < lastViewers.length; ++i) {
        this.DefaultViewerPositions.push(
            {left:lastViewers[i].style.left,
             top:lastViewers[i].style.top,
             width:lastViewers[i].style.width,
             height:lastViewers[i].style.height});
    }

    this.Note = note;
    this.Div.show();
    // This version setsup the saTextEditor and other jquery extensions.
    this.Div.saHtml(note.Text);

    if ( ! this.Edit) {
        // TODO: Reevaulate SaEdit functions.
        this.SaEditOff();
    } else {
        this.SaEditOn();
    }
    // hack
    // Do not let students edit text.
    if ( ! SA.Edit) {
        $('.sa-text-editor').attr('contenteditable', "false")
    }

    // Change the edit status of the elements.
    var self = this;
    this.Div.find('.sa-presentation-image')
        .saLightBox({'editable':SA.Edit,
                     'aspectRatio':true});
    this.Div.find('.sa-lightbox-viewer')
        .saLightBoxViewer({
            'editable':SA.Edit,
            'delete' : function (dom) {self.ViewDeleteCallback(dom);}});
    this.Div.find('.sa-presentation-rectangle')
        .saRectangle({'editable':SA.Edit});
    // Make viewers into lightbox elements.
    // MOVE
    //this.InitializeViews(this.Div.find('.sa-presentation-view'));

    // Set stops.
    $('sa-draggable').saDraggable();
    // still needed for iframes.
    this.BindElements();
    // I do not want to shuffle questions between test and review.
    //if (SA.Edit) {
    //    this.ShuffleQuestion();
    //}
}


// Add the initial html for a title page.
HtmlPage.prototype.InitializeTitlePage = function() {
    this.Div.empty();
    this.Div[0].className = 'sa-presentation-title-page';
    // Title bar
    this.InsertRectangle('#073E87','0%','31%','97.5%','25%');
    // Should everything be have Div as parent?
    // Todo: make this look like jquery.
    var titleText = this.InsertTextBox(50)
        .addClass('sa-presentation-title')
        .css({'color':'white',
              'left' :'10%',
              'width':'88%',
              'top':'40%'})
        .text("Title");

    var authorText = this.InsertTextBox(28)
        .css({'left':'10%',
              'width':'88%',
              'top':'59%'})
        .text("Author");

    this.UpdateEdits();
    this.BindElements();
}

// Add the initial html for a slide page.
HtmlPage.prototype.InitializeSlidePage = function() {
    this.Div.empty();
    this.Div[0].className = 'sa-presentation-slide-page';

    // Title bar
    this.InsertRectangle('#073E87','0%','6%','97.5%','14%');

    // Should everything be have Div as parent?
    // Todo: make this look like jquery.
    var titleText = this.InsertTextBox(42)
        .css({'color':'white',
              'left' :'18%',
              'width':'70%',
              'top':'7.25%',
              'height':'11.5%'})
        .text("Title")
        .addClass('sa-presentation-title');

    this.UpdateEdits();
    this.BindElements();
}

// TODO: make sa jquery handle this. 
HtmlPage.prototype.InsertImage = function(src) {

    var imgDiv;
    var left = 5 + Math.floor(Math.random() * 10);
    var top = 20 + Math.floor(Math.random() * 10);

    /* // link option
    if (ref != "") {
        imgDiv = $('<a>')
            .appendTo(this.Div)
            .attr('href', ref)
            .css({'position':'absolute',
                  'left'    :left+'%',
                  'top'     :top+'%',
                  'z-index' :'1'})
            .addClass('sa-presentation-image')
            .saLightBox();
    } else {*/
    imgDiv = $('<div>')
        .appendTo(this.Div)
        .css({'position':'absolute',
              'left'    :left+'%',
              'top'     :top+'%',
              'z-index' :'1'})
        .saLightBox({aspectRatio: true,
                     editable: SA.Edit})
        .addClass('sa-presentation-image');
    var img = $('<img>')
        .appendTo(imgDiv)
        .css({'width':'100%',
              'height':'100%'});
    img[0].onload = function () {
        // Bug.  imgDiv had no style.width
        // Not scalling
        this.parentNode.style.width = this.width + 'px';
        this.parentNode.style.height = this.height + 'px';
        this.parentNode.saElement.ConvertToPercentages();
    }
    img.attr('src',src);

    return imgDiv;
}

// TODO: Change type based on extension
HtmlPage.prototype.InsertVideo = function(src) {
    // resizable makes a containing div anyway.
    var vidDiv = $('<div>')
        .appendTo(this.Div)
        .css({'position':'absolute',
              'left'    :'10%',
              'top'     :'30%',
              'z-index' :'1'})
        .addClass('sa-presentation-video')
        .saDraggable()
        .saDeletable();

    var vid = $('<video controls>')
        .appendTo(vidDiv);
    var src = $('<source type="video/mp4">')
        .appendTo(vid)
        .attr('src',src);

    vid[0].addEventListener('loadeddata', function() {
        // Video is loaded
        // compute the aspect ratio.
        var aRatio = $(this).width() / $(this).height();
        vidDiv.saResizable({
            aspectRatio: aRatio,
        });
        vid.css({'height' :'100%',
                 'width'  :'100%'});
    }, false);

    return vidDiv;
}

// Make the title bar movable and resizable.
// left, top, width and height should be in percentages. i.e. '50%'
HtmlPage.prototype.InsertRectangle = function(color, left, top, width, height) {
    var bar = $('<div>')
        .appendTo(this.Div)
        .css({'background-color': color,
              'border':'1px solid rgba(255, 255, 255, 0)',
              'position':'absolute',
              'left':left,
              'width':width,
              'top':top,
              'height':height})
        .saRectangle({editable: SA.Edit});
}

// The execCommand paste does not work
HtmlPage.prototype.Paste = function() {
    // resizable makes a containing div anyway.
    var containerDiv = $('<div>')
        .appendTo(this.Div)
        .css({'position':'absolute',
              'left'    :'5%',
              'top'     :'25%'})
        .text("paste here")
        .saDraggable()
        .saDeletable();

    // Select the container
    containerDiv
        .attr('contenteditable', 'true')
        .focus();

    // Select everything.
    var sel = window.getSelection();
    var range = document.createRange();
    range.noCursor = true;
    range.selectNodeContents(containerDiv[0]);
    sel.removeAllRanges();
    sel.addRange(range);
    // This does not work.
    document.execCommand('paste',false,null);
}

// Embed youtube.
//'<iframe width="420" height="315" src="https://www.youtube.com/embed/9tCafgGZtxQ" frameborder="0" allowfullscreen></iframe>');
HtmlPage.prototype.InsertIFrame = function(html) {
    // Youtube size has to be set in the original html string.
    var width, height;
    var start = html.indexOf('width');
    if (start != -1) {
        var str = html.substring(start+7);
        var end = str.indexOf('"');
        var tmp = str.substr(0,end);
        width = parseInt(tmp) / (800*1.333);
        width = Math.round(width*100);
        width = width + '%';
        html = html.replace(tmp, width);
    }
    start = html.indexOf('height');
    if (start != -1) {
        var str = html.substring(start+8);
        var end = str.indexOf('"');
        var tmp = str.substr(0,end);
        height = parseInt(tmp) / 800;
        height = Math.round(height*100);
        height = height + '%';
        html = html.replace(tmp, height);
    }

    var frame = $(html)
        .appendTo(this.Div)
        .css({'position':'absolute',
              'display':'block',
              'left': '5%',
              'top' : '5%',
              'z-index':'1'})
        .saDraggable()
        .saDeletable();

    return frame;
}

HtmlPage.prototype.InsertURL = function(src) {
    // iframes do not scale with css.  I have to have a resize callback.
    var div = $('<div>')
        .appendTo(this.Div)
        .css({'position':'absolute',
              'left':'5%',
              'right':'2.5%',
              'top':'25%',
              'bottom':'10%',
              'z-index':'1'})
        .saDraggable()
        .saDeletable()
        .resizable();
    var frame = $('<iframe>')
        .appendTo(div)
        .css({'position':'absolute',
              'display':'block',
              'width':'100%',
              'height':'100%'})
        .attr('src',src)
        .attr('scrolling','no')
        .addClass('sa-presentation-iframe');

    this.BindElements();
    return frame;
}


// This could be eliminated and just use the jquery saTextEditor.
// Interactively place the initial box.
// First lets see if we can reposition it.
HtmlPage.prototype.InsertTextBox = function(size) {
    size = size || 30;

    // Arbitrary height so I do not need to specify
    // text in percentages.
    var scale = size / 800; 

    // Should everything be have Div as parent?
    var text = $('<div>')
        // note: parent has to be set before saTextEditor is called.
        .appendTo(this.Div)
        .css({'display':'inline-block',
              'position':'absolute',
              'overflow': 'visible',
              'fontFamily': "Verdana,sans-serif",
              'border' : '1px solid rgba(255, 255, 255, 0)',
              // defaults caller can reset these.
              'box-sizing':'border-box',
              'left'   : '5%',
              'width'  : '50%',
              'top'    : '30%',
              'height' : '10%',
              'padding': '2% 1% 1% 1%', // top right bottom left
              'z-index': '1'})
        .addClass('sa-presentation-text')
        // This makes the font scale with height of the window.
        .saScalableFont({scale:scale,
                         editable: SA.Edit})
        // default content
        .text("Text");

    if (this.Edit) {
        // Make this div into a text editor.
        text.saTextEditor({dialog:   true,
                           editable: true});
    }

    return text;
}

HtmlPage.prototype.ShuffleQuestion = function() {
    var questions = this.Div.find('.sa-q [type="multiple-choice"]');
    for (var i = 0; i < questions.length; ++i) {
        var q = questions[i];
        // Shuffle the list.
        for (j = q.childNodes.length; j > 0; --j) {
            var idx = Math.floor(Math.random() * j);
            q.appendChild(q.removeChild(q.childNodes[idx]));
        }
    }
}

// Multiple choice for now.
// Answers stored as list items <li>.
HtmlPage.prototype.InsertQuestion = function() {
    var bar = $('<div>')
        .css({'position':'absolute',
              'left':'2%',
              'width':'92%',
              'top':'75%',
              'height':'22.5%',
              'background':'#FFF',
              'border':'1px solid #AAA',
              'padding':'1% 1% 1% 1%', // top right bottom left
              'z-index' :'1'})
        .saScalableFont({scale:'0.03'})
        .saQuestion({editable: SA.Edit});

    // This is for interactive adding new question from the GUI / dialog.
    // Do not apped the question until apply is selected.
    var self = this;
    bar.saQuestion('OpenDialog',
                   function () {
                       bar.appendTo(self.Div);
                       bar.trigger('resize');
                   });
}





// Should save the view as a child notes, or viewer record?
// For saving, it would be easy to encode the view id into the html as an
// attribute, but what would I do with the other viewer records?  Ignore
// them. One issue:  I have to save the new note to get the id, which is
// necessary, for the saViewer.  Well, maybe not.  I could pass in the
// note, and then get the id when saHtml() is called to save.
HtmlPage.prototype.InsertView = function(viewObj) {
    if ( ! this.Note) {
        return;
    }

    // First make a copy of the view as a child.
    var newNote = new SA.Note();
    var tmpId = newNote.Id;
    newNote.Load(viewObj);
    delete newNote.Id;
    newNote.Id = tmpId;
    if (newNote.ViewerRecords.length == 0) {
        saDebug("Insert failed: Note has no viewer records.");
    } else if (this.Note.Parent) {
        this.Note.Children.push(newNote);
        newNote.Parent = this.Note;
        this.InsertView2(newNote);
    } else {
        // We cannot add a dual view to a tile page because the child note
        // will be interpreted as a new slide.
        this.InsertViewerRecord(newNote.ViewerRecords[0]);
    }
}


// The html page is a note.  It contains viewer whose states are saved in
// viewerRecords.
// Helper method
// TODO: Change newNote to viewerRecord.
HtmlPage.prototype.InsertViewerRecord = function(viewerRecord) {
    if ( ! this.Note) {
        return;
    }

    var viewerIdx = this.Note.ViewerRecords.length;
    this.Note.ViewerRecords.push(viewerRecord);

    var defaultPosition = {left:'5%',top:'25%',width:'40%',height:'40%'};
    if (this.DefaultViewerPositions.length > 0) {
        defaultPosition = this.DefaultViewerPositions.splice(0,1)[0];
    } else {
        var n = (this.Div.children().length) * 5;
        defaultPosition.left = n.toString()+'%';
        defaultPosition.top = (n+15).toString()+'%';
    }

    var self = this;
    var viewerDiv = $('<div>')
        .appendTo(this.Div)
        .css({'position':'absolute',
              'box-shadow': '10px 10px 5px #AAA',
              'background-color':'#FFF',
              'opacity':'1.0',
              'left'   : defaultPosition.left,
              'width'  : defaultPosition.width,
              'top'    : defaultPosition.top,
              'height' : defaultPosition.height})
        .saLightBoxViewer({
            'note'         : this.Note,
            'viewerIndex'  : viewerIdx,
            'hideCopyright': true,
            'editable'     : SA.Edit,
            'delete' : function (dom) {self.ViewDeleteCallback(dom);}});

    return viewerDiv;
}
// The html page is a note.  It contains viewer whose states are saved in
// viewerRecords.
// Helper method
// TODO: Change newNote to viewerRecord.
HtmlPage.prototype.InsertView2 = function(view) {
    if ( ! this.Note) {
        return;
    }

    var defaultPosition = {left:'5%',top:'25%',width:'45%',height:'45%'};
    if (this.DefaultViewerPositions.length > 0) {
        defaultPosition = this.DefaultViewerPositions.splice(0,1)[0];
    }

    var self = this;
    var viewerDiv = $('<div>')
        .appendTo(this.Div)
        .css({'position':'absolute',
              'box-shadow': '10px 10px 5px #AAA',
              'background-color':'#FFF',
              'opacity':'1.0',
              'left'   : defaultPosition.left,
              'width'  : defaultPosition.width,
              'top'    : defaultPosition.top,
              'height' : defaultPosition.height})
        .saLightBoxViewer({
            'note'         : view,
            'dual'         : true,
            'hideCopyright': true,
            'delete' : function (dom) {self.ViewDeleteCallback(dom);},
            'editable'     : SA.Edit});

    return viewerDiv;
}
// This was for development debugging
HtmlPage.prototype.InsertViewId2 = function(viewId) {
    if ( ! this.Note) {
        return;
    }

    var defaultPosition = {left:'5%',top:'25%',width:'45%',height:'45%'};
    if (this.DefaultViewerPositions.length > 0) {
        defaultPosition = this.DefaultViewerPositions.splice(0,1)[0];
    }

    var viewerDiv = $('<div>')
        .appendTo(this.Div)
        .css({'position':'absolute',
              'box-shadow': '10px 10px 5px #AAA',
              'background-color':'#FFF',
              'opacity':'1.0',
              'left'   : defaultPosition.left,
              'width'  : defaultPosition.width,
              'top'    : defaultPosition.top,
              'height' : defaultPosition.height})
        .saLightBoxViewer({
            'viewId'       : viewId,
            'dual'         : true,
            'hideCopyright': true,
            'editable'     : SA.Edit});

    return viewerDiv;
}

HtmlPage.prototype.ViewDeleteCallback = function (dom) {
    // When a viewer is deleted the next should replace it.
    this.DefaultViewerPositions.push(
        {left:dom.style.left,
         top:dom.style.top,
         width:dom.style.width,
         height:dom.style.height});

    // Extra viewer records get pruned when the page is converted to html
    // Get rid of dual viewer notes.
    if (dom.saViewer.saNote != this.Note) {
        var childIdx = this.Note.Children.indexOf(dom.saViewer.saNote);
        if ( childIdx >= 0) {
            this.Note.Children.splice(childIdx,1);
        }
    }
}

// NOTE: This should be lagacy now.  The jquery extensions should handle this.
// Text elements need to resize explicitly.
// TODO: Activate text (saScalatFont, saTextEditor, resize) on load.
// I could make this scalabe ifram as a jquery extension too.
HtmlPage.prototype.BindElements = function() {
    // Similar to text, we need to scale the content.
    frameElements = $('.sa-presentation-iframe');
    frameElements.addClass('sa-resize');
    for (var i = 0; i < frameElements.length; ++i) {
        frame = frameElements[i];
        frame.onresize =
            function () {
                var w = $(this).parent().width();
                var h = $(this).parent().height();
                scale = Math.min(h,w/1.62) / 700;
                scaleStr = scale.toString();
                w = (Math.floor(w/scale)).toString();
                h = (Math.floor(h/scale)).toString();

                $(this).css({'-ms-zoom': scaleStr,
                             '-ms-transform-origin': '0 0',
                             '-moz-transform': 'scale('+scaleStr+')',
                             '-moz-transform-origin': '0px 50px',
                             '-o-transform': 'scale('+scaleStr+')',
                             '-o-transform-origin': '0px 50px',
                             '-webkit-transform': 'scale('+scaleStr+')',
                             '-webkit-transform-origin': '0 0',
                             'width':  w +'px',
                             'height': h +'px'});
            };
        frame.onresize();
    }
}


HtmlPage.prototype.UpdateEdits = function () {
    if (this.Note) {
        // Record the camera position (and annotations).
        this.Div.find('.sa-lightbox-viewer').saRecordViewer();
        // Doing this here forces us to save the notes
        // TODO: This may created orphaned views. fix this be either
        // delaying copying saHtml to note, or incrementally saving
        // presentation to the database.
        var htmlDiv = this.Div;
        var note = this.Note;

        // prune deleted records.
        // I should really do this when a view is deleted, but there are
        // deleted records in the database.
        // NOTE: THIS ASSUME THAT ALL THE VIEWERS USE THIS NOTE!!!
        var newRecords = [];
        for (var i = 0; i < this.Note.ViewerRecords.length; ++i) {
            var record = this.Note.ViewerRecords[i];
            var str = i.toString();
            var items = $('[sa-viewer-index='+str+']');
            if (items.length > 0) {
                // Replace the index with the new index
                items.attr('sa-viewer-index', newRecords.length);
                newRecords.push(record);
            }
        }
        this.Note.ViewerRecords = newRecords;

        note.Text = htmlDiv.saHtml();
    }
}



    SA.Presentation = Presentation;

})();






//==============================================================================
function SearchPanel(parent, callback) {
    var self = this;
    this.UserCallback = callback;
    this.Parent = parent;

    // List of image data needed for callback.
    this.SearchData = [];

    // TODO:
    // User should probably be formating the parent.
    parent
        .css({'overflow': 'auto',
              'text-align': 'left',
              'color': '#303030',
              'font-size': '18px'});
    this.SearchForm = $('<form>')
        .appendTo(parent)
        .css({'width':'100%',
              'display':'table'})
        .submit(function(e) {self.SearchCallback(); return false;});
    this.SearchLabel = $('<span>')
        .appendTo(this.SearchForm)
        .css({'display':'table-cell',
              'padding':'8px',
              'width':'3.5em'})
        .text("Search:");
    this.SearchInput = $('<input>')
        .appendTo(this.SearchForm)
        .css({'width':'95%',
              'display':'table-cell',
              'border':'2px inset #CCC'})
        .focusin(function() { SA.ContentEditableHasFocus = true;})
        .focusout(function() { SA.ContentEditableHasFocus = false;});
    this.SearchResults = $('<div>')
        .appendTo(parent)
        .css({'position':'absolute',
              'top':'2em',
              'bottom':'0px',
              'width':'100%',
              'overflow-y':'auto'});
}


SearchPanel.prototype.SearchCallback = function() {
    var self = this;
    var terms = this.SearchInput.val();

    this.Parent.css({'cursor':'progress'});
    $.ajax({
        type: "get",
        url: "/webgl-viewer/query",
        data: {'terms': terms},
        success: function(data,status){
            self.LoadSearchResults(data);
            self.Parent.css({'cursor':'default'});
        },
        error: function() {
            saDebug( "AJAX - error() : query" );
            self.Parent.css({'cursor':'default'});
        },
    });
}


SearchPanel.prototype.LoadSearchResults = function(data) {
    var self = this;
    this.SearchResults.empty();
    this.SearchData = data.images;

    // These are in order of best match.
    for (var i = 0; i < data.images.length; ++i) {
        imgObj = data.images[i];

        var imageDiv = $('<div>')
            .appendTo(this.SearchResults)
            .css({'float':'left',
                  'margin':'5px',
                  'border': '1px solid #AAA'})
            .attr('id', imgObj._id)
            .data('index', i)
            .hover(function(){$(this).css({'border-color':'#00F'});},
                   function(){$(this).css({'border-color':'#AAA'});})
            .click(function(){
                self.SelectCallback($(this).data('index'));
            });

        var image  = {img       : imgObj._id,
                      db        : imgObj.database,
                      levels    : imgObj.levels,
                      tile_size : imgObj.TileSize,
                      bounds    : imgObj.bounds,
                      label     : imgObj.label};
        if ( ! image.bounds ) {
            image.bounds = [0, imgObj.dimensions[0], 0,
                      imgObj.dimensions[1]];
        }
        var thumb = new CutoutThumb(image, 100);
        thumb.Div.appendTo(imageDiv)
        var labelDiv = $('<div>')
            .css({'font-size':'50%'})
            .appendTo(imageDiv)
            .text(imgObj.label); // Should really have the image label.
    }
}

SearchPanel.prototype.SelectCallback = function(index) {
    // Search data is just a list of image objects.
    if (this.UserCallback && index >=0 && index<this.SearchData.length) {
        (this.UserCallback)(this.SearchData[index]);
    }
}

//==============================================================================

function ClipboardPanel(parent, callback) {
    var self = this;
    this.UserCallback = callback;

    parent
        .css({'overflow': 'auto',
              'text-align': 'left',
              'color': '#303030',
              'font-size': '18px'});
    this.ClearButton = $('<button>')
        .appendTo(parent)
        .click(function () { self.ClipboardDeleteAll(); })
        .text("Remove All");
    this.ClipboardDiv = $('<div>')
        .css({'overflow_y':'auto'})
        .appendTo(parent);

    $.ajax({
        type: "get",
        url: "webgl-viewer/getfavoriteviews",
        success: function(data,status){
            if (status == "success") {
                self.LoadClipboardCallback(data);
            } else { saDebug("ajax failed - get favorite views 2"); }
        },
        error: function() { saDebug( "AJAX - error() : getfavoriteviews 2" );
        },
    });
}

ClipboardPanel.prototype.LoadClipboardCallback = function(sessionData) {
    var self = this;
    this.ClipboardDiv.empty();
    this.ClipboardViews = sessionData.viewArray;

    for (var i = 0; i < this.ClipboardViews.length; ++i) {
        var view = this.ClipboardViews[i];
        if (view.Thumb.substring(0,6) == "http:/") {
            view.Thumb = view.Thumb.substring(6);
        }
        var thumb = $('<img>')
            .appendTo(this.ClipboardDiv)
            .attr('src', view.Thumb)
            .prop('title', view.Title)
            .css({'float':'left',
                  'margin':'5px',
                  'border': '1px solid #AAA',
                  'height': '60px'})
            .attr('index', i)
            .hover(function(){$(this).css({'border-color':'#00F'});},
                   function(){$(this).css({'border-color':'#AAA'});})
            .click(function(){
                self.ClickViewCallback(parseInt(this.getAttribute("index")));
            });
    }
}


ClipboardPanel.prototype.ClickViewCallback = function(idx) {
    if (this.UserCallback && idx >= 0 && idx < this.ClipboardViews.length) {
        (this.UserCallback)(this.ClipboardViews[idx]);
    }
}


ClipboardPanel.prototype.ClipboardDeleteAll = function() {
    var self = this;
    this.ClipboardDiv.empty();

    for (var i = 0; i < this.ClipboardViews.length; ++i) {
        $.ajax({
            type: "post",
            url: "/webgl-viewer/deleteusernote",
            data: {"noteId": this.ClipboardViews[i]._id,
                   "col" : "views"},//"favorites"
            success: function(data,status) {
            },
            error: function() {
                saDebug( "AJAX - error() : deleteusernote" );
            },
        });
    }
}







// Make this a singlton (effectively) for now.
// Two levels of caching and pruning.
// Image without an associated texture map.
// Texture maps (scarcer resource).




function InitProgressBar () {
  if (SA.ProgressBar) { return;}
  SA.ProgressBar = $("<div>")
   .appendTo('body')
   .addClass("sa-view-progress-bar");
}



function AdvanceTimeStamp() {
  ++SA.TimeStamp;
}

function GetCurrentTime() {
  return SA.TimeStamp;
}

// Prunning could be rethought to avoid so much depdency on the cache.
function Prune() {
  var prune = false;
  if (SA.NumberOfTiles >= SA.MaximumNumberOfTiles) {
    // Overflow may be possible after running for a while.
    if (SA.PruneTimeTiles > SA.TimeStamp) {
      SA.PruneTimeTiles = 0;
    }
    // Advance the prune threshold.
    SA.PruneTimeTiles += 0.05 * (SA.TimeStamp - SA.PruneTimeTiles);
    prune = true;
  }

  if (SA.NumberOfTextures >= SA.MaximumNumberOfTextures) {
    // Overflow may be possible after running for a while.
    if (SA.PruneTimeTextures > SA.TimeStamp) {
      SA.PruneTimeTextures = 0;
    }
    // Advance the prune threshold.
    SA.PruneTimeTextures += 0.05 * (SA.TimeStamp - SA.PruneTimeTextures);
    prune = true;
  }

  if (prune) {
    for (i in SA.Caches) {
      cache = SA.Caches[i];
      cache.PruneTiles();
    }
  }
}

function ClearQueue() {
    for (var i = 0; i < SA.LoadQueue.length; ++i) {
        var tile = SA.LoadQueue[i];
        if (tile) {
            tile.LoadState = 0;
        }
    }
    SA.LoadQueue = [];
    LoadQueueUpdate();
}

// You have to call LoadQueueUpdate after adding tiles.
// We could chop off the lowest priority tiles if the queue gets too long.
// Simply add the tile to the queue.
function LoadQueueAddTile(tile) {
    if (tile.LoadState == 0 || tile.LoadState == 4) {
        // New tile or error
        tile.LoadState = 1;
        // Add the tile at the front of the queue.
        SA.LoadQueue.push(tile);
    }
}

// Push the best tile to the end of the queue.
function PushBestToLast() {
  // Do a sort pass (pushing high priority items to the end.
  var t0 = SA.LoadQueue[0];
  for (var i = 1; i < SA.LoadQueue.length; ++i) {
    var t1 = SA.LoadQueue[i];
    var swap = false;
    if (t1 != null) {
      if (t0 == null) {
        swap = true;
      } else if (t0.TimeStamp > t1.TimeStamp) {
        swap = true;
      } else if (t0.TimeStamp == t1.TimeStamp && t0.Level < t1.Level) {
        swap = true;
      }
    }
    if (swap) {
      // Swap the pair.
      SA.LoadQueue[i] = t0;
      SA.LoadQueue[i-1] = t1;
    } else {
      t0 = t1;
    }
  }
}



// I need a way to remove tiles from the queue when they are deleted.
// I know this is inefficient.
function LoadQueueRemove(tile) {
  var length = SA.LoadQueue.length;
  for (var i = 0; i < length; ++i) {
    if (SA.LoadQueue[i] == tile) {
      tile.LoadState = 0;
      SA.LoadQueue[i] = null;
      return;
    }
  }
}


function LoadTimeout() {
  // 4 images requests are too slow.  Reset
  // I do not know which requests failed so I cannot mak another request.
  // TODO: Remember loading tiles (even if only for debugging).
  SA.LoadingCount = 0;
  LoadQueueUpdate();
}

// We will have some number of tiles loading at one time.
// Take the first N tiles from the queue and start loading them.
// Too many and we cannot abort loading.
// Too few and we will serialize loading.
function LoadQueueUpdate() {
    if (SA.LoadingCount < 0) {
        // Tiles must have arrived after timeout.
        SA.LoadingCount = 0;
    }
    while (SA.LoadingCount < SA.LoadingMaximum &&
           SA.LoadQueue.length > 0) {
        PushBestToLast();
        var tile = SA.LoadQueue.pop();
        // For debugging
        //this.PendingTiles.push(tile);
        if (tile != null && tile.LoadState == 1) {
            tile.StartLoad(tile.Cache);
            tile.LoadState = 2; // Loading.
            ++SA.LoadingCount;
        }
    }

    // Observed bug: If 4 tile requests never return, loading stops.
    // Do a time out to clear this hang.
    if (SA.LoadTimeoutId) {
        clearTimeout(SA.LoadTimeoutId);
        SA.LoadTimeoutId = 0;
    }
    if (SA.LoadingCount) {
        SA.LoadTimeoutId = setTimeout(function(){LoadTimeout();}, 1000);
    }

    if (SA.ProgressBar) {
        if (SA.LoadProgressMax < SA.LoadQueue.length) {
            SA.LoadProgressMax = SA.LoadQueue.length;
        }
        var width = (100 * SA.LoadQueue.length / SA.LoadProgressMax).toFixed();
        width = width + "%";
        SA.ProgressBar.css({"width" : width});
        // Reset maximum
        if (SA.LoadQueue.length == 0) {
            SA.LoadProgressMax = 0;
        }
    }

    if (SA.FinishedLoadingCallbacks.length > 0 &&
        SA.LoadQueue.length == 0 && SA.LoadingCount == 0) {
        var tmp = SA.FinishedLoadingCallbacks.slice(0); // copy
        SA.FinishedLoadingCallbacks = [];
        for (var i = 0; i < tmp.length; ++i) {
            (tmp[i])();
        }
    }
}

function AddFinishedLoadingCallback(callback) {
    SA.FinishedLoadingCallbacks.push(callback);
    LoadQueueUpdate();
}

function ClearFinishedLoadingCallbacks() {
    SA.FinishedLoadingCallbacks = [];
}



// Issue: Tiles call this method when their image gets loaded.
// How does the tile know which cache it belongs too.
// Marks a tile as loaded so another can start.
function LoadQueueLoaded(tile) {
    --SA.LoadingCount;
    tile.LoadState = 3; // Loaded
    LoadQueueUpdate();
}

// This is called if their was a 404 image not found error.
function LoadQueueError(tile) {
  tile.LoadState = 4; // Error Loading
  --SA.LoadingCount;
  LoadQueueUpdate();
}

//==============================================================================
// Camera Object
// Set the viewport separately
function Camera () {
    // Better managmenet of layers and sub layers.
    // Assign a range of the z buffer  for the view to use exclusively.
    // The full range is -1->1.  -1 is in front.
    this.ZRange = [-1.0,1.0];
    this.Roll = 0;
    this.Matrix = mat4.create();
    this.Height = 256.0 * 64.0;
    this.Width = this.Height * 1.62;
    this.FocalPoint = [128.0*64.0, 128.0*64.0];
    this.ComputeMatrix();
    // for drawing the view bounds.
    this.Points = [];
    this.Buffer = null;
    this.CreateBuffer();
    this.Mirror = false;

    // Placeholders
    this.ViewportWidth = 162;
    this.ViewportHeight = 100;
}

// Spacing of pixels of the screen.
Camera.prototype.GetSpacing = function() {
    return this.GetHeight() / this.ViewportHeight;
}

Camera.prototype.DeepCopy = function (inCam) {
    if (inCam.ZRange) { this.ZRange = inCam.ZRange.slice(0); }
    this.Roll = inCam.Roll;
    this.Height = inCam.Height;
    this.Width = inCam.Width;
    this.SetFocalPoint( inCam.FocalPoint);
    if (inCam.ViewportWidth) { this.ViewportWidth = inCam.ViewportWidth; }
    if (inCam.ViewportHeight) { this.ViewportHeight = inCam.ViewportHeight; }
    this.ComputeMatrix();
}

Camera.prototype.SetViewport = function (viewport) {
    if (10*viewport[3] < viewport[2]) {
        //alert("Unusual viewport " + viewport[3]);
        return;
    }
    this.ViewportWidth = viewport[2];
    this.ViewportHeight = viewport[3];
    this.Width = this.Height * this.ViewportWidth / this.ViewportHeight;
    this.ComputeMatrix();
}


Camera.prototype.Serialize = function () {
  var obj = {};
  obj.FocalPoint = [this.FocalPoint[0], this.FocalPoint[1]];
  obj.Roll = this.Roll;
  obj.Height = this.GetHeight();
  obj.Width = this.GetWidth();
  return obj;
}

Camera.prototype.Load = function (obj) {
    this.SetFocalPoint( obj.FocalPoint);
    this.Roll = obj.Roll;
    this.Height = obj.Height;
    if (obj.Width) {
        this.Width = obj.Width;
    } else {
        this.Width = this.Height * 1.62;
    }

    // Width is computed from height and aspect.
    this.ComputeMatrix();
}


// Roll is in Radians
// Rotation is in Degrees
Camera.prototype.GetRotation = function () {
    return this.Roll * 180.0 / 3.1415926535;
}

Camera.prototype.GetFocalPoint = function () {
  // Copy to avoid bugs because arrays are shared.
  // These are nasty to find.
  return [this.FocalPoint[0],this.FocalPoint[1]];
}

Camera.prototype.SetFocalPoint = function (fp) {
  if (isNaN(fp[0]) || isNaN(fp[1])) {
    console.log("Camera 1");
    return;
  }
  this.FocalPoint[0] = fp[0];
  this.FocalPoint[1] = fp[1];
  // Ignore z on purpose.
}


Camera.prototype.ConvertPointViewerToWorld = function(x, y) {
    // Convert to world coordinate system
    // Compute focal point from inverse overview camera.
    x = x/this.ViewportWidth;
    y = y/this.ViewportHeight;
    x = (x*2.0 - 1.0)*this.Matrix[15];
    y = (1.0 - y*2.0)*this.Matrix[15];
    var m = this.Matrix;
    var det = m[0]*m[5] - m[1]*m[4];
    var xNew = (x*m[5]-y*m[4]+m[4]*m[13]-m[5]*m[12]) / det;
    var yNew = (y*m[0]-x*m[1]-m[0]*m[13]+m[1]*m[12]) / det;

    return [xNew, yNew];
}

Camera.prototype.ConvertPointWorldToViewer = function(x, y) {
    var m = this.Matrix;

    // Convert from world coordinate to view (-1->1);
    var h = (x*m[3] + y*m[7] + m[15]);
    var xNew = (x*m[0] + y*m[4] + m[12]) / h;
    var yNew = (x*m[1] + y*m[5] + m[13]) / h;
    // Convert from view to screen pixel coordinates.
    xNew = (1.0+xNew)*0.5*this.ViewportWidth;
    yNew = (1.0-yNew)*0.5*this.ViewportHeight;

    return [xNew, yNew];
}

// dx, dy are in view coordinates [-0.5,0.5].
// The camera matrix converts world to view.
Camera.prototype.HandleTranslate = function (dx,dy) {
    // Convert view vector to world vector.
    // We could invert the matrix to get the transform, but this is easier for now.....
    var s = Math.sin(this.Roll);
    var c = Math.cos(this.Roll);
    var x = this.FocalPoint[0];
    var y = this.FocalPoint[1];
    var z = 10;
    var w = this.GetWidth();
    var h = this.GetHeight();

    if (this.Mirror) {
      dy = -dy;
    }

    // Scale to world.
    dx = dx * w;
    dy = dy * w;
    // Rotate
    var rx = dx*c + dy*s;
    var ry = dy*c - dx*s;

    this.Translate(rx,ry,0.0);
}

// x,y are in display coordiantes (origin at the center).
// dx,dy are in the same coordinates system (scale).
// Scale does not matter because we only care about rotation.
Camera.prototype.HandleRoll = function (x,y, dx, dy) {
  // Avoid divide by zero / singularity
  if (x == 0 && y == 0) {
    return;
  }
  // Orthogonal (counter clockwise) dot dVect.
  var dRoll = -y*dx +x*dy;
  // Remove magnitude of location.
  // Scale by R to get correct angle.
  dRoll = dRoll / (x*x + y*y);
  if ( this.Mirror) {
    dRoll = -dRoll;
  }
  // Keep roll in radians.
  this.Roll += dRoll;

  this.ComputeMatrix();
}


Camera.prototype.Translate = function (dx,dy,dz) {
    if (isNaN(dx) || isNaN(dy) || isNaN(dz)) {
        console.log("Camera 2");
        return;
    }
    // I will leave this as an exception.
    // Everything else uses SetFocalPoint([x,y]);
    this.FocalPoint[0] += dx;
    this.FocalPoint[1] += dy;
    //this.FocalPoint[2] += dz;
    this.ComputeMatrix();
}


Camera.prototype.GetHeight = function () {
  return this.Height;
}


Camera.prototype.SetHeight = function (height) {
    if (isNaN(height)) {
        console.log("Camera 3");
        return;
    }
    this.Height = height;
    // Width tracks height.
    this.Width = height * this.ViewportWidth / this.ViewportHeight;
}


Camera.prototype.GetWidth = function () {
    return this.Width;
}


Camera.prototype.SetWidth = function (width) {
    if (isNaN(width)) {
        console.log("Camera 4");
        return;
    }
    this.Width = width;
    // Width tracks height.
    this.Height = width * this.ViewportHeight / this.ViewportWidth;
}

Camera.prototype.SetRoll = function (roll) {
    this.Roll = roll;
}



// Slide coordinates.
Camera.prototype.GetBounds = function () {
    var width = this.GetWidth();
    var bds = new Array(4);
    bds[0] = this.FocalPoint[0] - (width*0.5);
    bds[1] = bds[0] + width;
    bds[2] = this.FocalPoint[1] - (this.Height*0.5);
    bds[3] = bds[2] + this.Height;
    return bds;
}


// Camera matrix transforms points into camera coordinate system
// X:(-1->1)
// Y:(-1->1) (-1 is bottom)
// Z:(-1->1) (-1 is front)
Camera.prototype.ComputeMatrix = function () {
    var s = Math.sin(this.Roll);
    var c = Math.cos(this.Roll);
    var x = this.FocalPoint[0];
    var y = this.FocalPoint[1];
    var z = 10;
    var w = this.GetWidth();
    // var ht = this.GetHeight();  The iPad got this wrong?????
    var ht = this.Height;

    if (ht > 1000000) {
      StartLogging();
      LogMessage("First height is big " + this.height);
    }
    if (w < 0) { return; }

    if (this.Mirror) { ht = -ht; }

    mat4.identity(this.Matrix);

    this.Matrix[0] = c;
    this.Matrix[1] = -s*w/ht;
    this.Matrix[4] =  -s;
    this.Matrix[5] =  -c*w/ht;
    this.Matrix[9] =  0;
    this.Matrix[10]=  (this.ZRange[1]-this.ZRange[0])*0.5;
    this.Matrix[12]= -c*x + s*y;
    this.Matrix[13]= -(w/ht)*(-s*x - c*y);
    this.Matrix[14]=  -z + (this.ZRange[1]+this.ZRange[0])*0.25*w;
    this.Matrix[15]=  0.5*w;

  if (Math.abs(this.Matrix[5]) < 0.01 &&
      Math.abs(this.Matrix[4]) < 0.01) {
    StartLogging();
    LogMessage("m[4] " + this.Matrix[4]);
    LogMessage("m[5] " + this.Matrix[4]);
    LogMessage("c = " + c);
    LogMessage("w = " + w);
    LogMessage("ht = " + ht);
    LogMessage("height = " + this.Height);
  }
}

// TODO: ROOT_SPACING IS UNDEFINED.
// Reset is not bound to any event.
Camera.prototype.Reset = function () {
    // Compute the bounds
    var bounds = [];
    bounds[0] = bounds[2] = bounds[4] = 0.0;
    bounds[1] = TILE_DIMENSIONS[0] * ROOT_SPACING[0];
    bounds[3] = TILE_DIMENSIONS[1] * ROOT_SPACING[1];
    bounds[5] = NUMBER_OF_SECTIONS * ROOT_SPACING[2];

    this.SetFocalPoint( [(bounds[0] + bounds[1]) * 0.5,
                         (bounds[2] + bounds[3]) * 0.5]);

    this.SetHeight(bounds[3]-bounds[2]);
    this.ComputeMatrix();
}

// Currenly assumes parallel projection and display z range = [-1,1].
// Also no rotation!
// a.k.a. This method does not work.
Camera.prototype.DisplayToWorld = function (x,y,z) {
    var scale = this.Height / this.ViewportHeight;
    x = x - (0.5*this.ViewportWidth);
    y = y - (0.5*this.ViewportHeight);
    var worldPt = [];
    worldPt[0] = this.FocalPoint[0] + (x * scale);
    worldPt[1] = this.FocalPoint[1] + (y * scale);
    worldPt[2] = 10 + (z * this.Height * 0.5);

    return worldPt;
}

Camera.prototype.AddPoint = function (x, y, z) {
    this.Points.push(x);
    this.Points.push(y);
    this.Points.push(z);
}

Camera.prototype.CreateBuffer = function () {
  if (GL) {
    if (this.Buffer != null) {
      GL.deleteBuffer(this.Buffer);
    }
    this.Buffer = GL.createBuffer();
    GL.bindBuffer(GL.ARRAY_BUFFER, this.Buffer);
    GL.bufferData(GL.ARRAY_BUFFER, new Float32Array(this.Points),
                  GL.STATIC_DRAW);
  }
}

// Getting rid of this.
Camera.prototype.UpdateBuffer = function() {
    this.Points = [];
    var cx = this.FocalPoint[0];
    var cy = this.FocalPoint[1];
    var rx = this.GetWidth() * 0.5;
    var ry = this.GetHeight() * 0.5;
    this.AddPoint(cx-rx, cy-ry);
    this.AddPoint(cx+rx, cy-ry);
    this.AddPoint(cx+rx, cy+ry);
    this.AddPoint(cx-rx, cy+ry);
    this.AddPoint(cx-rx, cy-ry);
    this.CreateBuffer();
}


// Camera is already set.
Camera.prototype.Draw = function (overview) {
    var overviewCam = overview.Camera;
    var viewport = overview.Viewport;

    var cx = this.FocalPoint[0];
    var cy = this.FocalPoint[1];
    var rx = this.GetWidth() * 0.5;
    var ry = this.GetHeight() * 0.5;

    // To handle rotation, I need to pass the center through
    // the overview camera matrix. Coordinate system is -1->1
    var newCx = (cx*overviewCam.Matrix[0] + cy*overviewCam.Matrix[4]
                 + overviewCam.Matrix[12]) / overviewCam.Matrix[15];
    var newCy = (cx*overviewCam.Matrix[1] + cy*overviewCam.Matrix[5]
                 + overviewCam.Matrix[13]) / overviewCam.Matrix[15];

    if (GL) {
        // I having trouble using the overview camera, so lets just compute
        // the position of the rectangle here.
        var ocx = overviewCam.FocalPoint[0];
        var ocy = overviewCam.FocalPoint[1];
        var orx = overviewCam.GetWidth() * 0.5;
        var ory = overviewCam.GetHeight() * 0.5;

        program = polyProgram;
        GL.useProgram(program);
        GL.uniform3f(program.colorUniform, 0.9, 0.0, 0.9);

        GL.viewport(viewport[0],viewport[1],viewport[2],viewport[3]);
        mat4.identity(pMatrix);
        GL.uniformMatrix4fv(program.pMatrixUniform, false, pMatrix);

        var viewFrontZ = overviewCam.ZRange[0]+0.001;

        mat4.identity(mvMatrix);
        //mvMatrix[12] = ((cx-rx)-ocx)/orx;
        //mvMatrix[13] = ((cy-ry)-ocy)/ory;
        mvMatrix[12] = newCx-(rx/orx);
        mvMatrix[13] = newCy-(ry/ory);
        mvMatrix[14] = viewFrontZ;
        mvMatrix[0] = 2*rx/orx;
        mvMatrix[5] = 2*ry/ory;

        GL.bindBuffer(GL.ARRAY_BUFFER, squareOutlinePositionBuffer);
        GL.vertexAttribPointer(program.vertexPositionAttribute,
                               squareOutlinePositionBuffer.itemSize,
                               GL.FLOAT, false, 0, 0);
        GL.uniformMatrix4fv(program.mvMatrixUniform, false, mvMatrix);
        GL.drawArrays(GL.LINE_STRIP, 0, squareOutlinePositionBuffer.numItems);
    } else {
        // Transform focal point from -1->1 to viewport
        newCx = (1.0 + newCx) * viewport[2] * 0.5;
        newCy = (1.0 - newCy) * viewport[3] * 0.5;
        // Scale width and height from world to viewport.
        rx = rx * viewport[3] / overviewCam.GetHeight();
        ry = ry * viewport[3] / overviewCam.GetHeight();

        // The 2d canvas was left in world coordinates.
        var ctx = overview.Context2d;
        /*
          ctx.beginPath();
          //ctx.strokeStyle="#E500E5";
          ctx.rect(this.FocalPoint[0]-(0.5*width),this.FocalPoint[1]-(0.5*height),width,height);
          //ctx.fillStyle="#E500E5";
          //ctx.fillRect(this.FocalPoint[0]-(0.5*width),this.FocalPoint[1]-(0.5*height),width,height);
          ctx.stroke();
        */
        ctx.save();
        //ctx.setTransform(1,0,0,1,0,0);
        // Now that the while slide / overview canvas is rotating
        // We have to rotate the rectangle.
        var c = Math.cos(this.Roll);
        var s = Math.sin(this.Roll);
        ctx.setTransform(c,-s,+s,c,
                         (1-c)*newCx-s*newCy,
                         (1-c)*newCy+s*newCx)

        ctx.strokeStyle="#4011E5";
        ctx.beginPath();
        ctx.rect(newCx-rx,newCy-ry,2*rx,2*ry);
        ctx.stroke();
        ctx.restore();
    }

}






// Generate an image of any resolution and size.

// You can use "FindCache(image)" to get the cache.
// image is the database image object with all the image meta data.

// How can you use the image data returned?
// canvasContext.putImageData(data, 0, 0);
// image = document.createElement('img');
// image.src = canvas.toDataURL('image/png');

// - cache: references the image source.
// - dimensions [xDim,yDim]: Final image dimensions in image pixels.
// - focalPoint [x,y,z]: the center of the image in slide coordinates.
// - rotation: Rotation around the focal point in degrees.
// - scale:  Image pixel size in slide coordinates. 1 is highest resolution.
// - returnCallback(data): Since non blocking ajax calls get the tiles necessary
//     to construct the image, we return the image data with a callback
//     function. The data returned is same as "ctx.getImageData(0,0,w,h);",
//     but we add data.Camera for conversion to the slide coordinate system.

// for debugging
var CUTOUT_VIEW;


function DownloadImageData(data, filename) {
    // The only way I know if is to put in into a canvas.

    // Construct a view to render the image on the client.
    var width =  data.width;
    var height =  data.height;
    var viewport = [0,0, width, height];

    var view = new SA.View();
    view.InitializeViewport(viewport, 1, true);
    view.Canvas.attr("width", width);
    view.Canvas.attr("height", height);
    view.Context2d.putImageData(data, 0, 0);

    view.Canvas[0].toBlob(function(blob) {saveAs(blob, filename);}, "image/png");
}

// If file name is not null or "", this image is save to the client.
// cache: The image/tile source.
// dimensions: size of the image in pixels [xDim,yDim]
// focalPoint: Center of the image in world / slide coordinates.
// scale:  Size of a pixel in world coordinates.
// roll: in radians?
// fileName: name of file to download. (null, or "" means do not download).
// returnCallback:  function to call (with data as argument) when done.
function GetCutoutImage(cache, dimensions, focalPoint, scale, roll, fileName,
                        returnCallback) {
    // Construct a view to render the image on the client.
    var width =  dimensions[0];
    var height =  dimensions[1];
    var viewport = [0,0, width, height];

    var view = new SA.View();
    CUTOUT_VIEW = view;
    view.SetCache(cache);
    view.InitializeViewport(viewport, 1, true);
    var newCam = view.Camera;
    newCam.SetFocalPoint( focalPoint);
    newCam.SetRoll(roll);
    newCam.SetHeight(height*scale);
    // TODO:  Hide matrix computation.  Make it automatic.
    newCam.ComputeMatrix();

    // Load only the tiles we need.
    var tiles = cache.ChooseTiles(newCam, 0, []);
    for (var i = 0; i < tiles.length; ++i) {
        LoadQueueAddTile(tiles[i]);
    }

    AddFinishedLoadingCallback(
        function () {GetCutoutImage2(view, fileName, returnCallback);}
    );

    LoadQueueUpdate();

    console.log("trigger " + SA.LoadQueue.length + " " + SA.LoadingCount);
}

GetCutoutImage2 = function(view, fileName, returnCallback) {
    // All the tiles are loaded and waiting in the cache.
    view.DrawTiles();
    var viewport = view.GetViewport();

    if (fileName && fileName != "") {
        view.Canvas[0].toBlob(function(blob) {saveAs(blob, fileName);}, "image/png");
    }

    if (returnCallback) {
        var ctx  = view.Context2d;
        var data = GetImageData(view);
        returnCallback(data);
    }
}



// This works great!
// Light weight viewer.
// Attempt to make a div with multiple images.
// image = database image object.
// height = height in screen pixels of the returned div image.
// request = (optional) bounds of cropped image in slide pixel units.
//           if request is not defined, it defaults to the whole image bounds.
// Events are funny,  The mouse position is realtive to
// the tiles.  click and bounds are callback functions to make
// interaction simpler.
function  CutoutThumb(image, height, request) {
    if ( ! request) {
        request = image.bounds;
    }

    this.ImageData = image;
    this.Height = height;
    this.Width = Math.ceil(height * (request[1]-request[0]) / (request[3]-request[2]));
    this.Div = $('<div>')
        .css({'width' : this.Width + 'px',
              'height': this.Height + 'px'  })
        .addClass("sa-view-cutout-thumb-div");
    // Crop the request so we do not ask for tiles that do not exist.
    var levelReq;
    if (image.bounds) {
      var levelReq = [Math.max(request[0],image.bounds[0]),
                    Math.min(request[1],image.bounds[1]),
                    Math.max(request[2],image.bounds[2]),
                    Math.min(request[3],image.bounds[3])];
    } else {
        levelReq = [Math.max(request[0],0), request[1],
                    Math.max(request[2],0), request[3]];
    }

    
    // Size of each tile.
    var tileDim = 256;
    if (image.tile_size) {
        tileDim = image.tile_size;
    }

    // Pick the level to use.
    this.Level = 0; // 0 = leaves
    while ((levelReq[3]-levelReq[2]) > this.Height && 
           this.Level < image.levels-1) {
        this.Level += 1;
        levelReq[0] *= 0.5;
        levelReq[1] *= 0.5;
        levelReq[2] *= 0.5;
        levelReq[3] *= 0.5;
    }

    // Size of each tile.
    var tileDim = 256;
    if (image.tile_size) {
        tileDim = image.tile_size;
    }

    this.ScreenPixelSpacing = (request[3]-request[2]) / this.Height;
    var imgSize = (tileDim<<this.Level) / this.ScreenPixelSpacing;


    // grid of tiles to render.
    this.GridReq = [Math.floor(levelReq[0]/tileDim),
                    Math.floor(levelReq[1]/tileDim),
                    Math.floor(levelReq[2]/tileDim),
                    Math.floor(levelReq[3]/tileDim)];

    // Compute the origin: the upper left corner of the upper left image.
    this.ScreenPixelOrigin = [this.GridReq[0]*(tileDim<<this.Level),
                              this.GridReq[2]*(tileDim<<this.Level)];

    // loop over the tiles.
    for (var y = this.GridReq[2]; y <= this.GridReq[3]; ++y) {
        for (var x = this.GridReq[0]; x <= this.GridReq[1]; ++x) {
            // Compute the tile name.
            var tx = x, ty = y, tl = this.Level;
            var tileName = "";
            while (tl < image.levels-1) {
                if ((tx&1) == 0 && (ty&1) == 0) {tileName = "q" + tileName;}
                if ((tx&1) == 1 && (ty&1) == 0) {tileName = "r" + tileName;}
                if ((tx&1) == 0 && (ty&1) == 1) {tileName = "t" + tileName;}
                if ((tx&1) == 1 && (ty&1) == 1) {tileName = "s" + tileName;}
                tx = (tx>>1);
                ty = (ty>>1);
                ++tl;
            }
            var left = (((x<<this.Level)*tileDim)-request[0])/this.ScreenPixelSpacing;
            var top  = (((y<<this.Level)*tileDim)-request[2])/this.ScreenPixelSpacing;
            var img  = $('<img>')
                .appendTo(this.Div)
                .attr("width", imgSize)
                .attr("height", imgSize)
                .attr("src", "/tile?img="+image.img+"&db="+image.db+"&name=t"+tileName+".jpg")
                .attr("alt", image.label)
                .css({"left": left.toString()+"px",
                      "top":  top.toString()+"px"})
                .addClass("sa-view-cutout-thumb-tile");
        }
    }
}

CutoutThumb.prototype.AppendTo = function(parent) {
    this.Div.appendTo(parent);
    return this;
}

// Call back argument is this thumb object.
// slideX, and slideY are set to mouse in slide coordinates.
CutoutThumb.prototype.Click = function(callback) {
    var self = this;
    this.ClickCallback = callback;
    this.Div.click(function (e) {
        // It is a real pain to get the mouse position rlative to the div.
        var x = e.pageX;
        var y = e.pageY;
        // Now get the location of this thumb on the screen.
        var offset = self.Div.offset();
        x -= offset.left;
        y -= offset.top;
        console.log("click: " + x + ", " + y);

        self.SlideX = (x * self.ScreenPixelSpacing) 
            + self.ScreenPixelOrigin[0];
        self.SlideY = (y * self.ScreenPixelSpacing) 
            + self.ScreenPixelOrigin[1];
        (self.ClickCallback)(self);
    });

    return this;
}









// todo: 
// - Bind delete key to stack creator.
// - debug why some slides are not working.
// - Get the average color of sections and get rid of outliers. 
//     (Maybe after delete)?
// - First pass rigid aligment in stack creator.
// - save the contour with the stack sections.
// - move the transformations to load with the sections.
// - Toggle slide / section view in stack viewer.
// - Implement a way to reorder the sections.
// - Implement a way to add a section in the slide stack viewer.
// - Implement multiple pieces in a single section.
// - Improve the gradient descent to be less sensitive to outliers
//     (mismatched contours.)
// For automatic segmentation.  I need the tissue volume for crystal percentage.
// It is too dificult to segment manually.
// This class will grab data from the canvas and perform seeded marching sqaures.
// My plan: Start from a seed point. Move right until I find the contour (cross the threshold).
//    Start propagating marching squares until the loop closes.




function GetDataValue(d, x, y, threshold, insideOut) {
    if (x < 0 || x >= d.width ||
        y < 0 || y >= d.height) {
        return 0;
    }
    var idx = 4*(x + y*d.width);
    if (insideOut) {
        return threshold - (d.data[idx]+d.data[idx+1]+d.data[idx+2]);
    }
    return (d.data[idx]+d.data[idx+1]+d.data[idx+2]) - threshold;
}



// (x0,y0) is the seed value inside the object being contoured.
// Returns an array of coordinate pairs in the data coordinate system
function GenerateContourFromData(d, threshold, xSeed, ySeed) {
    var x1 = xSeed;
    var y1 = ySeed;
    if (x1 < 0 || x1 >= d.width ||
        y1 < 0 || y1 >= d.height) {
        alert("Seed outside viewport");
        return;
    }


    // 0,1,2,3 is the current square.
    // s0,s1,s2,s3 contains the scalar values being contoured.
    var s0, s1, s2, s3;
    // 0 point index.
    var x0, y0;
    // Coordinate system basis of the current square. r=right,u=up;
    var xr, yr;
    var xu, yu;
    xr = 1;
    yr = 0;
    xu = -yr;
    yu = xr;

    // Setup the scalar function so inside is positive,
    var insideOut = false;
    s1 = GetDataValue(d, x1, y1, threshold, insideOut);
    if (s1 == 0) {
        alert("Seed point on threshold.");
        return;
    }
    if (s1 < 0) {
        insideOut = true;
        s1 = -s1;
    }

    // Starting from the seed point, move the edge 0-1 to the
    // right until it crosses the contour. One iteration is guaranteed.
    while (s1 > 0) {
        x0 = x1;
        y0 = y1;
        s0 = s1;
        x1 = x0+xr;
        y1 = y0+yr;
        // GetValue handles boundaries so a contour is always found.
        s1 = GetDataValue(d, x1, y1, threshold, insideOut);
    }

    // Now start tracing the contour.
    // Initialize the loop with the countour end on edge 0-1. 
    var k = s0/(s0-s1);
    var loop = [[x0+(xr*k), y0+(yr*k)]];
    xSeed = x0;  ySeed = y0;
    while (true) {
        // Get the other corner values.
        s2 = GetDataValue(d, x0+xu, y0+yu, threshold, insideOut);
        if (s2 > 0) {
            s3 = GetDataValue(d, x1+xu, y1+yu, threshold, insideOut);
            if (s3 > 0) { // The new propoagating edge is 1-3.
                k = s1/(s1-s3);
                loop.push([x1+(xu*k), y1+(yu*k)]);
                // point 1 does not change. p0 moves to p3.
                s0 = s3;  x0 = x1+xu;  y0 = y1+yu;
                // Rotate the coordinate system.
                xr = -xu; yr = -yu;
                xu = -yr; yu = xr;
            } else { // The new propoagating edge is 2-3.
                k = s2/(s2-s3);
                loop.push([x0+xu+(xr*k), y0+yu+(yr*k)]);
                // No rotation just move "up"
                s0 = s2;  x0 += xu;  y0 += yu;
                s1 = s3;  x1 += xu;  y1 += yu;
            }
        } else { // The new propoagating edge is 0-2.
            k = s0/(s0-s2);
            loop.push([x0+(xu*k), y0+(yu*k)]);
            // point 0 does not change. P1 moves to p2.
            s1 = s2;  x1 = x0 + xu;  y1 = y0 + yu;
            // Rotate the basis.
            xr = xu; yr = yu;
            xu = -yr; yu = xr;
        }
        // Check for termination.
        // x0 annd basis has returned to its original position.
        if (x0 == xSeed && y0 == ySeed && xr == 1) {
            return loop;
        }
    }
    // Loop never exits.
}



// Lets try to find a contour that circles the seed.
function GenerateContourContainingSeed(d, threshold, xSeed, ySeed) {
    if (xSeed < 0 || xSeed >= d.width ||
        ySeed < 0 || ySeed >= d.height) {
        alert("Seed outside viewport");
        return;
    }

    // Setup the scalar function so inside is positive,
    var insideOut = false;
    var s1 = GetDataValue(d, xSeed, ySeed, threshold, insideOut);
    console.log("seed value : " + (s1+threshold));
    if (s1 == 0) {
        alert("Seed point on threshold.");
        return;
    }
    if (s1 < 0) {
        insideOut = true;
        s1 = -s1;
    }

    var x0, s0;
    var x1 = xSeed;
    // Start walking to the right until we find a contour
    // that encircles the seed point.
    while (true) {
        x0 = x1;
        x1 = x0+1;
        s0 = s1;
        // GetValue handles boundaries so a contour is always found.
        s1 = GetDataValue(d, x1, ySeed, threshold, insideOut);
        if (s0 > 0 && s1 <= 0) {
            var loop = GenerateContourFromData(d, threshold, x0, ySeed);
            // Lets just use bounds as an estimate for containment.
            var x = loop[0][0];
            var y = loop[0][1];
            var bounds = [x, x, y, y];
            for (var i = 1; i < loop.length; ++i) {
                var x = loop[i][0];
                var y = loop[i][1];
                if (bounds[0] > x) {bounds[0] = x;}
                if (bounds[1] < x) {bounds[1] = x;}
                if (bounds[2] > y) {bounds[2] = y;}
                if (bounds[3] < y) {bounds[3] = y;}
            }
            if (bounds[0] < xSeed && xSeed < bounds[1] &&
                bounds[2] < ySeed && ySeed < bounds[3]) {
                return loop;
            }
        }
    }
}



// The seed is in screen coordinates.
// TODO: Reduce the resolution. Keep the data for altering the threshold.
function GenerateContourFromViewer(viewer, threshold) {
    var xSeed = viewer.LastMouseX;
    var ySeed = viewer.LastMouseY;

    var ctx = viewer.MainView.Context2d;
    var viewport = viewer.GetViewport();
    var data = ctx.getImageData(0,0,viewport[2],viewport[3]);
    // threshold * 3 because we sum R+G+B.
    //var loop = GenerateContourFromData(data, threshold*3, xSeed, ySeed);
    var loop = GenerateContourContainingSeed(data, threshold*3, xSeed, ySeed);
    // Transform the loop points to slide coordinate system.
    var slideLoop = [];
    for (var i = 0; i < loop.length; ++i) {
        var viewPt = loop[i];
        slideLoop.push(viewer.ConvertPointViewerToWorld(viewPt[0], viewPt[1]));
    }

    // Create a polylineWidget from the loop.
    var plWidget = new PolylineWidget(viewer,false);
    plWidget.Shape.Points = slideLoop;
    plWidget.Shape.Closed = true;
    plWidget.LineWidth = 0;    
    plWidget.Shape.UpdateBuffers();
    eventuallyRender();
}








    
    
// Histogram section alignment. 

//=================================================
// contour collection stuff.

function PermuteBounds(bds, axis, direction) {
    if (direction < 0) {
        axis = axis << 1;
        var tmp = bds[axis];
        bds[axis] = -bds[axis+1];
        bds[axis+1] = -tmp;
    }
}

// Heuristic to sort contours and remove outliers.
// Area of adjacent sections must be withing 20% of each other.
// The first section is passed in. THe second section is
// the closest viable section to the first.
// The major direction 1->2 determines the direction to search
// for subsequent sections (lines).  THe relative position of the
// first section on the second axis determines which direction to
// look for the next line on the second axis.
function SortAndFilterContours(contours, firstContour) {
    // pick the second contour as the closest 
    // to the first with similar areas.
    var firstCenter = firstContour.GetCenter();
    var closestDist2;
    var secondContour = false;
    // for picking a corner.
    var bds = [firstCenter[0],firstCenter[0], firstCenter[1],firstCenter[1]];
    for (var i = 0; i < contours.length; ++i) {
        if (contours[i] != firstContour) {
            match = contours[i].GetArea() / firstContour.GetArea();
            if (match < 1.2 && match > 0.8) {
                var c = contours[i].GetCenter();
                if (c[0] < bds[0]) { bds[0] = c[0]; }
                if (c[0] > bds[1]) { bds[1] = c[0]; }
                if (c[1] < bds[2]) { bds[2] = c[1]; }
                if (c[1] > bds[3]) { bds[3] = c[1]; }
                c[0] -= firstCenter[0];
                c[1] -= firstCenter[1];
                var dist2 = c[0]*c[0] + c[1]*c[1];
                if (! secondContour || dist2 < closestDist2) {
                    closestDist2 = dist2;
                    secondContour = contours[i];
                }
            }
        }
    }
    // Pick the primary axis and direction (order of sections).
    var v = secondContour.GetCenter();
    v[0] -= firstCenter[0];
    v[1] -= firstCenter[1];
    var axis0 = 1;
    if (Math.abs(v[0]) > Math.abs(v[1])) { axis0 = 0; }
    var direction0 = Math.sign(v[axis0]);
    // Pick the secondary axis and direction.
    var axis1 = axis0 ? 0 : 1;
    var direction1 = Math.sign(bds[2*axis1]+bds[2*axis1+1]
                               - 2*firstCenter[axis1]);

    // Sort the contours.
    // Remove the two contours we have found already
    contours.splice(contours.indexOf(firstContour),1);
    contours.splice(contours.indexOf(secondContour),1);
    var sortedContours = [firstContour, secondContour];
    var last = secondContour;
    var lastBds = last.GetBounds();
    // Handling directions is a pain.
    PermuteBounds(lastBds, axis0, direction0);
    PermuteBounds(lastBds, axis1, direction1);
    var bestBds = false;
    while (true) {
        var bestIdx = -1;
        for (var i = 0; i < contours.length; ++i) {
            var bds = contours[i].GetBounds();
            PermuteBounds(bds, axis0, direction0);
            PermuteBounds(bds, axis1, direction1);
            if ((bds[(axis1<<1)+1] > lastBds[axis1<<1]) &&
                ((bds[axis1<<1] > lastBds[(axis1<<1)+1] ||
                  bds[axis0<<1] > lastBds[(axis0<<1)+1]))) {
                // Contour is in the correct position relative to the last.
                var k = contours[i].GetArea() / last.GetArea();
                if (k > 0.9 && k < 1.1) {
                    // Area is good
                    // find the closest
                    if (bestIdx < 0) {
                        bestIdx = i;
                        bestBds = bds;
                    } else if (bds[(axis1<<1+1)] < bestBds[(axis1<<1)]) {
                        // Axis 1 <
                        bestIdx = i;
                        bestBds = bds;
                    } else if (bds[(axis1<<1)] < bestBds[(axis1<<1)+1] &&
                               bds[(axis0<<1)+1] < bestBds[(axis0<<1)]) {
                        // Axis 1 =, and Axis0 <
                        bestIdx = i;
                        bestBds = bds;
                    }
                }
            }
        }
        if (bestIdx == -1) {
            return sortedContours;
        }
        console.log(bestIdx);
        last = contours.splice(bestIdx,1)[0];
        sortedContours.push(last);
        lastBds = bestBds;
    }
}


// Use the bounds to create an ordering of sections.
// Direction or ordering is defined by axis0 and axis1 in {"+x","+y","-x","-y"}
// axis0 is less siginficat axis, axis1 is the more significant axis.
function SortContours(contours, axis0, axis1) {
    // Decode the axes strings.
    var direction0 = axis0[0] == "-" ? -1 : 1;
    var direction1 = axis1[0] == "-" ? -1 : 1;
    var axis0 = axis0[1] == "x" ? 0 : 1;
    var axis1 = axis1[1] == "x" ? 0 : 1;

    // Copy the array so we can modify the original.
    var copy = contours.slice(0);

    // Sort the contours
    function lessThanContours(c1,c2) {
        var bds1 = c1.GetBounds();
        PermuteBounds(bds1, axis0, direction0);
        PermuteBounds(bds1, axis1, direction1);
        var bds2 = c2.GetBounds();
        PermuteBounds(bds2, axis0, direction0);
        PermuteBounds(bds2, axis1, direction1);
        if ((bds2[(axis1<<1)+1] > bds1[axis1<<1]) &&
            ((bds2[axis1<<1] > bds1[(axis1<<1)+1] ||
              bds2[axis0<<1] > bds1[(axis0<<1)+1]))) {
            return true;
        }
        return false;
    }
    var idx = 0;
    while (copy.length > 0) {
        var bestContour = null;
        var bestIdx = -1;
        for (i = 0; i < copy.length; ++i) {
            if (bestIdx < 0 || lessThanContours(copy[i],bestContour)) {
                bestIdx = i;
                bestContour = copy[i];
            }
        }
        contours[idx++] = bestContour;
        copy.splice(bestIdx,1);
    }
}

//=================================================
// Time to create a contour object.
function Contour () {
    this.Points = [];
    this.World = false;
    this.Bounds = undefined;
    this.Area = undefined;
    // If the contour is in screen coordinates, this camera
    // can be used convert to world.
    this.Camera = undefined;
}

Contour.prototype.DeepCopy = function (contourIn) {
    // We cannot use slice because the items (coordinate pairs)
    // are arrays that need to be copied.
    this.Points = new Array(contourIn.Points.length);
    for (var i = 0; i < contourIn.Points.length; ++i) {
        this.Points[i] = contourIn.Points[i].slice(0);
    }
    this.World = contourIn.World;
    if (contourIn.Camera) {
        this.Camera = new Camera();
        this.Camera.DeepCopy(contourIn.Camera);
    }

    delete this.Bounds;
    delete this.Area;
}

Contour.prototype.SetPoints = function (points) {
    this.Points = points.slice(0);
    delete this.Bounds;
    delete this.Area;
}

Contour.prototype.Length = function () {
    return this.Points.length;
}

Contour.prototype.GetDistanceSquared = function (x,y) {
    /* distance to center.
    var c = this.GetCenter();
    x = x-c[0];
    y = y-c[1];
    return x*x + y*y;
    */

    // distance to closest point.
    if (this.Points.length == 0) {
        return 0.0;
    }
    var bestPt = this.Points[0];
    var dx = bestPt[0]-x, dy = bestPt[1]-y;
    var bestDist = dx*dx + dy*dy;
    for (var i = 1; i < this.Points.length; ++i) {
        var pt = this.Points[i];
        dx = pt[0]-x;
        dy = pt[1]-y;
        var dist = dx*dx + dy*dy;
        if (dist < bestDist) {
            bestDist = dist;
            bestPt = pt;
        }
    }
    return bestDist;
}

Contour.prototype.GetPoint = function (idx) {
    return this.Points[idx];
}

Contour.prototype.SetPoint = function (idx, pt) {
    this.Points[idx] = [pt[0], pt[1]];
    delete this.Bounds;
    delete this.Area;
}

Contour.prototype.GetBounds = function () {
    if (this.Length() == 0) {
        return this.Bounds;
    }
    if ( ! this.Bounds) {
        var xMin = this.Points[0][0];
        var xMax = xMin;
        var yMin = this.Points[0][1];
        var yMax = yMin;
        for (var i = 1; i < this.Points.length; ++i) {
            var pt = this.Points[i];
            if (pt[0] < xMin) xMin = pt[0];
            if (pt[0] > xMax) xMax = pt[0];
            if (pt[1] < yMin) yMin = pt[1];
            if (pt[1] > yMax) yMax = pt[1];
        }
        this.Bounds = [xMin,xMax, yMin,yMax];
    }
    return this.Bounds.slice(0);
}

Contour.prototype.GetCenter = function(contour) {
    var bds = this.GetBounds();
    return [(bds[0]+bds[1])/2, (bds[2]+bds[3])/2];
}

// returns + or - area depending on order of points.
Contour.prototype.GetArea = function() {
    if (this.Area) {
        return this.Area;
    }
    if (this.Points.length < 3) {
        this.Area = 0;
        return 0;
    }

    // compute the center of mass.
    var cx = 0;
    var cy = 0;
    for (var i = 0; i < this.Points.length; ++i) {
        cx += this.Points[i][0];
        cy += this.Points[i][1];
    }
    cx = cx / this.Points.length;
    cy = cy / this.Points.length;

    var area = 0;
    var p0 = this.Points[this.Points.length-1];
    var dx0 = p0[0] - cx;
    var dy0 = p0[1] - cy;
    for (var i = 0; i < this.Points.length; ++i) {
        var p1 = this.Points[i];
        var dx1 = p1[0] - cx;
        var dy1 = p1[1] - cy;
        area += dx0*dy1-dy0*dx1;
        dx0 = dx1;
        dy0 = dy1;
    }

    this.Area = area/2;
    return this.Area;
}


Contour.prototype. Transform = function (shift, center, roll) {
    delete this.Bounds;
    delete this.Area;
    for (var i = 0; i < this.Points.length; ++i) {
        var x = this.Points[i][0];
        var y = this.Points[i][1];
        var vx = x-center[0];
        var vy = y-center[1];
        var s = Math.sin(roll);
        var c = Math.cos(roll);
        var rx =  c*vx + s*vy;
        var ry = -s*vx + c*vy;
        this.Points[i][0] = x + (rx-vx) + shift[0];
        this.Points[i][1] = y + (ry-vy) + shift[1];
    }
}

// shift is [x,y]
Contour.prototype.Translate = function (shift) {
    delete this.Bounds;
    delete this.Area;
    for (var i = 0; i < this.Points.length; ++i) {
        this.Points[i][0] += shift[0];
        this.Points[i][1] += shift[1];
    }
}

// I could also impliment a resample to get uniform spacing.
Contour.prototype.RemoveDuplicatePoints = function (epsilon) {
    if ( epsilon == undefined) {
        epsilon = 0;
    }
    var p0 = this.Points[this.Points.length-1];
    var idx = 0;
    while (idx < this.Points.length) {
        var p1 = this.Points[idx];
        var dx = p1[0] - p0[0];
        var dy = p1[1] - p0[1];
        if (Math.sqrt(dx*dx + dy*dy) <= epsilon) {
            this.Points.splice(idx,1);
        } else {
            ++idx;
            p0 = p1;
        }
    }
}

// I could also impliment a resample to get uniform spacing.
// Assume closed loop
Contour.prototype.Resample = function (spacing) {
    var newPoints = [];
    var p0 = this.Points[this.Points.length-1];
    var idx = 1;
    var d = 0;
    while (idx < this.Points.length) {
        var p1 = this.Points[idx];
        var dx = p1[0] - p0[0];
        var dy = p1[1] - p0[1];
        var dist = Math.sqrt(dx*dx + dy*dy);
        d = d - dist;
        while (d < 0) {
            var x = p1[0] + dx*d/dist
            var y = p1[1] + dy*d/dist
            newPoints.push([x,y]);
            d = d + spacing;
        }
        idx = idx + 1;
        p0 = p1;
    }
    this.Points = newPoints;
}

// Should eventually share this with polyline.
// The real problem is aliasing.  Line is jagged with high frequency sampling artifacts.
// Pass in the spacing as a hint to get rid of aliasing.
Contour.prototype.Decimate = function (spacing) {
    // Keep looping over the line removing points until the line does not change.
    var modified = true;
    while (modified) {
        modified = false;
        var newPoints = [];
        newPoints.push(this.Points[0]);
        // Window of four points.
        var i = 3;
        while (i < this.Points.length) {
            var p0 = this.Points[i];
            var p1 = this.Points[i-1];
            var p2 = this.Points[i-2];
            var p3 = this.Points[i-3];
            // Compute the average of the center two.
            var cx = (p1[0] + p2[0]) * 0.5;
            var cy = (p1[1] + p2[1]) * 0.5;
            // Find the perendicular normal.
            var nx = (p0[1] - p3[1]);
            var ny = -(p0[0] - p3[0]);
            var mag = Math.sqrt(nx*nx + ny*ny);
            nx = nx / mag;
            ny = ny / mag;
            mag = Math.abs(nx*(cx-this.Points[i-3][0]) + ny*(cy-this.Points[i-3][1]));
            // Mag metric does not distinguish between line and a stroke that double backs on itself.
            // Make sure the two point being merged are between the outer points 0 and 3.
            var dir1 = (p0[0]-p1[0])*(p3[0]-p1[0]) + (p0[1]-p1[1])*(p3[1]-p1[1]);
            var dir2 = (p0[0]-p2[0])*(p3[0]-p2[0]) + (p0[1]-p2[1])*(p3[1]-p2[1]);
            if (mag < spacing && dir1 < 0.0 && dir2 < 0.0) {
                // Replace the two points with their average.
                newPoints.push([cx, cy]);
                modified = true;
                // Skip the next point the window will have one old merged point,
                // but that is ok because it is just used as reference and not altered.
                i += 2;
            } else {
                //  No modification.  Just move the window one.
                newPoints.push(this.Points[i-2]);
                ++i;
            }
        }
        // Copy the remaing point / 2 points
        i = i-2;
        while (i < this.Points.length) {
            newPoints.push(this.Points[i]);
            ++i;
        }
        this.Points = newPoints;
    }
}



// change coordiantes to world
Contour.prototype.TransformToWorld = function() {
    if ( this.World ) {
        return;
    }
    delete this.Bounds;
    delete this.Area;
    // Make an annotation out of the points.
    // Transform the loop points to slide coordinate system.
    for (var i = 0; i < this.Points.length; ++i) {
        var viewPt = this.Points[i];
        this.Points[i] = this.Camera.ConvertPointViewerToWorld(viewPt[0],
                                                               viewPt[1]);
    }
    this.World = true;
}

// change coordiantes to viewer
Contour.prototype.WorldToViewer = function() {
    if ( ! this.World ) {
        return;
    }
    delete this.Bounds;
    delete this.Area;

    for (var i = 0; i < this.Points.length; ++i) {
        var viewPt = this.Points[i];
        this.Points[i] = this.Camera.ConvertPointWorldToViewer(viewPt[0],
                                                               viewPt[1]);
    }
    this.World = false;
}

// Take a list of image points and make a viewer annotation out of them.
Contour.prototype.MakePolyline = function(rgb, view) {
    // Make an annotation out of the points.
    // Transform the loop points to slide coordinate system.
    var slidePoints = [];
    for (var i = 0; i < this.Points.length; ++i) {
        var viewPt = this.Points[i];
        if (  ! this.World && this.Camera) {
            slidePoints.push(
                this.Camera.ConvertPointViewerToWorld(viewPt[0], viewPt[1]));
        } else {
            slidePoints.push([viewPt[0], viewPt[1]]);
        }
    }

    // Create a polylineWidget from the loop.
    var pl = new SAM.Polyline();
    pl.OutlineColor = rgb;

    pl.Points = slidePoints;
    pl.Closed = true;
    pl.LineWidth = 0;
    pl.UpdateBuffers();
    pl.FixedSize = false;

    // We do not need to do this here.
    // This is sort of legacy
    if (view) {
        view.AddShape(pl);
    }

    return pl;
}

// Take a list of image points and make a viewer annotation out of them.
Contour.prototype.MakeStackSectionWidget = function() {
    // Make an annotation out of the points.
    // Create a widget.
    var w = new SAM.StackSectionWidget();
    w.Shapes.push(this.MakePolyline([0,1,0]));
    // Probably still in pixel coordinates.
    //w.Bounds = this.GetBounds();

    return w;
}


//=================================================
// Stuff for segmentation.
// Start with pixel classification by RGB

// TODO: 
// -: mouse drag
// -: Create a GUI panel with options.
//    Toggle mask option.
//    Widget events
// -: Connectivity



function Segmentation (viewer) {
    var viewport = viewer.GetViewport();
    var x = viewport[0];
    var y = viewport[1];
    var width = viewport[2];
    var height = viewport[3];
    var context  = viewer.MainView.Context2d;
    this.Viewer = viewer;
    this.Context = context;
    this.Data = GetImageData(viewer.MainView);
    // Lets add a center surround channel by over writing alpha.
    var tmp = GetImageData(viewer.MainView);
    // Smooth for the center.
    SmoothDataAlphaRGB(tmp,1);
    // Save the results.
    var idx = 0;
    while (idx < tmp.data.length) {
        var intensity = (tmp.data[idx++] + tmp.data[idx++] + tmp.data[idx++]) / 3;
        this.Data.data[idx++] = Math.round(intensity);
    }
    // Smooth for the larger surround.
    SmoothDataAlphaRGB(tmp,4);
    var idx = 0;
    var min = 128, max = 128;
    while (idx < tmp.data.length) {
        var intensity = (tmp.data[idx++] + tmp.data[idx++] + tmp.data[idx++]) / 3;
        intensity = 2*(this.Data.data[idx] - intensity)+128;
        min = Math.min(min, intensity);
        max = Math.max(max, intensity);
        intensity = Math.min(intensity, 255);
        intensity = Math.max(intensity, 0);
        this.Data.data[idx++] = Math.round(intensity);
    }
    console.log("center surround range " + min + ", " + max);
    // Now the alpha channel should contain center surround values
    delete tmp;

    // I am using a hidden canvas to convert imageData to an image.
    // there must be a better way of doing this.
    this.Canvas = document.createElement("canvas"); //create
    this.CanvasContext = this.Canvas.getContext("2d");
    this.Canvas.width = width;
    this.Canvas.height = height;

    this.Mask = this.CanvasContext.createImageData(width,height);
    for (var i = 0; i < this.Mask.data.length; ++i) {
        // transparent black RGBA
        this.Mask.data[i] = this.Data.data[i];
    }

    this.ImageAnnotation = new SAM.ImageAnnotation();
    this.ImageAnnotation.Image = document.createElement('img');
    this.ImageAnnotation.Image.src = this.Canvas.toDataURL('image/png');
    var cam = viewer.GetCamera();
    var width = cam.GetWidth();
    this.ImageAnnotation.Origin = [cam.FocalPoint[0]-width/2, cam.FocalPoint[1]-cam.Height/2];
    this.ImageAnnotation.Height = cam.Height;
    viewer.AddShape(this.ImageAnnotation);

    this.PositiveSpheres = [];
    // Negatives Not convinced we need negative sphers.
    this.NegativePoints = [];
    // We need to save the parameters necessary to convert
    // slide points to the mask coordinate systemse
    this.MaskViewport = viewport.slice(0);
    this.MaskMatrix = mat4.create(viewer.MainView.Camera.Matrix);
}

// We need to save the parameters necessary to convert
// slide points to the mask coordinate systemse
Segmentation.prototype.WorldPointToMask = function (pt) {
    var viewport = this.MaskViewport;
    var m = this.MaskMatrix;

    // Convert from world coordinate to view (-1->1);
    var h = (pt[0]*m[3] + pt[1]*m[7] + m[15]);
    var xNew = (pt[0]*m[0] + pt[1]*m[4] + m[12]) / h;
    var yNew = (pt[0]*m[1] + pt[1]*m[5] + m[13]) / h;
    // Convert from view to screen pixel coordinates.
    xNew = (1.0+xNew)*0.5*viewport[2];
    yNew = (1.0-yNew)*0.5*viewport[3];

    return [xNew, yNew];
}

Segmentation.prototype.Draw = function () {
    this.CanvasContext.putImageData(this.Mask, 0, 0);
    this.ImageAnnotation.Image.src = this.Canvas.toDataURL('image/png');
    eventuallyRender();
}

// TODO: Saves spheres instead of positive points.
Segmentation.prototype.AddPositive = function (ptWorld) {
    var ptMask = this.WorldPointToMask(ptWorld);
    ptMask[0] = Math.round(ptMask[0]);
    ptMask[1] = Math.round(ptMask[1]);

    if (ptMask[0] >= 0 && ptMask[0] < this.Data.width &&
        ptMask[1] >= 0 && ptMask[1] < this.Data.height) {
        var posPixel = this.GetPixel(ptMask);
        if (this.Evaluate(posPixel)) {
            // Already in the map; do nothing.
            return;
        }
        // Create a new sphere.
        var sphere = {center:posPixel, r2:4000};
        // Shrink the radius if it contains a negative.
        for (var i = 0; i < this.NegativePoints; ++i) {
            var negPixel = this.NegativePoints[i];
            var d2 = 0, d;
            for (var j = 0; j < posPixel.length; ++j) {
                d = negPixel[j] - posPixel[j];
                d2 += d*d;
                // Make the efective radius of the negative samples 1
                d2 = d2 - 2*Math.sqrt(d2) + 1;
            }
            if (d2 < sphere.r2) {
                sphere.r2 = d2;
            }
        }

        if (sphere.r2 > 1) {
            this.PositiveSpheres.push(sphere);
            // Everytime?
            //this.Update();
            //this.Draw();
        }
    }
}

Segmentation.prototype.AddNegative = function (ptWorld) {
    var ptMask = this.WorldPointToMask(ptWorld);
    ptMask[0] = Math.round(ptMask[0]);
    ptMask[1] = Math.round(ptMask[1]);

    var negPixel = this.GetPixel(ptMask);

    if (ptMask[0] >= 0 && ptMask[0] < this.Data.width &&
        ptMask[1] >= 0 && ptMask[1] < this.Data.height &&
        this.Evaluate(negPixel)) {
        // Map is wrong.  Add a negative point and shrink positive spheres.
        this.NegativePoints.push(negPixel);
        for (var i = 0; i < this.PositiveSpheres.length; ++i) {
            var posSphere = this.PositiveSpheres[i];
            var d2 = 0, d;
            for (var j = 0; j < negPixel.length; ++j) {
                d = negPixel[j] - posSphere.center[j];
                d2 += d*d;
            }
            // Make the efective radius of the negative samples 1
            d2 = d2 - 2*Math.sqrt(d2) + 1;
            if (d2 < posSphere.r2) {
                // TODO get rid of sphere with negative radius.
                posSphere.r2 = d2;
            }
        }
        // Everytime?
        //this.Update();
        //this.Draw();
    }
}

Segmentation.prototype.Evaluate = function (pixel) {
    for (var i = 0; i < this.PositiveSpheres.length; ++i) {
        var sphere = this.PositiveSpheres[i];
        var d2 = 0;
        for (var j = 0; j < pixel.length; ++j) {
            var delta = pixel[j] - sphere.center[j];
            d2 += delta*delta;
        }
        if (d2 < sphere.r2) {
            return true;
        }
    }
    return false;
}

Segmentation.prototype.GetPixel = function (coords) {
    idx = (coords[0]+(coords[1]*this.Data.width)) << 2;
    return [this.Data.data[idx++], this.Data.data[idx++], this.Data.data[idx++], this.Data.data[idx], coords[0], coords[1]];
}

Segmentation.prototype.Update = function () {
    // Now apply the new function to the mask.
    var idx = 0;
    for (var y = 0; y < this.Data.height; ++y) {
        for (var x = 0; x < this.Data.width; ++x) {
            var pixel = this.GetPixel([x,y]);
            if ( this.Evaluate(pixel) ) {
                this.Mask.data[idx] = 255;
                this.Mask.data[idx+1] = 0;
                this.Mask.data[idx+2] = 0;
                this.Mask.data[idx+3] = 255;
            } else {
                //this.Mask.data[idx] = this.Data.data[idx];
                //this.Mask.data[idx+1] = this.Data.data[idx+1];
                //this.Mask.data[idx+2] = this.Data.data[idx+2];
                this.Mask.data[idx] = 0;
                this.Mask.data[idx+1] = 255;
                this.Mask.data[idx+2] = 0;
                this.Mask.data[idx+3] = 0;
            }
            idx += 4;
        }
    }
}

var SEGMENT;
function HandleMouseUp(event) {
    if (event.which == 1) {
        var ptWorld = SEGMENT.Viewer.ConvertPointViewerToWorld(event.clientX, event.clientY);
        SEGMENT.AddPositive(ptWorld);
        SEGMENT.Update();
        SEGMENT.Draw();
        console.log("Positive");
    }
    if (event.which == 3) {
        var ptWorld = SEGMENT.Viewer.ConvertPointViewerToWorld(event.clientX, event.clientY);
        SEGMENT.AddNegative(ptWorld);
        SEGMENT.Update();
        SEGMENT.Draw();
        console.log("Negative");
    }
}

function testSegment() {
    if (SEGMENT === undefined) {
        SEGMENT = new Segmentation(VIEWERS[0]);
    }
    VIEWERS[0].MainView.Canvas.mouseup(function () {HandleMouseUp(event);});
}




//=================================================
// Histogram display.

function HistogramPlot (left, top, width, height) {
    this.Symetric = false;
    this.Axis = 0;

    this.Height = height;
    this.Width = width;

    this.Div = $('<div>')
        .appendTo('body')
        .addClass("sa-view-align-histogram-div");

    this.Canvas = $('<canvas>')
        .appendTo(this.Div)
        .addClass("sa-view-align-histogram-canvas");
    this.Context = this.Canvas[0].getContext("2d");

    this.SetSize(left,top, width, height);
}



HistogramPlot.prototype.SetSize = function (left,top,width,height) {
    this.Height = height;
    this.Width = width;

    if (typeof(left) == "number") {
        left = left.toString() + 'px';
    }
    if (typeof(top) == "number") {
        top = top.toString() + 'px';
    }


    this.Div
        .css({'width' : width.toString(),
              'height': height.toString(),
              'top'   : top,
              'left'  : left});

    this.Canvas[0].width = width;
    this.Canvas[0].height = height;
}



HistogramPlot.prototype.Clear = function () {
    this.Context.clearRect(0,0,this.Width,this.Height);
}

HistogramPlot.prototype.Draw = function (hist, color, iMin, iMax) {
    if ( ! iMin) { iMin = 0; }
    if ( ! iMax) { iMax = hist.length;}

    // Find the max value.
    var hMax = 0;
    var hMin = 0;
    for (var i = iMin; i < iMax; ++i) {
        var v = hist[i];
        if (v > hMax) { hMax = v;}
        if (v < hMin) { hMin = v;}
    }

    var ctx = this.Context;

    var hScale, iScale, hOrigin, iOrigin, ip, hp;
    if (this.Axis) {
        hScale = (this.Width-2)/(hMax-hMin);
        hOrigin = -hMin*hScale + 1;
        iScale = (this.Height-2)/(iMax-iMin);
        iOrigin = -iMin*iScale + 1;
    } else {
        hScale = -(this.Height-2)/(hMax-hMin);
        hOrigin = -hMax*hScale + 1;
        iScale = (this.Width-2)/(iMax-iMin);
        iOrigin = -iMin*iScale + 1;
    }

    // draw the axis
    ctx.beginPath();
    ctx.strokeStyle = '#EEE';
    ip = (iMin*iScale) + iOrigin;
    if (this.Axis) {
        ctx.moveTo(hOrigin, ip);
    } else {
        ctx.moveTo(ip, hOrigin);
    }
    ip = (iMax*iScale) + iOrigin;
    if (this.Axis) {
        ctx.lineTo(hOrigin, ip);
    } else {
        ctx.lineTo(ip, hOrigin);
    }
    ctx.stroke();

    // Draw the plot
    ctx.beginPath();
    ctx.strokeStyle = color;
    ip = Math.floor((iMin*iScale) + iOrigin);
    hp = Math.floor((hist[0]*hScale) + hOrigin);
    if (this.Axis) {
        ctx.moveTo(hp, ip);
    } else {
        ctx.moveTo(ip, hp);
    }
    for (var i = iMin+1; i < iMax; ++i) {
        ip = Math.floor((i*iScale) + iOrigin);
        hp = Math.floor((hist[i]*hScale) + hOrigin);
        if (this.Axis) {
            ctx.lineTo(hp,ip);
        } else {
            ctx.lineTo(ip,hp);
        }
    }
    ctx.stroke();
}




//=================================================
// Triangle Mesh
// Edge {vert0:id0, vert1:id1,   tri0:id0, tri1:id1, length:len}
// It is easier to keep a reference to the edge object rather than its id.
// Triangle {vert0:id0, vert1;id1; vert2:i2d,    edge0:e0, edge1:e1, edge2:e2}


// I need full face, edge and point connectivity for mesh conditioning.
function TriangleMesh() {
    // To save memory make a single array [x,y, x,y, ...]
    this.PointCoordinates = [];
    // Point indexes all in a single array [p0,p1,p2, p0,p1,p2 ...]
    this.TrianglePointIds = [];

    // Primative objects.
    this.Points = [];
    this.Edges = [];
    this.Triangles = [];
}



// Just enough to render the points.
TriangleMesh.prototype.DeepCopy = function (mesh) {
    this.PointCoordiantes = new Array(mesh.PointCoordinates.length);
    for (var i = 0; i < mesh.PointCoordinates.length; ++i) {
        this.PointCoordinates[i] = mesh.PointCoordinates[i];
    }

    this.TrianglePointIds = new Array(mesh.TrianglePointIds.length);
    for (var i = 0; i < mesh.TrianglePointIds.length; ++i) {
        this.TrianglePointIds[i] = mesh.TrianglePointIds[i];
    }
}




// I am doing this so much I decided to make a method out of it.
TriangleMesh.prototype.GetPointCoordinates = function (ptIdx) {
    var idx = ptIdx << 1;
    return [this.PointCoordinates[idx++],this.PointCoordinates[idx]];
}


// Methods for Shape ---------------------------------------------
TriangleMesh.prototype.ConvertPointsToWorld = function (viewer) {
    var viewport = viewer.GetViewport();
    var idx = 0;
    while (idx < this.PointCoordinates.length) {
        var pt = viewer.ConvertPointViewerToWorld(this.PointCoordinates[idx],
                                                  this.PointCoordinates[idx+1]);
        this.PointCoordinates[idx++] = pt[0];
        this.PointCoordinates[idx++] = pt[1];
    }
}

TriangleMesh.prototype.Draw = function (view) {
    var context = view.Context2d;
    context.save();
    // Identity (screen coordinates).
    context.setTransform(1,0,0,1,0,0);
    // Change canvas coordinates to View (-1->1, -1->1).
    context.transform(0.5*view.Viewport[2], 0.0,
                      0.0, -0.5*view.Viewport[3],
                      0.5*view.Viewport[2],
                      0.5*view.Viewport[3]);

    // Change canvas coordinates to slide (world). (camera: slide to view).
    var h = 1.0 / view.Camera.Matrix[15];
    context.transform(view.Camera.Matrix[0]*h, view.Camera.Matrix[1]*h,
                      view.Camera.Matrix[4]*h, view.Camera.Matrix[5]*h,
                      view.Camera.Matrix[12]*h, view.Camera.Matrix[13]*h);
    context.strokeStyle = '#000';
    context.lineWidth = 10;

    var x, y;
    var ptIdx;
    var triIdx = 0;
    while ( triIdx < this.TrianglePointIds.length) {
        context.beginPath();
        ptIdx = this.TrianglePointIds[triIdx++] << 1;
        x = this.PointCoordinates[ptIdx++];
        y = this.PointCoordinates[ptIdx];
        context.moveTo(x,y);
        ptIdx = this.TrianglePointIds[triIdx++] << 1;
        context.lineTo(this.PointCoordinates[ptIdx++],this.PointCoordinates[ptIdx]);
        ptIdx = this.TrianglePointIds[triIdx++] << 1;
        context.lineTo(this.PointCoordinates[ptIdx++],this.PointCoordinates[ptIdx]);
        context.lineTo(x,y);

        context.stroke();
    }

    context.restore();
}

// End of methods for Shape ---------------------------------------






// private
// Returns the other two edges (in order) of the triangle.
TriangleMesh.prototype.OtherTriangleEdges = function (tri, edge) {
      if (tri.edge0 === edge) {
            return [tri.edge1, tri.edge2];
      } else if (tri.edge1 === edge) {
            return [tri.edge2, tri.edge0];
      } else if (tri.edge2 === edge) {
            return [tri.edge0, tri.edge1];
      }
      saDebug("Triangle does not contain the edge");
}


// private
// Returns the point id shared by two edges.
TriangleMesh.prototype.PointIdSharedByEdges = function (edge0, edge1) {
    if (edge0.vert0 == edge1.vert0) { return edge0.vert0; }
    if (edge0.vert0 == edge1.vert1) { return edge0.vert0; }
    if (edge0.vert1 == edge1.vert0) { return edge0.vert1; }
    if (edge0.vert1 == edge1.vert1) { return edge0.vert1; }
    saDebug("Edges do not share a point");
}


// private
TriangleMesh.prototype.SwapEdgeTriangle = function(edge, oldId, newId) {
    if (edge.tri0 == oldId) {
        edge.tri0 = newId;
    }
    if (edge.tri1 != undefined && edge.tri1 == oldId) {
        edge.tri1 = newId;
    }
}

TriangleMesh.prototype.ConditionEdgeRotate = function () {
    var modified = false;

    // Loop over the edges and rotate edges when it makes it shorter.
    for (var edgeId = 0; edgeId < this.Edges.length; ++edgeId) {
        // find four edges/points of the quadrilateral containing the edge.
        var edge = this.Edges[edgeId];
        if (edge === undefined || edge.tri1 == undefined) {
            // boundary edge
            continue;
        }
        var tri0 = this.Triangles[edge.tri0];
        var tri1 = this.Triangles[edge.tri1];
        // It is a pain to find the other edges.
        var quadEdges = [];
        quadEdges = quadEdges.concat(this.OtherTriangleEdges(tri0, edge));
        quadEdges = quadEdges.concat(this.OtherTriangleEdges(tri1, edge));
        // Get the four points (consistent with quad edges).
        var quadPointIds = new Array(4);
        quadPointIds[0] = this.PointIdSharedByEdges(quadEdges[3], quadEdges[0]);
        quadPointIds[1] = this.PointIdSharedByEdges(quadEdges[0], quadEdges[1]);
        quadPointIds[2] = this.PointIdSharedByEdges(quadEdges[1], quadEdges[2]);
        quadPointIds[3] = this.PointIdSharedByEdges(quadEdges[2], quadEdges[3]);
        // Now that we have the four edge and point ids,
        // Evaluate whether it is beneficial to rotate the edge.
        var idx1 = quadPointIds[1] << 1;
        var idx3 = quadPointIds[3] << 1;
        var dx = this.PointCoordinates[idx3] - this.PointCoordinates[idx1];
        var dy = this.PointCoordinates[idx3+1] - this.PointCoordinates[idx1+1];
        var dist13 = Math.sqrt((dx*dx)+(dy*dy));
        if (dist13 < edge.length) {
            // Make sure we are not inverting a triangle.
            // New triangle at p2
            var idx1 = quadPointIds[1] << 1;
            var idx2 = quadPointIds[2] << 1;
            var idx3 = quadPointIds[3] << 1;
            var dx1 = this.PointCoordinates[idx1] - this.PointCoordinates[idx2];
            var dy1 = this.PointCoordinates[idx1+1] - this.PointCoordinates[idx2+1];
            var dx3 = this.PointCoordinates[idx3] - this.PointCoordinates[idx2];
            var dy3 = this.PointCoordinates[idx3+1] - this.PointCoordinates[idx2+1];
            var c2 = dx3*dy1 - dy3*dx1;
            // New triangle at p0
            var idx0 = quadPointIds[0] << 1;
            dx1 = this.PointCoordinates[idx1] - this.PointCoordinates[idx0];
            dy1 = this.PointCoordinates[idx1+1] - this.PointCoordinates[idx0+1];
            dx3 = this.PointCoordinates[idx3] - this.PointCoordinates[idx0];
            dy3 = this.PointCoordinates[idx3+1] - this.PointCoordinates[idx0+1];
            var c0 = dx1*dy3 - dy1*dx3;
            // Handedness of quad should no longer be random.  
            // However checking for both condition should not hurt.
            if ((c0 < 0 && c2 < 0) || (c0 > 0 && c2 > 0)) {
                modified = true;
                // Rotate the edge.
                edge.vert0 = quadPointIds[1];
                edge.vert1 = quadPointIds[3];
                edge.length = dist13;

                tri0.vert0 = quadPointIds[1];
                tri0.vert1 = quadPointIds[2];
                tri0.vert2 = quadPointIds[3];
                tri0.edge0 = quadEdges[1]
                tri0.edge1 = quadEdges[2]
                tri0.edge2 = edge;

                tri1.vert0 = quadPointIds[1];
                tri1.vert1 = quadPointIds[3];
                tri1.vert2 = quadPointIds[0];
                tri1.edge0 = edge;
                tri1.edge1 = quadEdges[3];
                tri1.edge2 = quadEdges[0];

                // Boundary edges point to swapped triangle
                this.SwapEdgeTriangle(quadEdges[0], edge.tri0, edge.tri1);
                this.SwapEdgeTriangle(quadEdges[2], edge.tri1, edge.tri0);
            }
        }
    }
    return modified;
}



TriangleMesh.prototype.AddEdge = function (ptId0, ptId1, triIdx) {
    if (ptId0 > ptId1) {
        var tmp = ptId0;
        ptId0 = ptId1;
        ptId1 = tmp;
    }
    var edge = undefined;
    // Look for the edge in the hash table (created by another triangle).
    for (var i = 0; i < this.EdgeHash[ptId0].length && !edge; ++i) {
        var e2 = this.EdgeHash[ptId0][i];
        if (e2.vert1 == ptId1) {
            edge = e2;
            edge.tri1 = triIdx;
        }
    }
    if ( edge == undefined) {
        // Make a new edge.
        edge = {vert0: ptId0, vert1: ptId1, tri0: triIdx};
        // Add it into the hash.
        this.EdgeHash[ptId0].push(edge);
        // Compute its length.
        var idx0 = ptId0 << 1;
        var idx1 = ptId1 << 1;
        var dx = this.PointCoordinates[idx1] - this.PointCoordinates[idx0];
        var dy = this.PointCoordinates[idx1+1] - this.PointCoordinates[idx0+1];
        edge.length = Math.sqrt((dx*dx)+(dy*dy));
    }
    return edge;
}


// Convert from simple point cooridnate and triangle corner id arrays 
// to full mesh.
TriangleMesh.prototype.CreateFullMesh = function () {
    var numPts = this.PointCoordinates.length / 2;
    var numTri = this.TrianglePointIds.length / 3;
    this.Triangles = new Array(numTri);
    this.EdgeHash = new Array(numPts);
    for (var i = 0; i < this.EdgeHash.length; ++i) {
        this.EdgeHash[i] = [];
    }

    var idx = 0;
    var triIdx = 0;
    while (idx < this.TrianglePointIds.length) {
        var ptId0 = this.TrianglePointIds[idx++];
        var ptId1 = this.TrianglePointIds[idx++];
        var ptId2 = this.TrianglePointIds[idx++];
        var triangle = {vert0:ptId0, vert1:ptId1, vert2:ptId2};
        triangle.edge0 = this.AddEdge(ptId0, ptId1, triIdx);
        triangle.edge1 = this.AddEdge(ptId1, ptId2, triIdx);
        triangle.edge2 = this.AddEdge(ptId2, ptId0, triIdx);
        this.Triangles[triIdx] = triangle;
        ++triIdx;
    }
    // Move the edges from the hash to a list of edges.
    var numEdges = numPts + numTri - 1;
    this.Edges = new Array(numEdges);
    var edgeIdx = 0;
    for (var i = 0; i < this.EdgeHash.length; ++i) {
        for (var j = 0; j < this.EdgeHash[i].length; ++j) {
            this.Edges[edgeIdx++] = this.EdgeHash[i][j];
        }
    }
    delete this.EdgeHash;
}

// Create the triangle point id array from the mesh triangles.
// I do not know if I will keep the dual mesh representations...
TriangleMesh.prototype.Update = function () {
    var idx = 0;
    var triIdx = 0;
    for (triIdx = 0; triIdx < this.Triangles.length; ++triIdx) {
        var tri = this.Triangles[triIdx];
        this.TrianglePointIds[idx++] = tri.vert0;
        this.TrianglePointIds[idx++] = tri.vert1;
        this.TrianglePointIds[idx++] = tri.vert2;
    }
}


// For debugging
TriangleMesh.prototype.DrawInCanvas = function (ctx) {
    var triIdx = 0;
    var ptIdx;
    while (triIdx < this.TrianglePointIds.length) {
        ptIdx = this.TrianglePointIds[triIdx++] << 1;
        ctx.beginPath(this.PointCoordinates[ptIdx++], this.PointCoordinates[ptIdx]);
        ptIdx = this.TrianglePointIds[triIdx++] << 1;
        ctx.lineTo(this.PointCoordinates[ptIdx++], this.PointCoordinates[ptIdx]);
        ptIdx = this.TrianglePointIds[triIdx++] << 1;
        ctx.lineTo(this.PointCoordinates[ptIdx++], this.PointCoordinates[ptIdx]);
        ctx.stroke();
    }
}

// Clears the mesh the adds the triangulation.
// The triangulation may not be optimal.
TriangleMesh.prototype.TriangulateContour = function(contour) {
    var s,c,a;
    var num = contour.Length();
    this.PointCoordinates = new Array(num*2);
    this.TrianglePointIds = new Array();
    // Make an array that marks unused points (and keeps their angles).
    var vAngles = new Array(num);

    var x0 = contour.GetPoint(num-1)[0], y0 = contour.GetPoint(num-1)[1];
    var x1 = contour.GetPoint(0)[0], y1 = contour.GetPoint(0)[1];
    var dx0 = x1-x0, dy0 = y1-y0;
    var dist0 = Math.sqrt(dx0*dx0 + dy0*dy0);
    var x2, y2, dx1, dy1, dist1;
    for (var i = 0; i < num; ++i) {
        this.PointCoordinates[i<<1] = x1;
        this.PointCoordinates[(i<<1) + 1] = y1;
        x2 = contour.GetPoint((i+1)%num)[0];
        y2 = contour.GetPoint((i+1)%num)[1];
        // Compute length
        dx1 = x2-x1;  dy1 = y2-y1;
        dist1 = Math.sqrt(dx1*dx1 + dy1*dy1);

        // Although this is correct, atan works without it,
        // And we might have divide by zero.
        //s = (dx1*dy0-dx0*dy1) / (dist0*dist1);
        //c = (dx0*dx1+dy0*dy1) / (dist0*dist1);
        s = (dx1*dy0-dx0*dy1);
        c = (dx0*dx1+dy0*dy1);
        a = Math.atan2(s,c);
        vAngles[i] = a;

        // Move forward one vertex.
        x0 = x1;   y0 = y1;
        x1 = x2;   y1 = y2;
        dx0=dx1;   dy0=dy1;
        dist0 = dist1;
    }

    var triIdx = 0;
    var numPointsLeft = num;
    while (numPointsLeft > 2) {
        // Find the vertex with the smallest angle.
        var smallestAngle = 10.0;
        var v1 = v0-1;
        for (var i = 0; i < num; ++i) {
            if (vAngles[i] < smallestAngle) {
                smallestAngle = vAngles[i];
                v1 = i;
            }
        }

        if (smallestAngle > 0) { return;}

        // Mark the vertex as used.
        vAngles[v1] = 100.0; // Special value.
        --numPointsLeft;
        // Find the adjacent unused points.
        var v0 = v1;
        do {
            --v0;
            if (v0 < 0) {v0 = num-1;}
        } while (vAngles[v0] > 10);
        var v2 = v1;
        do {
            ++v2;
            if (v2 >= num) {v2 = 0;}
        } while (vAngles[v2] > 10);

        // Add the triangle
        this.TrianglePointIds[triIdx++] = v0;
        this.TrianglePointIds[triIdx++] = v1;
        this.TrianglePointIds[triIdx++] = v2;
        // The new edge is (v0,v2)
        v1 = v0;
        // Get the points on either side of the new edge.
        v0 = v1;
        do {
            --v0;
            if (v0 < 0) {v0 = num-1;}
        } while (vAngles[v0] > 10);
        var  v3 = v2
        do {
            ++v3;
            if (v3 >= num) {v3 = 0;}
        } while (vAngles[v3] > 10);
        // Compute new angles.
        var p0 = contour.GetPoint(v0);
        var p1 = contour.GetPoint(v1);
        var p2 = contour.GetPoint(v2);
        var p3 = contour.GetPoint(v3);
        var dx0 = p1[0]-p0[0], dy0 = p1[1]-p0[1];
        var dx1 = p2[0]-p1[0], dy1 = p2[1]-p1[1];
        var dx2 = p3[0]-p2[0], dy2 = p3[1]-p2[1];

        var dist0 = Math.sqrt(dx0*dx0 + dy0*dy0);
        var dist1 = Math.sqrt(dx1*dx1 + dy1*dy1);
        var dist2 = Math.sqrt(dx2*dx2 + dy2*dy2);

        //var s = (dx1*dy0-dx0*dy1) / (dist0*dist1);
        //var c = (dx0*dx1+dy0*dy1) / (dist0*dist1);
        var s = (dx1*dy0-dx0*dy1);
        var c = (dx0*dx1+dy0*dy1);
        vAngles[v1] = Math.atan2(s,c);
        s = (dx2*dy1-dx1*dy2) / (dist1*dist2);
        c = (dx1*dx2+dy1*dy2) / (dist1*dist2);
        vAngles[v2] = Math.atan2(s,c);
    }
}



// Edge {vert0:id0, vert1:id1,   tri0:id0, tri1:id1}
// Triangle {vert0:id0, vert1;id1; vert2:i2d,    edge0:id0, edge1:id1, edge2:id2}



//=================================================
// Circular array for fifo methods
function MapQueue(length) {
    // Points to the first full spot.
    this.StartIdx = 0;
    // Points to the next empty spot.
    this.EndIdx = 0;
    this.Allocate(length);
}

MapQueue.prototype.Push = function (item) {
    var nextEndIdx = this.EndIdx + 1;
    // If the circular buffer is full, reallocate.
    if (nextEndIdx >= this.Array.length) {
        nextEndIdx == 0;
    }
    if (this.Array[nextEndIdx] != null) {
        this.Allocate(this.Array.length * 2);
        nextEndIdx = this.EndIdx+1;
    }
    // Add the index into the buffer.
    this.Array[this.EndIdx] = item;
    this.EndIdx = nextEndIdx;
}

MapQueue.prototype.Shift = function () {
    var item = this.Array[this.StartIdx];
    if (item == null) {
        return item;
    }
    this.Array[this.StartIdx] = null;
    this.StartIdx += 1;
    if (this.StartIdx >= this.Array.length) {
        this.StartIdx == 0;
    }
    return item;
}

// Reallocate
MapQueue.prototype.Allocate = function (length) {
    if (this.Array && this.Array.length > length) { return; }
    var newArray = new Array(length);
    var i = 0;
    if (this.Array) {
        for (var j = this.StartIdx; j != this.EndIdx; ++j) {
            if (j >= this.Array.length) { j = 0; }
            newArray[i++] = this.Array[j];
        }
        this.StartIdx = 0;
        this.EndIdx = i;
        delete this.Array;
    }
    while (i++ < length) {
        newArray[i] = null;
    }
    this.Array = newArray;
}





//=================================================
// Distance map: city block distance


function DistanceMap(bounds, spacing) {
    this.Bounds = bounds; // Warning shallow copy.
    this.Spacing = spacing;
    this.Dimensions = [Math.ceil((bounds[1]-bounds[0])/spacing),
                       Math.ceil((bounds[3]-bounds[2])/spacing)];
    var size = this.Dimensions[0]*this.Dimensions[1];
    if (size > 1000000) {
        saDebug("Warning: Distance map memory requirement is large.");
    }
    this.Map = new Array(size);
    for (var i = 0; i < size; ++i) {
        this.Map[i] = size; // a convenient large distance
    }

    this.Queue = null;
}

// For debugging
DistanceMap.prototype.Draw = function (viewer) {
    var ctx = viewer.MainView.Context2d;
    var data = ctx.createImageData(this.Dimensions[0], this.Dimensions[1]);
    // find maximum
    var max = 0;
    var numPixels = this.Dimensions[0] * this.Dimensions[1];
    for (var i = 0; i < numPixels; ++i) {
        if (max < this.Map[i]) { max = this.Map[i];}
    }
    // Draw the pixels.
    var ii = 0;
    for (var i = 0; i < numPixels; ++i) {
        data.data[ii] = data.data[ii+1] = data.data[ii+2] = Math.floor(255 * this.Map[i]/max);
        data.data[ii+3] = 255;
        ii += 4;
    }

    ctx.putImageData(data,10,10);
}

// Only rasterize contour points for now.  Assume they are close together.
DistanceMap.prototype.AddContour = function (contour) {
    for (var i = 0; i < contour.Length(); ++i) {
        var x = Math.round((contour.GetPoint(i)[0]-this.Bounds[0])/this.Spacing);
        var y = Math.round((contour.GetPoint(i)[1]-this.Bounds[2])/this.Spacing);
        if (x >=0 && x < this.Dimensions[0] &&
            y >=0 && y < this.Dimensions[1]) {
            this.Map[x + (y*this.Dimensions[0])] = 0;
        }
    }
}

// Rasterize the polyline into the distance map.
// Fill it if it is closed
DistanceMap.prototype.AddPolyline = function (pline) {
    var m0, m1, m2;
    var points = pline.Points;
    if (points.length == 0) { return; }
    m0 = [(points[0][0]-this.Bounds[0]) / this.Spacing,
          (points[0][1]-this.Bounds[2]) / this.Spacing];
    m1 = m0;
    for (var i = 1; i < points.length; ++i) {
        m2 = [(points[i][0]-this.Bounds[0]) / this.Spacing,
              (points[i][1]-this.Bounds[2]) / this.Spacing];
        this.AddEdge(m1,m2);
        m1 = m2;
    }

    if (pline.Closed && points.length > 2) {
        this.AddEdge(m2,m0);
    }

    // There is a chance this could fail if there are no pixels between two
    // edges.  Maybe get the mask from the thresholded image. 
    if (pline.Closed && points.length > 2 && false) {
        // Fill leaked out on one section.  Make it more robust, or
        // use the thresholded image.

        this.AddEdge(m2,m0);

        if ( ! this.Queue) {
            this.Queue = new MapQueue(this.Dimensions[0] +
                                      this.Dimensions[1]);
        }
        // Pick a seed.
        // Average perpendiculars to the first two edges
        var vy = (points[2][0] - points[0][0]);
        var vx = (points[0][1] - points[2][1]);
        // normalize
        var k = 1 / Math.sqrt(vx*vx + vy*vy);
        vx *= k;
        vy *= k;
        var x = (points[1][0]-this.Bounds[0]) / this.Spacing;
        var y = (points[1][1]-this.Bounds[2]) / this.Spacing;
        var ix, iy;
        do {
            x += vx;
            y += vy;
            ix = Math.round(x);
            iy = Math.round(y);
            if (ix < 0 || ix >= this.Dimensions[0] ||
                iy < 0 || iy >= this.Dimensions[1]) {
                // Failed to find seed.
                return;
            }
        } while (this.Map[ix + (iy*this.Dimensions[0])] == 0);
        this.Queue.Push([ix,iy]);
        var seed, idx;
        while ( (seed = this.Queue.Shift()) != null) {
            this.AddSeedToQueue(seed[0]-1, seed[1]);
            this.AddSeedToQueue(seed[0]+1, seed[1]);
            this.AddSeedToQueue(seed[0], seed[1]-1);
            this.AddSeedToQueue(seed[0], seed[1]+1);
        }
    }
}


DistanceMap.prototype.Fill = function (ix,iy) {
    if ( ! this.Queue) {
        this.Queue = new MapQueue(this.Dimensions[0] +
                                  this.Dimensions[1]);
    }
    this.Queue.Push([ix,iy]);
    var xMax = this.Dimensions[0]-1;
    var yMax = this.Dimensions[1]-1;
    var seed, idx;
    while ( (seed = this.Queue.Shift()) != null) {
        if (seed[0] > 0) { this.AddSeedToQueue(seed[0]-1, seed[1])};
        if (seed[0] < xMax) { this.AddSeedToQueue(seed[0]+1, seed[1])};
        if (seed[1] > 0) { this.AddSeedToQueue(seed[0], seed[1]-1)};
        if (seed[1] < yMax) { this.AddSeedToQueue(seed[0], seed[1]+1)};
    }
}

DistanceMap.prototype.AddSeedToQueue = function (ix,iy) {
    var idx = ix + (iy*this.Dimensions[0]);
    if (ix >= 0 && ix < this.Dimensions[0] &&
        iy >= 0 && iy < this.Dimensions[1] &&
        this.Map[idx] != 0) {
        this.Map[idx] = 0;
        this.Queue.Push([ix,iy]);
    }
}

// m0, and m1 should already be in map coordinates.
DistanceMap.prototype.AddEdge = function (m0, m1) {
    var divisions = Math.max(Math.abs(m0[0]-m1[0]), Math.abs(m0[1]-m1[1]));
    divisions = Math.ceil(divisions);
    for (var i = 0; i <= divisions; ++i) {
        var x = Math.round((m0[0]*(divisions-i)+m1[0]*i)/divisions);
        var y = Math.round((m0[1]*(divisions-i)+m1[1]*i)/divisions);
        this.Map[x + (y*this.Dimensions[0])] = 0;
    }    
}

// Rasterize points with alpha = 255
DistanceMap.prototype.AddImageData = function (data) {
    var idx = 0;
    for (var y = 0; y < data.height; ++y) {
        for (var x = 0; x < data.width; ++x) {
            if (x >=0 && x < this.Dimensions[0] &&
                y >=0 && y < this.Dimensions[1] &&
                data.data[i+3] == 255) {
                this.Map[x + (y*this.Dimensions[0])] = 0;
            }
            i += 4;
        }
    }
}

// Fill in all distance values from existing values.
DistanceMap.prototype.Update = function () {
    // I wonder if I can compute the number of passes that will be needed?
    count = 0;
    while (this.UpdatePass()) {++count;}
    //console.log("passes: " + count);
}

// Returns true if something changed.
DistanceMap.prototype.UpdatePass = function () {
    var changed = false;
    var idx;
    // Forward and backward pass over all the rows.
    for (var y = 0; y < this.Dimensions[1]; ++y) {
        idx = y*this.Dimensions[0];
        var min = this.Map[idx];
        for (var x = 1; x < this.Dimensions[0]; ++x) {
            ++idx;
            ++min;
            if (min < this.Map[idx]) {
                this.Map[idx] = min;
                changed = true;
            } else {
                min = this.Map[idx];
            }
        }
        for (var x = this.Dimensions[0]-2; x >= 0; --x) {
            --idx;
            ++min;
            if (min < this.Map[idx]) {
                this.Map[idx] = min;
                changed = true;
            } else {
                min = this.Map[idx];
            }
        }
    }

    // Forward and backward pass over all the columns.
    for (var x = 0; x < this.Dimensions[0]; ++x) {
        idx = x;
        var min = this.Map[idx];
        for (var y = 1; y < this.Dimensions[1]; ++y) {
            idx += this.Dimensions[0];
            ++min;
            if (min < this.Map[idx]) {
                this.Map[idx] = min;
                changed = true;
            } else {
                min = this.Map[idx];
            }
        }
        for (var y = this.Dimensions[1]-2; y >= 0; --y) {
            idx -= this.Dimensions[0];
            ++min;
            if (min < this.Map[idx]) {
                this.Map[idx] = min;
                changed = true;
            } else {
                min = this.Map[idx];
            }
        }
    }
    return changed;
}

// TODO:
// Change this so that it gives distance in units of world, not map.
DistanceMap.prototype.GetDistance = function (x, y) {
    var ix = Math.round((x-this.Bounds[0])/this.Spacing);
    var iy = Math.round((y-this.Bounds[2])/this.Spacing);
    if (ix >=0 && ix < this.Dimensions[0] &&
        iy >=0 && iy < this.Dimensions[1]) {
        return this.Map[ix + (iy*this.Dimensions[0])];
    } else {
        // Ramp the distance map down outside the bounds.
        var dist = 0;
        if ( ix < 0) {
            dist += -0.1*ix;
            ix = 0;
        }
        if ( ix >= this.Dimensions[0]) {
            dist += 0.1*(ix-this.Dimensions[0]+1);
            ix = this.Dimensions[0]-1;;
        }
        if ( iy < 0) {
            dist += -0.1*iy;
            iy = 0;
        }
        if ( iy >= this.Dimensions[1]) {
            dist += 0.1*(iy-this.Dimensions[1]+1);
            iy = this.Dimensions[1]-1;;
        }
        return dist + this.Map[ix + (iy*this.Dimensions[0])];
    }
}

// Central difference.
DistanceMap.prototype.GetGradient = function(x, y) {
    var ix = Math.round((x-this.Bounds[0])/this.Spacing);
    var iy = Math.round((y-this.Bounds[2])/this.Spacing);
    var dx = 0, dy=0;
    if (ix < 0 || ix >= this.Dimensions[0] ||
        iy < 0 || iy >= this.Dimensions[1]) {
        // Slow gradient toward middle.
        ix = ix - (this.Dimensions[0]*0.5);
        iy = iy - (this.Dimensions[1]*0.5);
        var dist = Math.sqrt(ix*ix + iy*iy);
        return [ix/(10*dist), iy/(10*dist)];
    }
    var idx = ix + (iy*this.Dimensions[0]);
    // x
    if (ix == 0) {
        dx = this.Map[idx+1] - this.Map[idx];
    } else if (ix == this.Dimensions[0]-1) {
        dx = this.Map[idx] - this.Map[idx-1];
    } else {
        dx = this.Map[idx+1] - this.Map[idx-1];
    }
    // y
    var incy = this.Dimensions[0];
    if (iy == 0) {
        dy = this.Map[idx+incy] - this.Map[idx];
    } else if (iy == this.Dimensions[1]-1) {
        dy = this.Map[idx] - this.Map[idx-incy];
    } else {
        dy = this.Map[idx+incy] - this.Map[idx-incy];
    }

    // Scale by spacing (Keeps gradient decent stable).
    dx = dx * this.Spacing;
    dy = dy * this.Spacing;

    return [dx, dy];
}


//=================================================
// Extend the image data returned by the canvas.

function ImageData() {
    this.IncX = 1;
    this.IncY = 1;
}

ImageData.prototype.GetIntensity = function (x,y) {
    if (! this.data) { return 0;}
    x = Math.round(x);
    y = Math.round(y);
    var idx = x*this.IncX + y*this.IncY;
    return (this.data[idx] + this.data[idx+1] + this.data[idx+2]) / 3;
}

ImageData.prototype.InBounds = function (x,y) {
    if (! this.data) { return false;}
    return (x >=0 && x < this.width && y >=0 && y < this.height);
}


// Add a couple methods to the object.
// change this to take a view instead of a viewer.
function GetImageData(view) {
    // interesting: When does it need to be set?
    //ctx.imageSmoothingEnabled = true; 
    // useful for debugging
    //ctx.putImageData(imagedata, dx, dy);
    var cam = view.Camera;
    var width = Math.floor(cam.ViewportWidth);
    var height = Math.floor(cam.ViewportHeight);
    var ctx  = view.Context2d;
    var data = ctx.getImageData(0,0,width,height);
    data.Camera = new Camera();
    data.Camera.DeepCopy(view.Camera);
    data.__proto__ = new ImageData();
    data.IncX = 4;
    data.width = width;
    data.height = height;
    data.IncY = data.IncX * data.width;
    return data;
}



// Mark edges visited so we do not create the same contour twice.
// I cannot mark the pixel cell because two contours can go through the same cell.
// Note:  I have to keep track of both the edge and the direction the contour leaves
// the edge.  The backward direction was to being contoured because the starting
// edge was already marked.  The order of the points here matters.  Each point
// marks 4 edges.
ImageData.prototype.MarkEdge = function (x0,y0, x1,y1) {
    if ( ! this.EdgeMarks) {
        var numTemplates = Math.round((this.width)*(this.height));
        this.EdgeMarks = new Array(numTemplates);
        for (var i = 0; i < numTemplates; ++i) {
            this.EdgeMarks[i] = 0;
        }
    }

    var edge = 0;
    if (x0 != x1) {
        edge = (x0 < x1) ? 1 : 4;
    } else if (y0 != y1) {
        edge = (y0 < y1) ? 2 : 8;
    }

    var idx = x0  + y0*(this.width);
    var mask = this.EdgeMarks[idx];
    if (mask & edge) {
        return true;
    }
    this.EdgeMarks[idx] = mask | edge;
    return false;
}



//--------------------------------
// iso contouring from canvas data

// Helper method.
// Trace contour one direction until it ends or circles back.
// Return a list of points.
// There is some extra complexity to trace both directions...
// (both in and out marking of edges).
function TraceIsoContourDirection(data, x0,y0, x1,y1, threshold, direction) {
    var s0 = (data.GetIntensity(x0, y0) - threshold) * direction;
    var s1 = (data.GetIntensity(x1, y1) - threshold) * direction;
    if ((s0 > 0 && s1 > 0) || (s0 <= 0 && s1 <= 0)) {
        // No contour crosses this edge.
        return false;
    }

    // I am looking to distinguish light versus dark objects.
    // Always trace contours right handed.
    if ( s0 > 0 ) {
        // swap 0 and 1
        var tmp = x1;
        x1 = x0;
        x0 = tmp;
        tmp = y1;
        y1 = y0;
        y0 = tmp;
        tmp = s1;
        s1 = s0;
        s0 = tmp;
    }

    // Leaving the edge (-,+)
    if (data.MarkEdge(x0,y0, x1,y1)) {
        return false;
    }

    // 0,1,2,3 is the current square.
    // s0,s1,s2,s3 contains the scalar values being contoured.
    var x2, y2, s2, x3, y3, s3;
    // Coordinate system basis of the current square. r=right,u=up;
    var xr, yr;
    var xu, yu;
    xr = x1-x0;
    yr = y1-y0;
    xu = -yr;
    yu = xr;

    // Now start tracing the contour.
    // Initialize the line with the countour end on edge 0-1.
    var k = s0/(s0-s1);
    // Polyline was about half a pixel off.
    var polyLine = [[x0+(xr*k)+0.5, y0+(yr*k)+0.5]];
    xStart = x0;  yStart = y0;
    xrStart = xr; yrStart = yr;
    while (true) {
        x2 = x0+xu;
        y2 = y0+yu;
        // Check for boundary termination.
        if (!data.InBounds(x2,y2)) { return polyLine;}
        x3 = x1+xu;
        y3 = y1+yu;
        // No need to check if the second point is in bounds.
        //if (!data.InBounds(x3,y3)) { return polyLine;}
        // Get the other corner values.
        s2 = (data.GetIntensity(x2, y2) - threshold) * direction;
        if (! (s2 > 0)) { 
            s3 = (data.GetIntensity(x3, y3) - threshold) * direction;
            if ( ! (s3 > 0)) {
                // Entering the edge (+,-)
                if (data.MarkEdge(x1,y1, x3,y3)) {
                    // We need to check both edge directions (in and out)
                    // Note the reverse order of the points
                    return polyLine;
                }
                // The new propoagating edge is 1-3.
                k = s1/(s1-s3);
                // Polyline was about half a pixel off.
                polyLine.push([x1+(xu*k)+0.5, y1+(yu*k)+0.5]);
                // point 1 does not change. p0 moves to p3.
                s0=s3;  x0=x3;  y0=y3;
                // Rotate the coordinate system.
                xr = -xu; yr = -yu;
                xu = -yr; yu = xr;
            } else { // The new propoagating edge is 2-3.
                // Entering the edge (+,-)
                if (data.MarkEdge(x3,y3, x2,y2)) {
                    // We need to check both edge directions
                    // Note the reverse order of the points
                    return polyLine;
                }
                k = s2/(s2-s3);
                // Polyline was about half a pixel off.
                polyLine.push([x0+xu+(xr*k)+0.5, y0+yu+(yr*k)+0.5]);
                // No rotation just move "up"
                s0=s2;  x0=x2;  y0=y2;
                s1=s3;  x1=x3;  y1=y3;
            }
        } else { // The new propoagating edge is 0-2.
            // Entering the edge (+,-)
            if (data.MarkEdge(x2,y2, x0,y0)) {
                // We need to check both edge directions
                // Note the reverse order of the points
                return polyLine;
            }
            k = s0/(s0-s2);
            // Polyline was about half a pixel off.
            polyLine.push([x0+(xu*k)+0.5, y0+(yu*k)+0.5]);
            // point 0 does not change. P1 moves to p2.
            s1=s2;  x1=x2;  y1=y2;
            // Rotate the basis.
            xr = xu; yr = yu;
            xu = -yr; yu = xr;
        }
        // Leaving the edge (-,+)
        if (data.MarkEdge(x0,y0, x1,y1)) {
            return polyLine;
        }
        // Edge marking detects the end of the loop.
    }
    // while(true) neve exits.
}


// Find the entire (both directions) that crosses an edge.
function SeedIsoContour(data, x0,y0, x1,y1, threshold) {
    this.Bounds = [0,-1,0,-1];
    var polyLineRight = TraceIsoContourDirection(data, x0,y0, x1,y1, threshold,1);
    if ( ! polyLineRight) {
        // No contour through this edge.
        return false;
    }
    var polyLineLeft = TraceIsoContourDirection(data, x1,y1, x0,y0, threshold,-1);
    if ( ! polyLineLeft || polyLineLeft.length < 2) {
        // Must have been a boundary edge.
        return polyLineRight;
    }
    // reverse and append the lines.
    polyLineLeft.reverse();
    polyLineLeft.pop();

    var points = polyLineLeft.concat(polyLineRight);
    return points;
}



function LongestContour(data, threshold) {
    // Loop over the cells.
    var contour;
    var area;
    var bestContour;
    var bestArea = 0;
    for (var y = 1; y < data.height; ++y) {
        for (var x = 1; x < data.width; ++x) {
            // Look for contours crossing the xMax and yMax edges.
            var xContour = SeedIsoContour(data, x,y, x-1,y, threshold);
            if (xContour) {
                contour = new Contour();
                contour.Camera = data.Camera;
                contour.SetPoints(xContour);
                area = Math.abs(contour.GetArea());
                if (area > bestArea) {
                    bestArea = area;
                    bestContour = contour;
                }
            }
            var yContour = SeedIsoContour(data, x,y, x,y-1, threshold);
            if (yContour) {
                contour = new Contour();
                contour.Camera = data.Camera;
                contour.SetPoints(yContour);
                area = Math.abs(contour.GetArea());
                if (area > bestArea) {
                    bestArea = area;
                    bestContour = contour;
                }
            }
        }
    }

    return bestContour;
}


// Inplace (not considering tmp data).
// Radius = 0 => single point / no smoothing,  1 => kernel dim 3 ...
function SmoothDataAlphaRGB(inData, radius) {
    if (radius < 1) {return;}
    // create a kernel
    var kernelDim = 2*radius+1;
    var kernel = new Array(kernelDim);
    // One extra for ease of inner loop
    var ksum = new Array(kernelDim + 1);
    ksum[0] = 0;
    for (var i = -radius, j=0; i <= radius; ++i, ++j) {
        if (radius == 0) { // for testing
            kernel[j] = 1.0;
        } else {
            kernel[j] = Math.exp(-i*i/(radius*radius));
        }
        ksum[j+1] = ksum[j] + kernel[j];
    }
    // Normalize
    var sum = ksum[kernel.length];
    for (var i = 0; i < kernel.length; ++i) {
        kernel[i] /= sum;
        ksum[i+1] /= sum;
    }

    var tmpData = new Array(inData.data.length);

    // Smooth x
    var iOut = 0;
    for (var y = 0; y < inData.height; ++y) {
        var rowx = (y*inData.width*4);
        for (var x = 0; x < inData.width; ++x) {
            var startk = Math.max(radius-x, 0);
            var endk = Math.min(radius-x+inData.width, kernelDim);
            var startx = rowx + (x - radius + startk)*4;
            var sumr = 0;
            var sumg = 0;
            var sumb = 0;
            var suma = 0;
            for (var ix = startx, ik = startk; ik < endk; ++ik) {
                sumr += kernel[ik] * inData.data[ix++];
                sumg += kernel[ik] * inData.data[ix++];
                sumb += kernel[ik] * inData.data[ix++];
                suma += kernel[ik] * inData.data[ix++];
            }
            if (x < radius || inData.width - x <= radius) {
                sumr = sumr / (ksum[endk] - ksum[startk]);
                sumg = sumg / (ksum[endk] - ksum[startk]);
                sumb = sumb / (ksum[endk] - ksum[startk]);
                suma = suma / (ksum[endk] - ksum[startk]);
            }
            tmpData[iOut++]   = sumr;
            tmpData[iOut++]   = sumg;
            tmpData[iOut++]   = sumb;
            tmpData[iOut++]   = suma;
        }
    }

    for (var i = 0; i < tmpData.length; ++i) {
        inData.data[i] = tmpData[i];
    }

    // Smooth y
    iOut = 0;
    for (var y = 0; y < inData.height; ++y) {
        var rowx = y * inData.width * 4;
        var startk = Math.max(radius-y, 0);
        var endk = Math.min(radius-y+inData.height, kernelDim);
        var starty = rowx - ((radius-startk)*inData.width*4);
        var clipped = (y < radius || inData.height - y <= radius);
        for (var x = 0; x < inData.width; ++x, starty+=4) {
            var sumr = 0;
            var sumg = 0;
            var sumb = 0;
            var suma = 0;
            for (var iy = starty, ik = startk; ik < endk; ++ik) {
                sumr += kernel[ik] * tmpData[iy];
                sumg += kernel[ik] * tmpData[iy+1];
                sumb += kernel[ik] * tmpData[iy+2];
                suma += kernel[ik] * tmpData[iy+3];
                iy += inData.width*4;
            }
            if (clipped) {
                sumr = sumr / (ksum[endk] - ksum[startk]);
                sumg = sumg / (ksum[endk] - ksum[startk]);
                sumb = sumb / (ksum[endk] - ksum[startk]);
                suma = suma / (ksum[endk] - ksum[startk]);
            }
            inData.data[iOut++]   = sumr;
            inData.data[iOut++]   = sumg;
            inData.data[iOut++]   = sumb;
            inData.data[iOut++]   = suma;
        }
    }
    delete tmpData;
}

function ComputePrincipleCompnent(data) {
    // first compute the average RGB
    var aver = 0.0;
    var aveg = 0.0;
    var aveb = 0.0;
    var suma = 0.0
    for (var i = 0; i < data.data.length; ) {
        var r = data.data[i++];
        var g = data.data[i++];
        var b = data.data[i++];
        var a = data.data[i++];
        suma += a;
        aver += r*a;
        aveg += g*a;
        aveb += b*a;

    }
    aver /= suma;
    aveg /= suma;
    aveb /= suma;

    // Now compute the covarient matrix.
    var rr = 0, bb = 0, gg = 0;
    var rb = 0, rg = 0, gb = 0;
    for (var i = 0; i < data.data.length; ) {
        var r = data.data[i++] - aver;
        var g = data.data[i++] - aveg;
        var b = data.data[i++] - aveb;
        var a = data.data[i++];
        rr += r*r*a;
        bb += b*b*a;
        gg += g*g*a;
        rb += r*b*a;
        rg += r*g*a;
        gb += g*b*a;
    }
    rr /= suma;
    bb /= suma;
    gg /= suma;
    rg /= suma;
    rb /= suma;
    gb /= suma;
    // I am not sure exactly how to  compute the eigen vector.  Just estimate the vector.
    var v = [1,1,1];
    var mag1 = Math.sqrt(v[0]*v[0] + v[1]*v[1] + v[2]*v[2]);
    var eVal = 0;
    for (var i = 0; i < 10; ++i) {
        var r = v[0]*rr + v[1]*rg + v[2]*rb;
        var g = v[0]*rg + v[1]*gg + v[2]*gb;
        var b = v[0]*rb + v[1]*gb + v[2]*bb;
        var mag2 = Math.sqrt(r*r + g*g + b*b);
        eVal = mag2 / mag1;
        mag1 = 1.0;
        v = [r/mag2,g/mag2,b/mag2];
    }

    console.log("val = " + Math.sqrt(eVal) + ", v=(" + v[0] + ", " + v[1] + ", " + v[2] + "), ave=(" + aver + ", " + aveg + ", " + aveb + ")");

    return {val: eVal, v: v, ave: [aver, aveg, aveb]};
}



// Results: Interesting, but not useful.  
// Some tissue has the same value as background. I would need a fill to segment background better.
// Deep red tissue keeps blue red component from dominating.
function EncodePrincipleComponent(data) {
    pc = ComputePrincipleComponent(data);
    pc.val = Math.sqrt(pc.val);
    // first compute the average RGB
    var aver = 0.0;
    var aveg = 0.0;
    var aveb = 0.0;
    for (var i = 0; i < data.data.length; i += 4 ) {
        var r = data.data[i];
        var g = data.data[i+1];
        var b = data.data[i+2];
        r = r - pc.ave[0];
        g = g - pc.ave[1];
        b = b - pc.ave[2];
        // Dot product with eigenvector.
        var dot = r*pc.v[0] + g*pc.v[1] + b*pc.v[2];
        r = Math.round(pc.ave[0] + dot*pc.v[0]);
        g = Math.round(pc.ave[1] + dot*pc.v[1]);
        b = Math.round(pc.ave[2] + dot*pc.v[2]);
        r = Math.min(r,255);
        g = Math.min(g,255);
        b = Math.min(b,255);
        r = Math.max(r,0);
        g = Math.max(g,0);
        b = Math.max(b,0);
        data.data[i] = r;
        data.data[i+1] = g;
        data.data[i+2] = b;
    }
}




function ComputeIntensityHistogram(data, ignoreWhite) {
    if (ignoreWhite === undefined) {
        ignoreWhite = false;
    }

    var hist = new Array(256);
    for (var i = 0; i < 256; ++i) {
        hist[i] = 0;
    }
    // Loop through pixels.
    var pixels = data.data;
    var length = data.width * data.height * 4;
    for (var i = 0; i < length; ) {
        // Compute intensity
        var intensity = Math.floor((data.data[i++] + data.data[i++] + data.data[i++]) / 3);
        // Skip alpha
        if ( ! ignoreWhite || intensity < 254 ) {
            if (intensity > 5) { // black background on some slides.
                ++hist[intensity];
            }
        }
        ++i;
    }
    return hist;
}

function ComputeContourBounds(contour) {
    var bds = [contour[0][0], contour[0][0], contour[0][1], contour[0][1]];
    for (var i = 0; i < contour.length; ++i) {
        if (contour[i][0] < bds[0]) { bds[0] = contour[i][0]; }
        if (contour[i][0] > bds[1]) { bds[1] = contour[i][0]; }
        if (contour[i][1] < bds[2]) { bds[2] = contour[i][1]; }
        if (contour[i][1] > bds[3]) { bds[3] = contour[i][1]; }
    }
    return bds;
}

function ComputeContourSpatialCurvatureHistogram(contour, min, max, axis) {
    var hist = new Array(256);
    for (var i = 0; i < 256; ++i) {
        hist[i] = 0;
    }
    for (var i = 1; i < contour.length-1; ++i) {
        var v0 = [contour[i-1][0]-contour[i][0], contour[i-1][1]-contour[i][1]];
        var v1 = [contour[i+1][0]-contour[i][0], contour[i+1][1]-contour[i][1]];
        // Lets just use the cross product,
        // smoothing should make the angles near 180 anyway.
        var mag0 = Math.sqrt(v0[0]*v0[0] + v0[1]*v0[1]);
        var mag1 = Math.sqrt(v1[0]*v1[0] + v1[1]*v1[1]);
        if (mag0 > 0 && mag1 > 0) {
            var cross = (v0[0]*v1[1] - v0[1]*v1[0]) / (mag0*mag1);
            var idx = Math.floor((contour[i][axis] - min) * 256 / (max-min));
            if (idx >= 0 && idx < 256) {
                hist[idx] += cross;
            }
        }
    }
    return hist;
}

// Find peak of correlation. Wrapped for orientation.
function CorrelateHistograms(hist1, hist2){
    var best = 0;
    var bestOffset = 0;
    for (var i = -200; i <= 200; ++i) {
        var sum = 0;
        var start = Math.max(0, -i);
        var end = Math.min(256, 256-i);
        for (var j = start; j < end; ++j) {
            sum += hist1[j] * hist2[j+i];
        }
        if (sum > best) {
            best = sum;
            bestOffset = i;
        }
    }
    return bestOffset;
}

var YPLOT = undefined;
//  Lets compute and correlate X and y histograms of curvature.
// CURVATURE is too noisey to use for a reliable feature.
// FAILED (Worse than pixel mean).
function ComputeContourShiftCurvatureHistagram(contour1, contour2) {
    // Get the bounds of both contours.
    var bds1 = ComputeContourBounds(contour1);
    var bds2 = ComputeContourBounds(contour2);
    bds1[0] = Math.min(bds1[0], bds2[0]);
    bds1[1] = Math.max(bds1[1], bds2[1]);
    bds1[2] = Math.min(bds1[2], bds2[2]);
    bds1[3] = Math.max(bds1[3], bds2[3]);


    if ( ! YPLOT) {
        YPLOT = new HistogramPlot(20, bds1[2], 100, bds1[3]-bds1[2]);
        YPLOT.Axis = 1;
        YPLOT.Symmetrc = true;
    } else {
        YPLOT.Clear();
        YPLOT.SetSize(20, bds1[2], 100, bds1[3]-bds1[2]);
    }

    MakeContourPolyline(contour1, VIEWERS[0]);
    MakeContourPolyline(contour2, VIEWERS[1]);

    var hist1 = ComputeContourSpatialCurvatureHistogram(contour1, bds1[0], bds1[1], 0);
    var hist2 = ComputeContourSpatialCurvatureHistogram(contour2, bds1[0], bds1[1], 0);
    var dx = CorrelateHistograms(hist1, hist2) * (bds1[1]-bds1[0]) / 256;

    hist1 = ComputeContourSpatialCurvatureHistogram(contour1, bds1[2], bds1[3], 1);
    hist2 = ComputeContourSpatialCurvatureHistogram(contour2, bds1[2], bds1[3], 1);

    YPLOT.Draw(hist1, "green");
    YPLOT.Draw(hist2, "red");

    var dy = CorrelateHistograms(hist1, hist2) * (bds1[3]-bds1[2]) / 256;

    return [dx, dy];
}



// Does not modify either of the contours.
// Minimize distance between contours.
// Returns shift and rotation.
function AlignContours(contour1, contour2) {
    // Get the bounds of both contours.
    var bds1 = ComputeContourBounds(contour1);
    var bds2 = ComputeContourBounds(contour2);
    // Combine them (union).
    bds1[0] = Math.min(bds1[0], bds2[0]);
    bds1[1] = Math.max(bds1[1], bds2[1]);
    bds1[2] = Math.min(bds1[2], bds2[2]);
    bds1[3] = Math.max(bds1[3], bds2[3]);
    // Exapnd the contour by 10%
    var xMid = (bds1[0] + bds1[1])*0.5;
    var yMid = (bds1[2] + bds1[3])*0.5;
    bds1[0] = xMid + 1.1*(bds1[0]-xMid);
    bds1[1] = xMid + 1.1*(bds1[1]-xMid);
    bds1[2] = yMid + 1.1*(bds1[2]-yMid);
    bds1[3] = yMid + 1.1*(bds1[3]-yMid);

    var distMap = new DistanceMap(bds1, 2);
    distMap.AddContour(contour1);
    distMap.Update();

    // No rotation yet.
    var dx = 0, dy = 0;
    for (var i = 0; i < 100; ++i) {
        var sumx = 0, sumy = 0, sumd = 0;
        for (var j = 0; j < contour2.length; ++j) {
            var x = contour2[j][0] - dx;
            var y = contour2[j][1] - dy;
            var grad = distMap.GetGradient(x,y);
            sumx += grad[0];
            sumy += grad[1];
            sumd += distMap.GetDistance(x,y);
        }
        sumd = sumd / contour2.length;
        if (sumd < 1.0) { sumd = 1.0;}
        var mag = Math.abs(sumx) + Math.abs(sumy);
        if (mag > sumd) {
            sumx = sumx * sumd / mag;
            sumy = sumy * sumd / mag;
        }
        dx += sumx;
        dy += sumy;
    }

    var trans = {delta :[dx,dy]};
    return trans;
}

// This first transforms contour2 to match contour1 with a rigid transformation.
// It then creates a mesh and allows it to deform for a better match.
// contour2 is modified to match contour1.
function DeformableAlignContours(contour1, contour2, rigid) {
    // First translate the contour2 to have the same center as
    // contour1. This will make the map smaller and more useful!
    var center1 = contour1.GetCenter();
    var center2 = contour2.GetCenter();
    contour2.Translate([center1[0]-center2[0], center1[1]-center2[1]]);

    // Get the bounds of both contours.
    var bds1 = contour1.GetBounds();
    var bds2 = contour2.GetBounds();
    // Combine them (union).
    bds1[0] = Math.min(bds1[0], bds2[0]);
    bds1[1] = Math.max(bds1[1], bds2[1]);
    bds1[2] = Math.min(bds1[2], bds2[2]);
    bds1[3] = Math.max(bds1[3], bds2[3]);
    // Exapnd the contour by 10%
    var xMid = (bds1[0] + bds1[1])*0.5;
    var yMid = (bds1[2] + bds1[3])*0.5;
    bds1[0] = xMid + 1.1*(bds1[0]-xMid);
    bds1[1] = xMid + 1.1*(bds1[1]-xMid);
    bds1[2] = yMid + 1.1*(bds1[2]-yMid);
    bds1[3] = yMid + 1.1*(bds1[3]-yMid);

    // Compute a spacing so we can use contours in world coordiantes.
    // (used to be 2)
    var spacing = Math.sqrt((bds1[1]-bds1[0])*(bds1[3]-bds1[2])/100000.0);
    var distMap = new DistanceMap(bds1, spacing);
    distMap.AddContour(contour1);
    distMap.Update();

    // Offset ?? Debug this later.
    //contour2 = DecimateContour(contour2, 1);
    RigidAlignContourWithMap(contour2, distMap);
    if ( ! rigid) {
        DeformableAlignContourWithMap(contour2, distMap);
    }
}


// This shifts and rotates the contour to match the distance map.
// It returns the shift and roll, but the contour is also transformed.
function RigidAlignContourWithMap(contour, distMap) {
    // Compute center of rotation
    var c2 = contour.GetCenter();
    var xCenter = c2[0], yCenter = c2[1];

    var xSave = xCenter;
    var ySave = yCenter;
    var roll = 0;

    for (var i = 0; i < 200; ++i) {
        var sumx = 0, sumy = 0, totald = 0;
        var sumr = 0, totalr = 0;
        for (var j = 0; j < contour.Length(); ++j) {
            var x = contour.GetPoint(j)[0];
            var y = contour.GetPoint(j)[1];
            var grad = distMap.GetGradient(x,y);
            sumx += grad[0];
            sumy += grad[1];
            totald += distMap.GetDistance(x,y);
            // For rotation
            var dx = (x-xCenter);
            var dy = (y-yCenter);
            var cross = dx*grad[1]-dy*grad[0];
            sumr += cross;
            totalr += Math.sqrt(dx*dx + dy*dy);
        }
        totald = totald / contour.Length();
        if (totald < 1.0) { totald = 1.0;}
        var mag = Math.abs(sumx) + Math.abs(sumy);
        if (mag > totald) {
            sumx = sumx * totald / mag;
            sumy = sumy * totald / mag;
        }
        sumr /= (totalr * 100);
        contour.Transform([-sumx,-sumy], [xCenter,yCenter], sumr);
        xCenter -= sumx;
        yCenter -= sumy;
        roll += sumr;
    }

    var c1 = contour.GetCenter();
    console.log("2: "+(c2[0]-c1[0])+", "+(c2[1]-c1[1]));


    return {delta: [xCenter-xSave, yCenter-ySave], roll: roll, c0: [xSave,ySave], c1: [xCenter, yCenter]}; // Return rotation?
}

var ITERATIONS = 5000;
var EDGE_FACTOR = 0.2;
var GRADIENT_FACTOR = 0.03;
// Convert the contour into a mesh for internal use, but modify contour2
// to match contour1.
function DeformableAlignContourWithMap(contour, distMap) {
    var mesh = new TriangleMesh();

    if (contour.GetArea() < 0) {
        contour.Points.reverse();
    }

    mesh.TriangulateContour(contour);
    mesh.CreateFullMesh();
    while (mesh.ConditionEdgeRotate()) {}
    mesh.Update();
    DEBUG_MESH2 = new TriangleMesh();
    DEBUG_MESH2.DeepCopy(mesh);

    // Create an array to hold the sumation of forces on the points.
    var numPoints = (mesh.PointCoordinates.length / 2);
    var dPoints = new Array(numPoints);

    for (var i = 0; i < ITERATIONS; ++i) {
        // First move points down gradient.
        var idx = 0;
        for (var j = 0; j < numPoints; ++j) {
            var pt = mesh.GetPointCoordinates(j);
            var grad = distMap.GetGradient(pt[0], pt[1]);

            // Better to apply the gradient and edge forces separately
            //dPoints[idx++] = -grad[0] * GRADIENT_FACTOR;
            //dPoints[idx++] = -grad[1] * GRADIENT_FACTOR;
            mesh.PointCoordinates[idx]   -= grad[0] * GRADIENT_FACTOR;
            mesh.PointCoordinates[idx+1] -= grad[1] * GRADIENT_FACTOR;
            dPoints[idx] = 0;
            dPoints[idx+1] = 0;
            idx += 2;
        }

        // Apply forces due to edge displacement.
        for (var j = 0; j < mesh.Edges.length; ++j) {
            var edge = mesh.Edges[j];
            if ( edge === undefined) {
                continue;
            }
            var p0 = mesh.GetPointCoordinates(edge.vert0);
            var p1 = mesh.GetPointCoordinates(edge.vert1);
            var dx = p1[0]-p0[0], dy = p1[1]-p0[1];
            var length = Math.sqrt(dx*dx+dy*dy);
            var k = EDGE_FACTOR*(length - edge.length)/(2*length);
            idx = edge.vert0 << 1;
            dPoints[idx++] += dx*k;
            dPoints[idx] += dy*k;
            idx = edge.vert1 << 1;
            dPoints[idx++] -= dx*k;
            dPoints[idx] -= dy*k;
        }
        // Apply the delta sums to the points/
        var idx = 0;
        for (var j = 0; j < numPoints; ++j) {
            mesh.PointCoordinates[idx] += dPoints[idx++];
            mesh.PointCoordinates[idx] += dPoints[idx++];
        }
    }
    var idx = 0;
    for (var ptIdx = 0; ptIdx < contour.Length(); ++ptIdx) {
        contour.SetPoint(ptIdx, [mesh.PointCoordinates[idx++],
                                 mesh.PointCoordinates[idx++]]);
    }

    mesh.Update();
    DEBUG_MESH1 = mesh;
}



// Choose a threshold: 
//    (This step can be a problem.  It latches onto white vs slide when zoomed out)
// Find the largest contour 
//    (We might want to find multiple tissue sections).
// Create a distance map from contour in viewer1.  
//    (We may want to make inside 0 distance).
//    We may want to use euclidian instead of cityblock.
// Rigid align contour2 to contour1
// Deformable align contour2 to contour1.
var DEBUG_CONTOUR1;
var DEBUG_CONTOUR2a;
var DEBUG_CONTOUR2b;
var DEBUG_MESH1;
var DEBUG_MESH2;
var DEBUG_TRANS;
function testDebug() {
    //MakeContourPolyline(DEBUG_CONTOUR1, VIEWERS[0]);
    //MakeContourPolyline(DEBUG_CONTOUR2a, VIEWERS[1]);
    //MakeContourPolyline(DEBUG_CONTOUR2b, VIEWERS[0]);

    DEBUG_MESH1.ConvertPointsToWorld(VIEWERS[0]);
    VIEWERS[0].AddShape(DEBUG_MESH1);

    DEBUG_MESH2.ConvertPointsToWorld(VIEWERS[1]);
    VIEWERS[1].AddShape(DEBUG_MESH2);
}


var WAITING;

function DeformableAlignViewers() {
    var note = SA.DualDisplay.GetNote();
    var trans = note.ViewerRecords[note.StartIndex + 1].Transform;
    if ( ! trans) {
        return;
    }

    var viewport = VIEWERS[1].GetViewport();
    var left = viewport[0] + (viewport[2]/2) - 40;
    var top = viewport[1] + (viewport[3]/2) - 40;
    if (WAITING === undefined) {
        WAITING = $('<img>')
            .appendTo('body')
            .attr("src", SA.ImagePathUrl+"circular.gif")
            .attr("alt", "waiting...")
            .hide()
            .addClass("sa-view-align-waiting");
    }

    WAITING
        .show()
        .css({'left': left+'px',
              'top': top+'px'});

    // Trying to get the waiting icon to appear....
    window.setTimeout(
        function () {
            // Resample contour for a smaller mesh.
            var spacing = 3;

            var viewer = VIEWERS[0];
            var data1 = GetImageData(viewer.MainView);
            SmoothDataAlphaRGB(data1, 2);
            var histogram1 = ComputeIntensityHistogram(data1, true);
            var threshold1 = PickThreshold(histogram1);
            var contour1 = LongestContour(data1, threshold1);

            viewer = VIEWERS[1];
            var data2 = GetImageData(viewer.MainView);
            SmoothDataAlphaRGB(data2, 2);
            var histogram2 = ComputeIntensityHistogram(data2, true);
            var threshold2 = PickThreshold(histogram2);
            var contour2 = LongestContour(data2, threshold2);
            contour2.RemoveDuplicatePoints(spacing);

            // Save a copy of the contour before it is transformed.
            // We need before and after to make correlation points.
            var originalContour2 = new Contour();
            originalContour2.DeepCopy(contour2);
            DeformableAlignContours(contour1, contour2);

            DEBUG_CONTOUR1 = contour1;
            DEBUG_CONTOUR2a = originalContour2;
            DEBUG_CONTOUR2b = contour2

            // Now clear all correlation points in the stack sections.

            // Remove all correlations.
            //trans.Correlations = [];
            // Remove all correlations visible in the window.
            var cam = VIEWERS[0].GetCamera();
            var bds = cam.GetBounds();
            var idx = 0;
            while (idx < trans.Correlations.length) {
                var cor = trans.Correlations[idx];
                if (cor.point0[0] > bds[0] && cor.point0[0] < bds[1] && 
                    cor.point0[1] > bds[2] && cor.point0[1] < bds[3]) {
                    trans.Correlations.splice(idx,1);
                } else {
                    ++idx;
                }
            }
            DEBUG_TRANS = trans;

            // Now make new correlations from the transformed contour.
            var targetNumCorrelations = 40;
            var skip = Math.ceil(contour2.Length() / targetNumCorrelations);
            for (var i = 2; i < originalContour2.Length(); i += skip) {
                var viewport = VIEWERS[0].GetViewport();
                var pt1 = VIEWERS[0].ConvertPointViewerToWorld(contour2.GetPoint(i)[0],
                                                            contour2.GetPoint(i)[1]);
                var viewport = VIEWERS[1].GetViewport();
                var pt2 = VIEWERS[1].ConvertPointViewerToWorld(originalContour2.GetPoint(i)[0],
                                                            originalContour2.GetPoint(i)[1]);
                var cor = new PairCorrelation();
                cor.SetPoint0(pt1);
                cor.SetPoint1(pt2);
                trans.Correlations.push(cor);
            }

            console.log("Finished alignment");
            // Syncronize views
            SA.DualDisplay.SynchronizeViews(0, note);

            WAITING.hide();

            eventuallyRender();
        }, 10);
}

// An idea.  Use an existing polyline instead of a new iso contour.
// Select polylines by color.
// Something is not work.  
// I expect two things: Coordinate system (no) or spacing (no).
// !!!!!!!!!!!!!

function AlignPolylines(replace) {

    var viewer1 = VIEWERS[0];
    var camBds1 = viewer1.GetCamera().GetBounds();
    var viewer2 = VIEWERS[1];
    var camBds2 = viewer2.GetCamera().GetBounds();
    for (var i1 = 0; i1 < viewer1.WidgetList.length; ++i1) {
        var pLine1 = viewer1.WidgetList[i1];
        if (pLine1 instanceof PolylineWidget && pLine1.Shape.Points.length > 0) {
            var bds1 = pLine1.Shape.GetBounds();
            var wCen1 = [(bds1[0]+bds1[1])*0.5, (bds1[2]+bds1[3])*0.5];
            var cen1 = viewer1.ConvertPointWorldToViewer(wCen1[0], wCen1[1]);
            if (wCen1[0] < camBds1[0] || wCen1[0] > camBds1[1] ||
                wCen1[1] < camBds1[2] || wCen1[1] > camBds1[3]) { 
                continue; 
            } 
            var c1 = pLine1.Shape.OutlineColor;
            var pLine2Best = null;
            var dist2Best = 10000000;
            for (var i2 = 0; i2 < viewer2.WidgetList.length; ++i2) {
                var pLine2 = viewer2.WidgetList[i2];
                if (pLine2 instanceof PolylineWidget && pLine2.Shape.Points.length > 0) {
                    var c2 = pLine2.Shape.OutlineColor;
                    if (Math.abs(c1[0]-c2[0]) < 0.01 &&
                        Math.abs(c1[1]-c2[1]) < 0.01 &&
                        Math.abs(c1[2]-c2[2]) < 0.01) {

                        var bds2 = pLine2.Shape.GetBounds();
                        var wCen2 = [(bds2[0]+bds2[1])*0.5, (bds2[2]+bds2[3])*0.5];
                        var cen2 = viewer2.ConvertPointWorldToViewer(wCen2[0], wCen2[1]);
                        if (wCen2[0] < camBds2[0] || wCen2[0] > camBds2[1] ||
                            wCen2[1] < camBds2[2] || wCen2[1] > camBds2[3]) { 
                            continue; 
                        } 
                        var dist2 =
                            (cen2[0]-cen1[0])*(cen2[0]-cen1[0]) +
                            (cen2[1]-cen1[1])*(cen2[1]-cen1[1]);
                        if ( ! pLine2Best || dist2Best < dist2) {
                            dist2Best = dist2;
                            pLine2Best = pLine2;
                        }
                    }
                }
            }

            if (dist2Best < 100000) {
                AlignPolylines2(pLine1, pLine2Best, replace);
            }
        }
    }
}


// just remove all polylines leaving only lines of the same color.
function MaskPolylinesByColor(rgb) {
    rgb[0] = rgb[0] / 255;
    rgb[1] = rgb[1] / 255;
    rgb[2] = rgb[2] / 255;
    // Remove the polylines from viewers
    for (var i = 0; i < 2; ++i) {
        var viewer1 = VIEWERS[i];
        var newList = [];
        for (var i1 = 0; i1 < viewer1.WidgetList.length; ++i1) {
            var w1 = viewer1.WidgetList[i1];
            if (w1 instanceof PolylineWidget) {
                var c1 = w1.Shape.OutlineColor;
                if (Math.abs(c1[0]-rgb[0]) < 0.05 &&
                    Math.abs(c1[1]-rgb[1]) < 0.05 &&
                    Math.abs(c1[2]-rgb[2]) < 0.05) {
                    newList.push(w1);
                }
            }
        }
        viewer1.WidgetList = newList;
    }

    // Do the note too.
    var note = SA.DualDisplay.GetNote();
    // Display has no get root.
    while (note.Parent) {
        note = note.Parent;
    }
    for (var i = 0; i < note.ViewerRecords.length; ++i) {
        var vr = note.ViewerRecords[i];
        var newList = [];
        for ( var j = 0; j < vr.Annotations.length; ++j) {
            var a = vr.Annotations[j];
            var c = a.outlinecolor;
            if (Math.abs(c[0]-rgb[0]) < 0.05 &&
                Math.abs(c[1]-rgb[1]) < 0.05 &&
                Math.abs(c[2]-rgb[2]) < 0.05) {
                newList.push(a);
            }
        }
        vr.Annotations = newList;
    }
    eventuallyRender();    
}

function AlignPolylinesByColor(rgb, replace) {
    rgb[0] = rgb[0] / 255;
    rgb[1] = rgb[1] / 255;
    rgb[2] = rgb[2] / 255;
    // Get the polyline from viewer1
    var viewer1 = VIEWERS[0];
    var camBds1 = viewer1.GetCamera().GetBounds();
    var pLine1 = null;
    var count1 = 0;
    for (var i1 = 0; i1 < viewer1.WidgetList.length; ++i1) {
        var w1 = viewer1.WidgetList[i1];
        if (w1 instanceof PolylineWidget && w1.Shape.Points.length > 0) {

            var bds1 = w1.Shape.GetBounds();
            var wCen1 = [(bds1[0]+bds1[1])*0.5, (bds1[2]+bds1[3])*0.5];
            if (wCen1[0] < camBds1[0] || wCen1[0] > camBds1[1] ||
                wCen1[1] < camBds1[2] || wCen1[1] > camBds1[3]) {
                continue;
            }

            var c1 = w1.Shape.OutlineColor;
            if (Math.abs(c1[0]-rgb[0]) < 0.05 &&
                Math.abs(c1[1]-rgb[1]) < 0.05 &&
                Math.abs(c1[2]-rgb[2]) < 0.05) {
                ++count1;
                pLine1 = w1;
            }
        }
    }
    if (count1 != 1) {return;}

    // Get the polyline from viewer2
    var viewer2 = VIEWERS[1];
    var camBds2 = viewer2.GetCamera().GetBounds();
    var pLine2 = null;
    var count2 = 0;
    for (var i2 = 0; i2 < viewer2.WidgetList.length; ++i2) {
        var w2 = viewer2.WidgetList[i2];
        if (w2 instanceof PolylineWidget && w1.Shape.Points.length > 0) {

            var bds2 = w2.Shape.GetBounds();
            var wCen2 = [(bds2[0]+bds2[1])*0.5, (bds2[2]+bds2[3])*0.5];
            if (wCen2[0] < camBds2[0] || wCen2[0] > camBds2[1] ||
                wCen2[1] < camBds2[2] || wCen2[1] > camBds2[3]) {
                continue;
            }

            var c2 = w2.Shape.OutlineColor;
            if (Math.abs(c2[0]-rgb[0]) < 0.05 &&
                Math.abs(c2[1]-rgb[1]) < 0.05 &&
                Math.abs(c2[2]-rgb[2]) < 0.05) {
                ++count2;
                pLine2 = w2;
            }
        }
    }
    if (count2 != 1) {return;}

    AlignPolylines2(pLine1, pLine2, replace);
}


var POLYLINE_AREA = 0;
function IntegratePolylinesByColor(rgb) {
    rgb[0] = rgb[0] / 255;
    rgb[1] = rgb[1] / 255;
    rgb[2] = rgb[2] / 255;

    // Get the polyline from viewer1
    var viewer1 = VIEWERS[0];
    var camBds1 = viewer1.GetCamera().GetBounds();

    for (var i1 = 0; i1 < viewer1.WidgetList.length; ++i1) {
        var w1 = viewer1.WidgetList[i1];
        if (w1 instanceof PolylineWidget && w1.Shape.Points.length > 0) {
            var bds1 = w1.Shape.GetBounds();
            var wCen1 = [(bds1[0]+bds1[1])*0.5, (bds1[2]+bds1[3])*0.5];
            var c1 = w1.Shape.OutlineColor;
            if (wCen1[0] < camBds1[0] || wCen1[0] > camBds1[1] ||
                wCen1[1] < camBds1[2] || wCen1[1] > camBds1[3]) {
                continue;
            }
            if (Math.abs(c1[0]-rgb[0]) < 0.05 &&
                Math.abs(c1[1]-rgb[1]) < 0.05 &&
                Math.abs(c1[2]-rgb[2]) < 0.05) {
                var area = w1.ComputeArea();
                POLYLINE_AREA += area;
                console.log(area);
            }
        }
    }

}


function AlignPolylines2(pLine1, pLine2, replace) {
    var note = SA.DualDisplay.GetNote();
    var trans = note.ViewerRecords[note.StartIndex + 1].Transform;
    if ( ! trans) {
        return;
    }

    var contour1 = new Contour();
    contour1.World = true;
    contour1.SetPoints(pLine1.Shape.Points);
    contour1.Camera = VIEWER1.GetCamera();
    contour1.WorldToViewer();
    contour1.Resample(1);
    //contour1.Resample(5);

    var contour2 = new Contour();
    contour2.World = true;
    contour2.SetPoints(pLine2.Shape.Points);
    contour2.Camera = VIEWER2.GetCamera();
    contour2.WorldToViewer();
    contour2.Resample(1);
    //contour2.Resample(5);

    if (contour1.Points.length == 0 || contour2.Points.length == 0) {
        return;
    }

    // Save a copy of the contour before it is transformed.
    // We need before and after to make correlation points.
    var originalContour2 = new Contour();
    originalContour2.DeepCopy(contour2);
    // Lets try rigid.
    DeformableAlignContours(contour1, contour2, true);

            DEBUG_CONTOUR1 = contour1;
            DEBUG_CONTOUR2a = originalContour2;
            DEBUG_CONTOUR2b = contour2
            DEBUG_TRANS = trans;


    if (replace) {
        // Remove all correlations.
        //trans.Correlations = [];
        // Remove all correlations visible in the window.
        var cam = VIEWERS[0].GetCamera();
        var bds = cam.GetBounds();
        var idx = 0;
        while (idx < trans.Correlations.length) {
            var cor = trans.Correlations[idx];
            if (cor.point0[0] > bds[0] && cor.point0[0] < bds[1] && 
                cor.point0[1] > bds[2] && cor.point0[1] < bds[3]) {
                trans.Correlations.splice(idx,1);
            } else {
                ++idx;
            }
        }
    }
        DEBUG_TRANS = trans;

    // Now make new correlations from the transformed contour.
    var targetNumCorrelations = 10;
    var skip = Math.ceil(contour2.Length() / targetNumCorrelations);
    for (var i = 2; i < originalContour2.Length(); i += skip) {
        var pt1 = contour2.GetPoint(i);
        if (contour1.Camera) { // aligned contour2 is in contour1
            // coordinate system.
            pt1 = contour1.Camera.ConvertPointViewerToWorld(pt1[0],pt1[1]);
        }
        var pt2 = originalContour2.GetPoint(i);
        if (contour2.Camera) {
            pt2 = contour2.Camera.ConvertPointViewerToWorld(pt2[0],pt2[1]);
        }

        //var pt1 = contour2.GetPoint(i);
        //var pt2 = originalContour2.GetPoint(i);
        var cor = new PairCorrelation();
        cor.SetPoint0(pt1);
        cor.SetPoint1(pt2);
        trans.Correlations.push(cor);
    }

    console.log("Finished alignment");
    // Syncronize views
    SA.DualDisplay.SynchronizeViews(0, note);

    eventuallyRender();
}



// Find peak of correlation. Wrapped for orientation.
function CorrelateWrappedHistograms(hist1, hist2){
    var length = hist1.length;
    var best = 0;
    var bestOffset = 0;
    for (i = 0; i < length; ++i) {
        var sum = 0;
        for (j1 = 0; j1 < length; ++j1) {
            var j2 = i + j1;
            if (j2 >= length) { j2 -= length; }
            sum += hist1[j1] * hist2[j2];
        }
        if (sum > best) {
            best = sum;
            bestOffset = i;
        }
    }

    return bestOffset;
}

function HistogramDerivative(hist) {
    var derivative = new Array(hist.length-1);
    for (var i = 1; i < hist.length; ++i) {
        derivative[i-1] = hist[i] - hist[i-1];
    }
    return derivative;
}

function HistogramIntegral(hist) {
    var integral = new Array(hist.length);
    var sum = 0;
    for (var i = 0; i < hist.length; ++i) {
        sum += hist[i];
        integral[i] = sum;
    }
    return integral;
}


// I cannot make any good assumptions about percentages because
// a bounding box could be tight around the tissue.
// Just look for the minimum histogram value in the correct
// intensity range.
function PickThreshold(hist) {
    return PickThresholdContaining(hist,10);
}            

// Threshold has to be above val.
function PickThresholdContaining(hist, val) {
    var best = -1;
    var bestIdx = -1;

    var integral = HistogramIntegral(hist);
    var max = integral[integral.length - 1];
    for (idx = val; idx < hist.length-10; ++idx) {
        // Compute a metric for a good threshold.
        var goodness = 0;
        // > 10%, < 90%
        var tmp = integral[idx]/max;
        if (tmp > 0.1 && tmp < 0.9) {
            // Pick a gap (low point) in the histogram.
            goodness = 1.0 / (hist[idx]+1);
            // Pick a high value over a low value
            goodness *= Math.exp(idx / 8);  // tried 4-8, all very similar.
        }
        if (goodness > best) {
            best = goodness;
            bestIdx = idx;
        }
    }

    return bestIdx;
}            

// Threshold is choosen from the range, but not equal to the min or max.
function PickThresholdFromRange(hist, min, max) {
    var best = -1;
    var bestIdx = -1;

    var integral = HistogramIntegral(hist);
    var max = integral[integral.length - 1];
    for (idx = val; idx < hist.length-10; ++idx) {
        // Compute a metric for a good threshold.
        var goodness = 0;
        // > 10%, < 90%
        var tmp = integral[idx]/max;
        if (tmp > 0.1 && tmp < 0.9) {
            // Pick a gap (low point) in the histogram.
            goodness = 1.0 / (hist[idx]+1);
            // Pick a high value over a low value
            goodness *= Math.exp(idx / 8);  // tried 4-8, all very similar.
        }
        if (goodness > best) {
            best = goodness;
            bestIdx = idx;
        }
    }

    return bestIdx;
}            



// For debugging.
// Create a threshold mask image annotation to see the results.
// Compute the first moment at the same time.
function ThresholdData(data, threshold, high) {
    if (high == undefined) { high = true; }
    var xSum = 0;
    var ySum = 0;
    var count = 0;
    var i = 0;
    for (var y = 0; y < data.height; ++y) {
        for (var x = 0; x < data.width; ++x) {
            var intensity = Math.floor((data.data[i] + data.data[i+1] + data.data[i+2]) / 3);
            if ((intensity > threshold) == high) { // Make it semi opaque black
                data.data[i] = data.data[i+1] = data.data[i+2] = 0;
                data.data[i+3] = 255;
            } else {
                ++count;
                xSum += x;
                ySum += y;
                data.data[i+3] = 0;
            }
            i += 4;
        }
    }
    data.mid_x = xSum / count;
    data.mid_y = ySum / count;
}

// I was going to create an image annotation, but it is not easy
// to convert the data to an image.  I could use a separate canves to do this,
// but it is easier (for now) to just use putImageData.
//var IMAGE_ANNOTATION = undefined;
function DrawImageData(viewer, data) {
    /*if ( ! IMAGE_ANNOTATION) {
        IMAGE_ANNOTATION = new ImageAnnotation();
        IMAGE_ANNOTATION.Image = new Image();
        IMAGE_ANNOTATION.Image.src = SA.ImagePathUrl+"nextNote.png";
        IMAGE_ANNOTATION.Origin = [80000, 40000];
        IMAGE_ANNOTATION.Height = 5000;
*/
    var context = viewer.MainView.Context2d;
    context.putImageData(data, 0, 0);
}



    
    
// Shared histogram, So we can execute tests multiple times.
var PLOT = undefined;



function intensityHistogram(viewer, color, min, max) {
    if ( ! PLOT) {
        PLOT= new HistogramPlot('50%','50%', 400, 200);
    }
    PLOT.Clear();

    var data1 = GetImageData(viewer.MainView);
    var histogram1 = ComputeIntensityHistogram(data1);
    PLOT.Draw(histogram1, color, min, max);
    var d = HistogramIntegral(histogram1);
    PLOT.Draw(d, "red", min, max);
}

// Takes around a second for r = 3;
function testSmooth(radius) {
    var data1 = GetImageData(VIEWERS[0].MainView);
    SmoothDataAlphaRGB(data1,radius);
    DrawImageData(VIEWERS[0], data1);
    delete data1;
}


// Peal away background
// then run pc again.
// Results: Interesting, but not useful.  
// Some tissue has the same value as background. I would need a fill to segment background better.
// Deep red tissue keeps blue red component from dominating.
function testPrincipleComponentEncoding() {
    var data1 = GetImageData(VIEWERS[0].MainView);
    SmoothDataAlphaRGB(data1,2);
    //EncodePrincipleComponent(data1);
    var histogram1 = ComputeIntensityHistogram(data1);
    var threshold1 = PickThreshold(histogram1);
    // This masks background by making it tranparent.
    ThresholdData(data1, threshold1);
    // This ignores transparent pixels.
    EncodePrincipleComponent(data1);


    DrawImageData(VIEWERS[1], data1);
    delete data1;
}


// Worked sometimes, but not always.
function testAlignTranslationPixelMean() {
    var data1 = GetImageData(VIEWERS[0].MainView);
    var histogram1 = ComputeIntensityHistogram(data1);
    var threshold1 = PickThreshold(histogram1);
    ThresholdData(data1, threshold1);
    //DrawImageData(VIEWERS[0], data1);

    var data2 = GetImageData(VIEWERS[1].MainView);
    var histogram2 = ComputeIntensityHistogram(data2);
    var threshold2 = PickThreshold(histogram2);
    ThresholdData(data2, threshold2);
    //DrawImageData(VIEWERS[1], data2);

    var dx = data2.mid_x - data1.mid_x;
    var dy = data2.mid_y - data1.mid_y;

    // Convert from pixels to slide coordinates
    var cam = VIEWERS[0].GetCamera();
    var viewport = VIEWERS[0].GetViewport();
    dx = dx * cam.Height / viewport[3];
    dy = dy * cam.Height / viewport[3];

    VIEWERS[0].AnimateTranslate(-dx/2, -dy/2);
    VIEWERS[1].AnimateTranslate(dx/2, dy/2);

    console.log("Translate = (" + dx + ", " + dy + ")" );
}




// Allign mean of thresholded pixels worked ok but not for zoomed in.
// Try aligning the contour.
// Mean of the contour points did not work.
// Histogram of contour curvature did not work.
// Minimize distance between two contours. (Distance map to keep distance computation fast).
function testAlignTranslation(debug) {
    var viewer1 = VIEWERS[0];
    var data1 = GetImageData(viewer1.MainView);
    SmoothDataAlphaRGB(data1, 2);
    var histogram1 = ComputeIntensityHistogram(data1, true);
    var threshold1 = PickThreshold(histogram1);
    var contour1 = LongestContour(data1, threshold1);

    var viewer2 = VIEWERS[1];
    var viewport2 = viewer2.GetViewport();
    var data2 = GetImageData(viewer2.MainView);
    SmoothDataAlphaRGB(data2, 2);
    var histogram2 = ComputeIntensityHistogram(data2, true);
    var threshold2 = PickThreshold(histogram2);
    var contour2 = LongestContour(data2, threshold2);

    var trans = AlignContours(contour1, contour2);

    if (debug) {
        contour1 = DecimateContour(contour1,1);
        TranslateContour(contour2,[-trans.delta[0],-trans.delta[1]]);
        contour2 = DecimateContour(contour2,1);
        MakeContourPolyline(contour1, VIEWERS[0]);
        MakeContourPolyline(contour2, VIEWERS[0]);
    }


    // Convert from pixels to slide coordinates
    var cam = VIEWERS[0].GetCamera();
    var viewport = VIEWERS[0].GetViewport();
    var dx = trans.delta[0] * cam.Height / viewport[3];
    var dy = trans.delta[1] * cam.Height / viewport[3];

    VIEWERS[0].AnimateTranslate(-dx/2, -dy/2);
    VIEWERS[1].AnimateTranslate(dx/2, dy/2);


    // Ignore rotation for now.

    console.log("Translate = (" + dx + ", " + dy + ")" );
}

function testAlignTranslation2(debug) {
    var viewer1 = VIEWERS[0];
    var data1 = GetImageData(viewer1.MainView);
    SmoothDataAlphaRGB(data1, 2);
    var histogram1 = ComputeIntensityHistogram(data1, true);
    var threshold1 = PickThreshold(histogram1);
    var contour1 = LongestContour(data1, threshold1);

    var viewer2 = VIEWERS[1];
    var data2 = GetImageData(viewer2.MainView);
    SmoothDataAlphaRGB(data2, 2);
    var histogram2 = ComputeIntensityHistogram(data2, true);
    var threshold2 = PickThreshold(histogram2);
    var contour2 = LongestContour(data2, threshold2);

    var trans = AlignContours(contour1, contour2);

    if (debug) {
        contour1 = DecimateContour(contour1,1);
        TranslateContour(contour2,[-trans.delta[0],-trans.delta[1]]);
        contour2 = DecimateContour(contour2,1);
        MakeContourPolyline(contour1, VIEWERS[0]);
        MakeContourPolyline(contour2, VIEWERS[0]);
    }


    // Convert from pixels to slide coordinates
    var cam = VIEWERS[0].GetCamera();
    var viewport = VIEWERS[0].GetViewport();
    var dx = trans.delta[0] * cam.Height / viewport[3];
    var dy = trans.delta[1] * cam.Height / viewport[3];

    VIEWERS[0].AnimateTranslate(-dx/2, -dy/2);
    VIEWERS[1].AnimateTranslate(dx/2, dy/2);


    // Ignore rotation for now.

    console.log("Translate = (" + dx + ", " + dy + ")" );
}



// Moving toward deformation of contour
function testAlignTranslation() {
    var viewer1 = VIEWERS[0];
    var data1 = GetImageData(viewer1.MainView);
    SmoothDataAlphaRGB(data1, 5);
    var histogram1 = ComputeIntensityHistogram(data1, true);
    var threshold1 = PickThreshold(histogram1);
    var contour1 = LongestContour(data1, threshold1);

    //MakeContourPolyline(contour1, VIEWERS[0]);

    var viewer2 = VIEWERS[1];
    var data2 = GetImageData(viewer2.MainView);
    SmoothDataAlphaRGB(data2, 5);
    var histogram2 = ComputeIntensityHistogram(data2, true);
    var threshold2 = PickThreshold(histogram2);
    var contour2 = LongestContour(data2, threshold2);

    //MakeContourPolyline(contour2, VIEWERS[1]);

    // Make a copy of contour2.
    //var contour2copy = new Array(contour2.length);
    //for (var i = 0; i < contour2copy; ++i) {
    //    contour2copy[i] = [contour2[i][0], contour2[i][1]];
    //}

    var trans = RigidAlignContours(contour1, contour2);

    // Move center to 0 (keep track of focal point
    var dx = (viewport2[2]*0.5) - trans.c0[0];
    var dy = (viewport2[3]*0.5) - trans.c0[1];
    // Rotate
    var c = Math.cos(trans.roll);
    var s = Math.sin(trans.roll);

    var tx = c*dx + s*dy;
    var ty = -s*dx + c*dy;
    // Move origin to c1
    tx += trans.c1[0];
    ty += trans.c1[1];

    // Compute focal point delta.
    tx = tx - (viewport2[2]*0.5);
    ty = ty - (viewport2[3]*0.5);

    // Convert from pixels to slide coordinates
    var cam = VIEWERS[0].GetCamera();
    var tx = tx * cam.Height / viewport2[3];
    var ty = ty * cam.Height / viewport2[3];

    VIEWERS[1].AnimateTransform(-tx, -ty, -trans.roll);
}



function testDistanceMapContour() {
    var viewer1 = VIEWERS[0];
    var data1 = GetImageData(viewer1.MainView);
    SmoothDataAlphaRGB(data1, 5);
    var histogram1 = ComputeIntensityHistogram(data1);
    var threshold1 = PickThreshold(histogram1);
    var contour1 = LongestContour(data1, threshold1);
    MakeContourPolyline(contour1, VIEWERS[0]);

    var bds1 = ComputeContourBounds(contour1);
    var distMap = new DistanceMap(bds1, 1);
    distMap.AddContour(contour1);
    distMap.Update();
    distMap.Draw(VIEWERS[1]);
}

function testDistanceMapThreshold() {
    var viewer1 = VIEWERS[0];
    var ctx1 = viewer1.MainView.Context2d;
    var data1 = GetImageData(viewer1.MainView);
    SmoothDataAlphaRGB(data1, 2);
    var histogram1 = ComputeIntensityHistogram(data1);
    var threshold1 = PickThreshold(histogram1);
    ThresholdData(data1, threshold1, false);
    ctx1.putImageData(data1,0,0);

    var bds1 = [0, data1.width, 0, data1.height];
    var distMap = new DistanceMap(bds1, 1);
    distMap.AddImageData(data1);
    distMap.Update();
    distMap.Draw(VIEWERS[1]);
}

// Lets try the contour trick.
// Smooth, contour, find the longest contour
// I could perform connectivity before or after contouring.
// lets do it after.  Scan for edge. Trace the edge. Mark pixels that have already been contoured.
function testContour(threshold) {
    var viewer = VIEWERS[0];
    var data1 = GetImageData(viewer.MainView);
    SmoothDataAlphaRGB(data1, 2);
    var points = LongestContour(data1, threshold);
    ContourRemoveDuplicatePoints(points, 1);
    if (points.length > 1) {
        var plWidget = MakeContourPolyline(points, VIEWERS[0]);
    }
}


// Make a triangle mesh from a contour
// This works great.
// Rigid alignment should work the same (hold off on using distance map from threshold).
// The to implement deformable registration.
function testContourMesh(deci) {
    if (deci == undefined) {
        deci = 3;
    }
    var viewer = VIEWERS[1];
    var data1 = GetImageData(viewer.MainView);
    SmoothDataAlphaRGB(data1, 2);
    var histogram1 = ComputeIntensityHistogram(data1, true);
    var threshold1 = PickThreshold(histogram1);
    var points = LongestContour(data1, threshold1);
    ContourRemoveDuplicatePoints(points, 3);
    //points = DecimateContour(points, deci); // just for testing.

    CONTOUR = points;

    var mesh = new TriangleMesh();
    mesh.TriangulateContour(points);
    mesh.CreateFullMesh();
    while (mesh.ConditionEdgeRotate()) {}
    mesh.Update();


    mesh.ConvertPointsToWorld(viewer);
    viewer.AddShape(mesh);
    eventuallyRender();
}


// !!! This works on needle core biopsies !!!
// A couple of issues: Many iterations are required.  Better to have smaller steps and more iterations.
// It should really be executed on the server for performance.
// We may want to add internal points to the mesh for contour stability.


// Get two contours and deform second to match the first.
// Next step, get alignment points from contour.
function testDeformableAlign(spacing) {
    if (spacing == undefined) {
        spacing = 3;
    }
    var viewer = VIEWERS[0];
    var data1 = GetImageData(viewer.MainView);
    SmoothDataAlphaRGB(data1, 2);
    var histogram1 = ComputeIntensityHistogram(data1, true);
    var threshold1 = PickThreshold(histogram1);
    var contour1 = LongestContour(data1, threshold1);
    MakeContourPolyline(contour1, VIEWERS[0]);

    viewer = VIEWERS[1];
    var data2 = GetImageData(viewer.MainView);
    SmoothDataAlphaRGB(data2, 2);
    var histogram2 = ComputeIntensityHistogram(data2, true);
    var threshold2 = PickThreshold(histogram2);
    var contour2 = LongestContour(data2, threshold2);
    ContourRemoveDuplicatePoints(contour2, spacing);

    DeformableAlignContours(contour1, contour2);
    MakeContourPolyline(contour2, VIEWERS[0]);
    eventuallyRender();
}

//==============================================================================
// Find all the sections on a slide (for a stack).
// hagfish
// I either have to keep the camera with the contour, or translate the
// contour into world coordinate points.  The second sounds easier.



// Find the best contour given an estimate of center and area..
function FindSectionContour (data, center, area) {
    var smooth = 2; // is this really necesary?  It is expensive.
    SmoothDataAlphaRGB(data, smooth);

    // I could estimate area from the histogram, but there maybe multiple pieces.
    var histogram = ComputeIntensityHistogram(data, true);
    var threshold = PickThreshold(histogram);

    var contours = GetHagFishContours(data, threshold, min, max);

    return contours;
}




// We might constrain sequential contours to be similar areas.
// This could eliminate the need for manual verification.
function FindSectionContours(data, val) {
    var smooth = 2; // is this really necesary?  It is expensive.
    var min = 0.00002;
    var max = 0.5;
    if ( ! val) { val = 10; }

    SmoothDataAlphaRGB(data, smooth);
    var histogram = ComputeIntensityHistogram(data, true);
    var threshold = PickThresholdContaining(histogram, val);
    var contours = GetHagFishContours(data, threshold, min, max);

    return contours;
}



// The area threshold is important so we skip the internal structures.
// Returns all contours that circle areas greater than the areaFraction of the image.
function GetHagFishContours(data, threshold, areaMin, areaMax) {
    var imageArea = data.width * data.height;
    var areaMin = areaMin * imageArea;
    var areaMax = areaMax * imageArea;

    // Loop over the cells.
    // Start at the bottom left: y up then x right.
    // (The order of sections on the hagfish slides.)
    var longContours = [];
    for (var x = 1; x < data.width; ++x) {
        for (var y = data.height-1; y > 0; --y) {
            // Look for contours crossing the xMax and yMax edges.
            var xContour = SeedIsoContour(data, x,y, x-1,y, threshold);
            if (xContour) {
                var c = new Contour();
                c.Camera = data.Camera;
                c.Threshold = threshold;
                c.SetPoints(xContour);
                c.RemoveDuplicatePoints(2);
                var area = c.GetArea();
                if (area > areaMin && area < areaMax) {
                    console.log(area/ imageArea);
                    longContours.push(c);
                }
            }

            var yContour = SeedIsoContour(data, x,y, x,y-1, threshold);
            if (yContour) {
                c = new Contour();
                c.Camera = data.Camera;
                c.Threshold = threshold;
                c.SetPoints(yContour);
                c.RemoveDuplicatePoints(2);
                area = c.GetArea();
                if (area > areaMin && area < areaMax) {
                    console.log(area / imageArea);
                    longContours.push(c);
                }
            }
        }
    }
    return longContours;
}


var HAGFISH_CONTOURS;
var VERIFIED_HAGFISH_CONTOURS = [];
var HAGFISH_STACK;
var LAST_HAGFISH_CONTOUR;
var HAGFISH_THRESHOLD;

function initHagfish() {
    HAGFISH_STACK = new Note();
    HAGFISH_STACK.Id = "5523dad0dd98b56d82d6d062";
    HAGFISH_STACK.Title = "AutoStack";
    HAGFISH_STACK.CoordinateSystem = "Pixel";
    HAGFISH_STACK.HiddenTitle = "AutoStack";
    HAGFISH_STACK.HideAnnotations = false;
    HAGFISH_STACK.Type = "Stack";
    HAGFISH_STACK.ViewerRecords = [];

    LAST_HAGFISH_CONTOUR = undefined;
    VIEWERS[0].WidgetList = [];
    eventuallyRender();
}


function acceptHagfishContours() {
    console.log("Accept");
    VERIFIED_HAGFISH_CONTOURS = HAGFISH_CONTOURS;
    HAGFISH_CONTOURS = [];

    VIEWERS[0].WidgetList = [];
    eventuallyRender();
    addVerifiedHagFishContours();
    console.log("Finished: adding contours.");
}


// We might constrain sequential contours to be similar areas.
// This could eliminate the need for manual verification.
function findHagFishSections(smooth, min, max) {
    VIEWERS[0].WidgetList = [];
    eventuallyRender();

    VERIFIED_HAGFISH_CONTOURS = [];

    var viewer1 = VIEWERS[0];
    var data1 = GetImageData(viewer1.MainView);
    SmoothDataAlphaRGB(data1, smooth);
    var histogram1 = ComputeIntensityHistogram(data1, true);
    var threshold1 = PickThreshold(histogram1);
    var contours = GetHagFishContours(data1, threshold1, min, max);

    // Sort the contours.
    HAGFISH_CONTOURS = [];
    while (contours.length) {
        var bds = contours[0].GetBounds();
        var bestIdx = 0;
        for (var i = 1; i < contours.length; ++i) {
            var bds2 = contours[i].GetBounds();
            if (bds2[2] > bds[3] && bds2[0] < bds[1]) {
                bds = bds2;
                bestIdx = i;
            }
        }
        HAGFISH_CONTOURS.push(contours.splice(bestIdx,1)[0]);
    }

    // render the first contour red
    for (var i = 0; i < HAGFISH_CONTOURS.length; ++i) {
        var red = i / HAGFISH_CONTOURS.length;
        HAGFISH_CONTOURS[i].MakePolyline([red,0,1.0-red], VIEWERS[0].MainView);
    }
    eventuallyRender();
}


function alignHagFishSections(record, contour1, contour2) {
    var trans = new PairTransformation();
    record.Transform = trans;

    var alignedContour2 = new Contour();
    alignedContour2.DeepCopy(contour2);

    // Contour2 returns the result.  It is transformed into contour1's
    // coordinate sytem, Save a copy of contour2.
    //DeformableAlignContours(contour1, alignedContour2);
    RigidAlignContours(contour1, alignedContour2);

    var c1 = contour1.GetCenter();
    var ac2 = alignedContour2.GetCenter();
    console.log("shift: "+(ac2[0]-c1[0])+", "+(ac2[1]-c1[1]));

    // I want to see the alignment for debugging.
    alignedContour2.MakePolyline([1,0,1], VIEWERS[0].MainView);

    // Now make new correlations from the transformed contour.
    var targetNumCorrelations = 40;
    var skip = Math.ceil(contour2.Length() / targetNumCorrelations);
    for (var i = 2; i < contour2.Length(); i += skip) {
        var pt1 = alignedContour2.GetPoint(i);
        if (contour1.Camera) { // aligned contour2 is in contour1
            // coordinate system.
            pt1 = contour1.Camera.ConvertPointViewerToWorld(pt1[0],pt1[1]);
        }
        var pt2 = contour2.GetPoint(i);
        if (contour2.Camera) {
            pt2 = contour2.Camera.ConvertPointViewerToWorld(pt2[0],pt2[1]);
        }

        var cor = new PairCorrelation();
        cor.SetPoint0(pt1);
        cor.SetPoint1(pt2);
        trans.Correlations.push(cor);
    }
}


function addVerifiedHagFishContours() {
    for (var i = 0; i < VERIFIED_HAGFISH_CONTOURS.length; ++i) {
        var imgData = VIEWERS[0].GetCache().Image;
        var contour = VERIFIED_HAGFISH_CONTOURS[i];
        var bds = contour.GetBounds();
        var record = new ViewerRecord();
        record.Camera = {};
        var fp = [(bds[0]+bds[1])/2, (bds[2]+bds[3])/2];
        record.Camera.Height = bds[3]-bds[2];
        record.Camera.Width = bds[2]-bds[0];
        record.Camera.Roll = 0.0;
        if (contour.Camera) {
            fp = contour.Camera.ConvertPointViewerToWorld(fp[0],fp[1]);
            var c =contour.Camera.ConvertPointViewerToWorld(bds[0],bds[2]);
            record.Camera.Width = Math.abs((fp[0]-c[0])*2);
            record.Camera.Height = Math.abs((fp[1]-c[1])*2);
            record.Camera.Roll = contour.Camera.Roll;
        }
        record.Camera.SetFocalPoint(fp);
        record.Image = imgData;
        record.Database = imgData.db;
        if (LAST_HAGFISH_CONTOUR) {
            alignHagFishSections(record,
                                 LAST_HAGFISH_CONTOUR,
                                 VERIFIED_HAGFISH_CONTOURS[i]);
        }
        LAST_HAGFISH_CONTOUR = VERIFIED_HAGFISH_CONTOURS[i];

        HAGFISH_STACK.ViewerRecords.push(record);
    }
}

// debugging
var HAGFISH_DATA;
var HAGFISH_DATA_STACK;


function saveHagFishStack() {
    var d = new Date();
    // Save this users notes in the user specific collection.
    var noteObj = JSON.stringify(HAGFISH_STACK.Serialize());
    $.ajax({
        type: "post",
        url: "/webgl-viewer/saveviewnotes",
        data: {"note" : noteObj,
               "date" : d.getTime()},
        success: function(data,status) {
            HAGFISH_DATA = data;
            HAGFISH_DATA_STACK = new Note();
            HAGFISH_DATA_STACK.Load(data);
            saDebug("Auto Stack Saved");
        },
        error: function() { saDebug( "AJAX - error() : saveviewnotes" ); },
    });
}



// !!!!!!!!!!!!!!!!!!!! I had to skip the auto highres step.
// I lost the viewer that created the image.  I sould probably 
// have the camera translate points rather than the viewer. (done)
// Change the low res contours into a high res contour.
var NEW_HAGFISH_CONTOURS = [];
function getHighResHagFishContours() {
    if (HAGFISH_CONTOURS.length == 0) {
        HAGFISH_CONTOURS = NEW_HAGFISH_CONTOURS;
        NEW_HAGFISH_CONTOURS = [];
        return;
    }
    var bds = HAGFISH_CONTOURS[0].GetBounds();
    var scale = (bds[1]-bds[0])/500;
    var roll = VIEWERS[0].GetCamera().Roll;
    VIEWERS[0].GetImage(bds, roll, scale, getHighResHagFishContours2);
}

// We need two methods because we have to wait for tiles to stop loading.
function getHighResHagFishContours2(data) {
    var threshold = HAGFISH_CONTOURS[0].Threshold;
    NEW_HAGFISH_CONTOURS.push(LongestContour(data, threshold));
    HAGFISH_CONTOURS.slice(1);
    // Do the next section.
    getHighResHagFishContours();
}


// Tasks.
// Finish the contour widget.  
//   - should we store the contour object?
//   - should we save it in screen or world coordinates?
// Convert viewer record stacks into note slides and back.
// Generate contours for those sections that do not have them.
// Add a mode state to the stack creator
//   - Single centered.
//   - Left to Right
//   - Right to left
//   - Up / down
//   - allopecia





// Toggle: Each section / viewer record has a contour widget.
// Slide view, looks through the entire stack and finds all sections
//   with the same slide.  Make a new note with multiple children notes.
// Fowarding through the stack slides?
// if a section does not have a contour, generate one.



// Process:
// 1: User selects detect.
// 2: Contours are detected and the viewer is put in a proofreading mode.
// 3: User deletes, merges and adds contours.
// 4: user changes the order.
// 5: user hits accept.
// 6: Critera for future filtering of contours is updated.

// For auto stack, maybe show each section in stack and edit individually.
// I would still need the contourWidget.
// Inserting missed sections would be difficult.
// I really need to toggle between individual display and slide display.




// TODO: 
// - Number contours to show the order (Special contour widget?)
// - Rectangle widget to create a new contour, or merge multiple contours, or
//     cut a contour.
// - Delete a contour.







// I want to avoid adding a Cache instance variable.
// I need to create the temporary object to hold pointers
// to both the cache and the tile which we are waiting for
// the image to load.  The callback only gives a single reference.



function LoadTileCallback(tile,cache) {
    this.Tile = tile;
    this.Cache = cache;
}

// Cache is now saved in tile ivar.
LoadTileCallback.prototype.HandleLoadedImage = function () {
    /* experimetation with trasparent tiles for layer
    if ( ! SA.FilterCanvas) {
        SA.FilterCanvas = new Canvas();
    }
    var canvas = SA.FilterCanvas;
    var image = this.Tile.Image;
    if (image.width != canvas.width)
        canvas.width = image.width;
    if (image.height != canvas.height)
        canvas.height = image.height;
    context.clearRect(0, 0, canvas.width, canvas.height);
    context.drawImage(image, 0, 0, canvas.width, canvas.height);
    var imageData = context.getImageData(0, 0, canvas.width, canvas.height);
    // Make white transparent.
    var d = imageData.data;
    for (var i = 0; i < d.length; i += 4) {
        var r = d[i];
        var g = d[i + 1];
        var b = d[i + 2];
        if (r == 255 && g == 255 && b == 255) {
            d[i+3] = 0;
        }
    }
    context.putImageData(imageData, 0, 0);
    image.src = canvas.toDataURL();
    */

    var curtime = new Date().getTime();
    TILESTATS.add({"name" : this.Tile.Name, "loadtime" : curtime - this.Tile.starttime });
    LoadQueueLoaded(this.Tile);
}

// If we cannot load a tile, we need to inform the cache so it can start
// loading another tile.
LoadTileCallback.prototype.HandleErrorImage = function () {
    console.log("LoadTile error " + this.Tile.Name);

    LoadQueueError(this.Tile);
}

function TileStats() {
  this.tiles = [];
}

TileStats.prototype.add = function(atile) {
  this.tiles.push(atile)
}

TileStats.prototype.report = function() {
    var total = 0;

    for(var i = 0; i < this.tiles.length; i ++) {
        total = total + this.tiles[i].loadtime;
    }

    var report = {};
    report.count = this.tiles.length;
    report.average = total / this.tiles.length;
    report.total = total;
    console.log(report);
}

function GetLoadImageFunction (callback) {
    return function () {callback.HandleLoadedImage();}
}
function GetErrorImageFunction (callback) {
    return function () {callback.HandleErrorImage();}
}

TILESTATS = new TileStats();


// Three stages to loading a tile: (texture map is created when the tile is rendered.
// 1: Create a tile object.
// 2: Initialize the texture.
// 3: onload is called indicating the image has been loaded.
function Tile(x, y, z, level, name, cache) {
    // This should be implicit.
    //this is just for debugging
    //this.Id = x + (y<<level)
    //
    this.Cache = cache;
    this.X = x;
    this.Y = y;
    this.Z = z;
    this.Level = level;
    this.Children = [];
    this.Parent = null;
    this.LoadState = 0;

    this.Name = name;
    this.Texture = null;
    this.TimeStamp = SA.TimeStamp;
    this.BranchTimeStamp = SA.TimeStamp;

    this.Matrix = mat4.create();
    mat4.identity(this.Matrix);
    this.Matrix[14] = z * cache.RootSpacing[2] -(0.1 * this.Level);

    // Default path is to shared geometry and move/scale it with the matrix.
    // The shared polygon is a square [(0,0),(1,0),(1,1),(0,1)]
    // The matrix transforms it into world coordinates.
    if ( ! cache.Warp) {
        // TODO: We should have a simple version of warp that creates this matrix for us.
        // Use shared buffers and place them with the matrix transformation.
        var xScale = cache.TileDimensions[0] * cache.RootSpacing[0] / (1 << this.Level);
        var yScale = cache.TileDimensions[1] * cache.RootSpacing[1] / (1 << this.Level);
        this.Matrix[0] = xScale;
        this.Matrix[5] = -yScale;
        this.Matrix[12] = this.X * xScale;
        this.Matrix[13] = (this.Y+1) * yScale;
        this.Matrix[15] = 1.0;

        if (GL) {
            // These tiles share the same buffers.  Do not crop when there is no warp.
            this.VertexPositionBuffer = tileVertexPositionBuffer;
            this.VertexTextureCoordBuffer = tileVertexTextureCoordBuffer;
            this.CellBuffer = tileCellBuffer;
        }
    } else {
        // Warp model.
        this.CreateWarpBuffer(cache.Warp);
    }

    ++SA.NumberOfTiles;
}

Tile.prototype.destructor=function()
{
    --SA.NumberOfTiles;
    this.DeleteTexture();
    delete this.Matrix;
    this.Matrix = null;
    if (this.Image) {
        delete this.Image;
        this.Image = 0;
    }
    for (var i = 0; i < 4; ++i) {
        if (this.Children[i] != null) {
            this.Children[i].destructor();
            this.Children[i] = null;
        }
    }
}


// Youy have to call LoadQueueUpdate after adding tiles.
// Add the first unloaded ancestor to the load queue.
Tile.prototype.LoadQueueAdd = function() {
  // Record that the tile is used (for prioritizing loading and pruning).
  // Mark all lower res tiles so they will be loaded inthe correct order.
  var tmp = this;
  while (tmp && tmp.TimeStamp != SA.TimeStamp) {
    tmp.TimeStamp = SA.TimeStamp;
    tmp = tmp.Parent;
  }

  if (this.LoadState != 0) { // == 2
    // This tiles is already in the load queue or loaded.
    return;
  }

  // Now I want progressive loading so I will not add tiles to the queue if their parents are not completely loaded.
  // I could add all parent and children to the que at the same time, but I have seen children rendered before parents
  // (levels are skipped in progresive updata).  So, lets try this.
  // Now that I am prioritizing the queue on the tiles time stamp and level,  the previous issues should be resolved.
  if (this.Parent) {
    if (this.Parent.LoadState == 0) {
      // Not loaded and not in the queue.
      return this.Parent.LoadQueueAdd();
    } else if (this.Parent.LoadState == 1) {
      // Not loaded but in the queue
      return;
    }
  }

  // The tile's parent is loaded.  Add the tile to the load queue.
  LoadQueueAddTile(this);
}







// This is for connectome stitching.  It uses texture mapping
// to dynamically warp images.  It only works with webGL.
Tile.prototype.CreateWarpBuffer = function (warp) {
  // Compute the tile bounds.
  var tileDimensions = this.Cache.TileDimensions;
  var rootSpacing = this.Cache.RootSpacing;
  var p = (1 << this.Level);
  var size = [rootSpacing[0]*tileDimensions[0]/p, rootSpacing[1]*tileDimensions[1]/p];
  var bds = [size[0]*this.X, size[0]*(this.X+1),
             size[1]*this.Y, size[1]*(this.Y+1),
             this.Level, this.Level];

  // Tile geometry buffers.
  var vertexPositionData = [];
  var tCoordsData = [];
  var cellData = [];

  warp.CreateMeshFromBounds(bds, vertexPositionData, tCoordsData, cellData);

  this.VertexTextureCoordBuffer = GL.createBuffer();
  GL.bindBuffer(GL.ARRAY_BUFFER, this.VertexTextureCoordBuffer);
  GL.bufferData(GL.ARRAY_BUFFER, new Float32Array(tCoordsData), GL.STATIC_DRAW);
  this.VertexTextureCoordBuffer.itemSize = 2;
  this.VertexTextureCoordBuffer.numItems = tCoordsData.length / 2;

  this.VertexPositionBuffer = GL.createBuffer();
  GL.bindBuffer(GL.ARRAY_BUFFER, this.VertexPositionBuffer);
  GL.bufferData(GL.ARRAY_BUFFER, new Float32Array(vertexPositionData), GL.STATIC_DRAW);
  this.VertexPositionBuffer.itemSize = 3;
  this.VertexPositionBuffer.numItems = vertexPositionData.length / 3;

  this.CellBuffer = GL.createBuffer();
  GL.bindBuffer(GL.ELEMENT_ARRAY_BUFFER, this.CellBuffer);
  GL.bufferData(GL.ELEMENT_ARRAY_BUFFER, new Uint16Array(cellData), GL.STATIC_DRAW);
  this.CellBuffer.itemSize = 1;
  this.CellBuffer.numItems = cellData.length;
}



// This starts the loading of the tile.
// Loading is asynchronous, so the tile will not
// immediately change its state.
Tile.prototype.StartLoad = function (cache) {
    if (this.LoadState >= 2) {
        return;
    }

    // Reusing the image caused problems.
    //if (this.Image == null) {
    this.Image = new Image();

    this.starttime = new Date().getTime();
    // Setup callbacks
    var callback = new LoadTileCallback(this, cache);
    this.Image.onload = GetLoadImageFunction(callback);
    this.Image.onerror = GetErrorImageFunction(callback);
    // This starts the loading.

    if (SA.TileLoader == "websocket") {
        this.LoadWebSocket(cache);
    } else {
        // "http"
        this.LoadHttp(cache);
    }
}

Tile.prototype.LoadHttp = function (cache) {
    // For http simply set the data url and wait 
    if (cache.TileSource) {
        // This should eventually displace all other methods
        // of getting the tile source.

        this.Name  = cache.TileSource.getTileUrl(this.Level,
                                                 this.X, this.Y, this.Z);
        // Name is just for debugging.
        this.Image.src = this.Name;

        return;

    }

    // Legacy
    var imageSrc;
    if (cache.Image.type && cache.Image.type == "stack") {
        imageSrc = cache.GetSource() + this.Name + ".png";
    } else {
        imageSrc = cache.GetSource() + this.Name + ".jpg";
    }

    if (cache.UseIIP) {
        var level = this.Level + 2;
        var xDim = Math.ceil(cache.Image.dimensions[0] / (cache.Image.TileSize << (cache.Image.levels - this.Level - 1)));
        var idx = this.Y * xDim + this.X;
        imageSrc = "http://iip.slide-atlas.org/iipsrv.fcgi?FIF=" + cache.Image.filename + "&jtl=" + level + "," + idx;
    }

    this.Image.src = imageSrc;
}


Tile.prototype.LoadWebSocket = function (cache) {
    // Right now doing exact same thing
    var name = '';
    if (cache.Image.type && cache.Image.type == "stack") {
        name = this.Name + ".png";
    } else {
        name = this.Name + ".jpg";
    }

    var image = cache.Image._id;

    ws.FetchTile(name, image, cache, this.Image);
}

Tile.prototype.Draw = function (program, context) {
  // Load state 0 is: Not loaded and not scheduled to be loaded yet.
  // Load state 1 is: not loaded but in the load queue.
  if ( this.LoadState != 3) {
    // This should never happen.
    return;
  }

  if (GL) {
    if (this.Texture == null) {
      this.CreateTexture();
    }
    // These are the same for every tile.
    // Vertex points (shifted by tiles matrix)
    context.bindBuffer(GL.ARRAY_BUFFER, this.VertexPositionBuffer);
    // Needed for outline ??? For some reason, DrawOutline did not work
    // without this call first.
    context.vertexAttribPointer(imageProgram.vertexPositionAttribute,
                          this.VertexPositionBuffer.itemSize,
                          GL.FLOAT, false, 0, 0);     // Texture coordinates
    context.bindBuffer(GL.ARRAY_BUFFER, this.VertexTextureCoordBuffer);
    context.vertexAttribPointer(imageProgram.textureCoordAttribute,
                          this.VertexTextureCoordBuffer.itemSize,
                          GL.FLOAT, false, 0, 0);
    // Cell Connectivity
    context.bindBuffer(GL.ELEMENT_ARRAY_BUFFER, this.CellBuffer);

      // Texture
    context.activeTexture(GL.TEXTURE0);
    context.bindTexture(GL.TEXTURE_2D, this.Texture);

    context.uniform1i(program.samplerUniform, 0);
    // Matrix that tranforms the vertex p
    context.uniformMatrix4fv(program.mvMatrixUniform, false, this.Matrix);

    context.drawElements(GL.TRIANGLES, this.CellBuffer.numItems, GL.UNSIGNED_SHORT, 0);
  } else {
    // It is harder to flip the y axis in 2d canvases because the image turns upside down too.
    // WebGL handles this by flipping the texture coordinates.  Here we have to
    // translate the tiles to the correct location.
    context.save(); // Save the state of the transform so we can restore for the next tile.

    // Map tile to world.
    // Matrix is world to 0-1.
    context.transform(this.Matrix[0], this.Matrix[1],
                      this.Matrix[4], this.Matrix[5],
                      this.Matrix[12], this.Matrix[13]);


    // Flip the tile upside down, but leave it in the same place
    context.transform(1.0,0.0, 0.0,-1.0, 0.0, 1.0);

    // map pixels to Tile
    var tileSize = this.Cache.Image.TileSize;
    // This should not be necessary, quick hack around a bug in __init__.py
    if ( tileSize == undefined) {
      tileSize = 256;
    }
    context.transform(1.0/tileSize, 0.0, 0.0, 1.0/tileSize, 0.0, 0.0);
    context.drawImage(this.Image,0,0);

    //  Transform to map (0->1, 0->1)
    context.restore();
  }
}

Tile.prototype.CreateTexture = function () {
  if (this.Texture != null) { return;}

  ++SA.NumberOfTextures; // To determine when to prune textures.
  this.Texture = GL.createTexture();
  var texture = this.Texture;
  //alert(tile);
  GL.pixelStorei(GL.UNPACK_FLIP_Y_WEBGL, true);
  GL.bindTexture(GL.TEXTURE_2D, texture);
  GL.texImage2D(GL.TEXTURE_2D, 0, GL.RGBA, GL.RGBA, GL.UNSIGNED_BYTE, this.Image);
  GL.texParameteri(GL.TEXTURE_2D, GL.TEXTURE_MAG_FILTER, GL.LINEAR);
  GL.texParameteri(GL.TEXTURE_2D, GL.TEXTURE_MIN_FILTER, GL.LINEAR);
  GL.texParameteri(GL.TEXTURE_2D, GL.TEXTURE_WRAP_S, GL.CLAMP_TO_EDGE);
  GL.texParameteri(GL.TEXTURE_2D, GL.TEXTURE_WRAP_T, GL.CLAMP_TO_EDGE);
  GL.bindTexture(GL.TEXTURE_2D, null);
}

Tile.prototype.DeleteTexture = function () {
  if (this.Texture) {
    --SA.NumberOfTextures; // To determine when to prune textures.
    GL.deleteTexture(this.Texture);
    this.Texture = null;
  }
}

(function () {
    "use strict";

// I am adding a levels with grids to index tiles in addition
// to the tree.  Eventually I want to get rid fo the tree.
// I am trying to get rid of the roots now.

// A stripped down source object.
// A source object must have a getTileUrl method.
// It can have any instance variables it needs to
// compute the URL.
SA.SlideAtlasSource = function() {
    this.Prefix = undefined;

    // Higher levels are higher resolution.
    // x, y, slide are integer indexes of tiles in the grid.
    this.getTileUrl = function(level, x, y, z) {
        var name = this.Prefix + "t";
        while (level  > 0) {
            --level;
            var cx = (x>>level)&1;
            var cy = (y>>level)&1;
            var childIdx = cx+(2*cy);
            if (childIdx == 0) {name += "q";}
            if (childIdx == 1) {name += "r";}
            if (childIdx == 2) {name += "t";}
            if (childIdx == 3) {name += "s";}
        }
        name = name + ".jpg"
        return name;
    }
}

SA.GigamacroSource = function() {
    this.Prefix = "http://www.gigamacro.com/content/AMNH/unit_box_test2_05-01-2015/zoomify/"
    this.GridSizeDebug = [[1,1],[2,2],[4,3],[7,5],[14,9],[28,17],[56,34]];

    this.setDimensions = function(xDim,yDim) {
        this.Dimensions = [xDim, yDim];
        this.GridSize = [];
        this.Levels = 0;
        while (true) {
            var gridLevelDim = [Math.ceil(xDim/256), Math.ceil(yDim/256)];
            this.GridSize.splice(0,0,gridLevelDim);
            this.Levels += 1;
            if (gridLevelDim[0] == 1 && gridLevelDim[1] == 1) return;
            xDim = xDim / 2;
            yDim = yDim / 2;
        }
    }

    // Higher levels are higher resolution.
    // x, y, slide are integer indexes of tiles in the grid.
    this.getTileUrl = function(level, x, y, z) {
        var g = this.GridSize[level];
        if (x < 0 || x >= g[0] || y < 0 || y >= g[1]) {
            return "";
        }
        var num = y*g[0] + x;
        for (var i = 0; i < level; ++i) {
            g = this.GridSize[i];
            num += g[0]*g[1];
        }
        var tileGroup = Math.floor(num / 256);
        var name = this.Prefix+"TileGroup"+tileGroup+'/'+level+'-'+x+'-'+y+".jpg";
        return name;
    }
}

SA.GirderSource = function() {
    this.height = 18432;
    this.width = 18432;
    this.tileSize = 256;
    this.minLevel = 0;
    this.maxLevel = 7;
    this.getTileUrl = function (level,x,y) {
        return 'http://lemon:8081/api/v1/item/564e42fe3f24e538e9a20eb9/tiles/zxy/'
            + level + '/' + x + '/' + y;
    }
}

// Our subdivision of leaves is arbitrary.
SA.IIIFSource = function() {
    this.Prefix = "http://ids.lib.harvard.edu/ids/view/Converter?id=834753&c=jpgnocap";
    this.TileSize = 256;

    this.setDimensions = function(xDim,yDim) {
        this.Dimensions = [xDim, yDim];
        this.GridSize = [];
        this.Levels = 0;
        while (true) {
            var gridLevelDim = [Math.ceil(xDim/256), Math.ceil(yDim/256)];
            this.Levels += 1;
            if (gridLevelDim[0] == 1 && gridLevelDim[1] == 1) return;
            xDim = xDim / 2;
            yDim = yDim / 2;
        }
    }

    // Higher levels are higher resolution. (0 is the root).
    // x, y, slide are integer indexes of tiles in the grid.
    this.getTileUrl = function(level, x, y, z) {
        // compute the dimensions of this resolution.
        var x0 = x * 256;
        var y0 = y * 256;
        var x1 = x0 + 256;
        var y1 = y0 + 256;
        // crop the tile
        var res = this.Levels - level - 1;
        var dx = this.Dimensions[0] >> res;
        var dy = this.Dimensions[1] >> res;
        if (x1 > dx) { x1 = dx; }
        if (y1 > dy) { y1 = dy; }
        dx = x1-x0;
        dy = y1-y0;
        // Compute the scale.
        res = 1.0 / (1 << res);

        var name = this.Prefix+"&s="+res+"&r=0&x="+x0+"&y="+y0+"&w="+dx+"&h="+dy;
        return name;
    }
}


SA.DanielSource = function() {
    this.Prefix = "http://dragon.krash.net:2009/data/1"
    this.MinLevel = 0;
    this.MaxLevel = 7;

    // Higher levels are higher resolution.
    // x, y, slide are integer indexes of tiles in the grid.
    this.getTileUrl = function(level, x, y, z) {
        if (z < this.MinLevel) {return "";}
        if (z > this.MaxLevel) {return "";}
        var name = this.Prefix + level + '-' + x + '-' + y;
        return name;
    }
}


SA.IIPSource = function() {
    // Higher levels are higher resolution.
    // x, y, slide are integer indexes of tiles in the grid.
    this.getTileUrl = function(level, x, y, z) {
        // The number if tiles in a row for this level grid.
        var xDim = Math.ceil(this.ImageWidth /
                             (this.TileSize << (this.NumLevels - z - 1)));
        var idx = y * xDim + x;
        imageSrc = this.Prefix + (z+2) + "," + idx;
    }

    this.ImageWidth = 0;
    this.TileSize = 256;
    this.NumLevels = 0;
}



//==============================================================================

//==============================================================================

SA.FindCache = function(image) {
    // Look through existing caches and reuse one if possible
    for (var i = 0; i < SA.Caches.length; ++i) {
        if (SA.Caches[i].Image._id == image._id) {
            return SA.Caches[i];
        }
    }
    var cache = new Cache();

    // Special case to link to IIIF? Harvard art..
    //http://ids.lib.harvard.edu/ids/view/Converter?id=834753&c=jpgnocap&s=1&r=0&x=0&y=0&w=600&h=600

    if (image._id == "556e0ad63ed65909dbc2e383") {
        var tileSource = new SA.IIIFSource ();
        tileSource.Prefix = "http://ids.lib.harvard.edu/ids/view/Converter?id=47174896";
        // "width":2087,"height":2550,"scale_factors":[1,2,4,8,16,32],
        tileSource.setDimensions(2087,2550);
        image.levels = tileSource.Levels;
        image.dimensions = tileSource.Dimensions;
        image.bounds = [0,image.dimensions[0]-1, 0,image.dimensions[1]-1];
        cache.SetImageData(image);
        cache.TileSource = tileSource;
        return cache;
    }

    if (image._id == "556c89a83ed65909dbc2e317") {
        var tileSource = new SA.IIIFSource ();
        tileSource.Prefix = "http://ids.lib.harvard.edu/ids/view/Converter?id=834753&c=jpgnocap";
        tileSource.setDimensions(3890,5787);
        image.levels = tileSource.Levels;
        image.dimensions = tileSource.Dimensions;
        image.bounds = [0,image.dimensions[0]-1, 0,image.dimensions[1]-1];
        cache.SetImageData(image);
        cache.TileSource = tileSource;
        return cache;
    }

    // Special case to link to gigamacro.
    if (image._id == "555a1af93ed65909dbc2e19a") {
        var tileSource = new SA.GigamacroSource ();
        tileSource.Prefix = "http://www.gigamacro.com/content/AMNH/unit_box_test2_05-01-2015/zoomify/"
        tileSource.setDimensions(14316,8459);
        image.levels = tileSource.Levels;
        image.dimensions = tileSource.Dimensions;
        image.bounds = [0,image.dimensions[0]-1, 0,image.dimensions[1]-1];
        cache.SetImageData(image);
        cache.TileSource = tileSource;
        return cache;
    }
    if (image._id == "555a5e163ed65909dbc2e19d") {
        var tileSource = new SA.GigamacroSource ();
        tileSource.Prefix = "http://www.gigamacro.com/content/cmnh/redbug_bottom/zoomify/"
        tileSource.setDimensions(64893, 40749);
        image.levels = tileSource.Levels;
        image.dimensions = tileSource.Dimensions;
        image.bounds = [0,image.dimensions[0]-1, 0,image.dimensions[1]-1];
        cache.SetImageData(image);
        cache.TileSource = tileSource;
        return cache;
    }
    if (image._id == "555b66483ed65909dbc2e1a0") {
        var tileSource = new SA.GigamacroSource ();
        tileSource.Prefix = "http://www.gigamacro.com/content/cmnh/redbug_top/zoomify/"
        tileSource.setDimensions(64893,40749);
        image.levels = tileSource.Levels;
        image.dimensions = tileSource.Dimensions;
        image.bounds = [0,image.dimensions[0]-1, 0,image.dimensions[1]-1];
        cache.SetImageData(image);
        cache.TileSource = tileSource;
        return cache;
    }
    if (image._id == "555b664d3ed65909dbc2e1a3") {
        var tileSource = new SA.GigamacroSource ();
        tileSource.Prefix = "http://www.gigamacro.com/content/AMNH/drawer_unit_box_test_05-01-2015_08-52-29_0000/zoomify/"
        tileSource.setDimensions(11893,7322);
        image.levels = tileSource.Levels;
        image.dimensions = tileSource.Dimensions;
        image.bounds = [0,image.dimensions[0]-1, 0,image.dimensions[1]-1];
        cache.SetImageData(image);
        cache.TileSource = tileSource;
        return cache;
    }
    if (image._id == "555b66523ed65909dbc2e1a6") {
        var tileSource = new SA.GigamacroSource ();
        tileSource.Prefix = "http://www.gigamacro.com/content/AMNH/full_drawer_test_05-01-2015_09-04-17_0000/zoomify/"
        tileSource.setDimensions(44245,34013);
        image.levels = tileSource.Levels;
        image.dimensions = tileSource.Dimensions;
        image.bounds = [0,image.dimensions[0]-1, 0,image.dimensions[1]-1];
        cache.SetImageData(image);
        cache.TileSource = tileSource;
        return cache;
    }
    if (image._id == "555c93973ed65909dbc2e1b5") {
        var tileSource = new SA.GigamacroSource ();
        tileSource.Prefix = "http://www.gigamacro.com/content/gigamacro/impasto_polarized/zoomify/";
        tileSource.setDimensions(76551, 57364);
        image.levels = tileSource.Levels;
        image.dimensions = tileSource.Dimensions;
        image.bounds = [0,image.dimensions[0]-1, 0,image.dimensions[1]-1];
        cache.SetImageData(image);
        cache.TileSource = tileSource;
        return cache;
    }
    if (image._id == "555c93913ed65909dbc2e1b2") {
        var tileSource = new SA.GigamacroSource ();
        tileSource.Prefix = "http://www.gigamacro.com/content/gigamacro/restoration_polaraized/zoomify/";
        tileSource.setDimensions(55884, 55750);
        image.levels = tileSource.Levels;
        image.dimensions = tileSource.Dimensions;
        image.bounds = [0,image.dimensions[0]-1, 0,image.dimensions[1]-1];
        cache.SetImageData(image);
        cache.TileSource = tileSource;
        return cache;
    }

    if (image._id == "555f46503ed65909dbc2e1b8") {
        var tileSource = new SA.GigamacroSource ();
        tileSource.Prefix = "http://www.gigamacro.com/content/gigamacro/eucalyptus_10-31-2010/zoomify/";
        tileSource.setDimensions(38392, 45242);
        image.levels = tileSource.Levels;
        image.dimensions = tileSource.Dimensions;
        image.bounds = [0,image.dimensions[0]-1, 0,image.dimensions[1]-1];
        cache.SetImageData(image);
        cache.TileSource = tileSource;
        return cache;
    }
    if (image._id == "555f46553ed65909dbc2e1bb") {
        var tileSource = new SA.GigamacroSource ();
        tileSource.Prefix = "http://www.gigamacro.com/content/Bunton/leaf_fossil_04-30-2015/zoomify/";
        tileSource.setDimensions(22590, 10793);
        image.levels = tileSource.Levels;
        image.dimensions = tileSource.Dimensions;
        image.bounds = [0,image.dimensions[0]-1, 0,image.dimensions[1]-1];
        cache.SetImageData(image);
        cache.TileSource = tileSource;
        return cache;
    }
    if (image._id == "555f465a3ed65909dbc2e1be") {
        var tileSource = new SA.GigamacroSource ();
        tileSource.Prefix = "http://www.gigamacro.com/content/formsandsurfaces/maiden_hair_fern_v1_7-6-2012/zoomify/";
        tileSource.setDimensions(22092, 22025);
        image.levels = tileSource.Levels;
        image.dimensions = tileSource.Dimensions;
        image.bounds = [0,image.dimensions[0]-1, 0,image.dimensions[1]-1];
        cache.SetImageData(image);
        cache.TileSource = tileSource;
        return cache;
    }
    if (image._id == "555f46623ed65909dbc2e1c1") {
        var tileSource = new SA.GigamacroSource ();
        tileSource.Prefix = "http://www.gigamacro.com/content/gigamacro/nancy_plants_7-28-2014/zoomify/";
        tileSource.setDimensions(40687, 69306);
        image.levels = tileSource.Levels;
        image.dimensions = tileSource.Dimensions;
        image.bounds = [0,image.dimensions[0]-1, 0,image.dimensions[1]-1];
        cache.SetImageData(image);
        cache.TileSource = tileSource;
        return cache;
    }
    // It is really time to implement this in the database ...


    cache.SetImageData(image);

    return cache;
}


//==============================================================================
function CacheLevel(xGridDim, yGridDim) {
    this.Tiles = new Array(xGridDim*yGridDim);
    this.GridDims = [xGridDim, yGridDim];
}
// No bounds checking.
CacheLevel.prototype.SetTile=function(tile){
    return this.Tiles[tile.X+(tile.Y*this.GridDims[0])] = tile;
}
CacheLevel.prototype.GetTile=function(x, y){
    return this.Tiles[x+(y*this.GridDims[0])];
}


//==============================================================================
function Cache() {
    //  this.UseIIP = Boolean(image.filename !== undefined && image.filename.split(".")[1] === 'ptif');
    this.UseIIP = false;
    this.Levels = [];

    // Keep a global list for pruning tiles.
    SA.Caches.push(this);
    this.NumberOfSections = 1;
}

Cache.prototype.destructor=function()
{
}

Cache.prototype.SetImageData = function(image) {

    if ( ! image.TileSize) {
        image.TileSize = 256;
    }
    
    this.Image = image;

    this.Levels = new Array(image.levels);
    for ( var i = 0; i < image.levels; ++i) {
        var level = image.levels-1-i;
        this.Levels[i] = new CacheLevel(
            Math.ceil(image.dimensions[0]/(image.TileSize<<level)),
            Math.ceil(image.dimensions[1]/(image.TileSize<<level)));
    }

    if ( ! this.TileSource) {
        // TODO:  This should not be here.
        // Source should be initialized someplace else.
        // Other sources have to overwrite this default.
        this.TileSource = new SA.SlideAtlasSource();
        this.TileSource.Prefix = "/tile?img="+image._id+"&db="+image.database+"&name=";
    }
    this.Warp = null;
    this.RootSpacing = [1<<(image.levels-1), 1<<(image.levels-1), 10.0];

    if (image.type && image.type == "stack") {
        this.NumberOfSections = image.dimensions[2];
        this.TileDimensions = [image.dimensions[0], image.dimensions[1]];
        var qTile;
        for (var slice = 1; slice <= this.NumberOfSections; ++slice) {
            qTile = this.GetTile(slice, 0, 0);
            qTile.LoadQueueAdd();
        }
        LoadQueueUpdate();
    } else {
        this.TileDimensions = [image.TileSize, image.TileSize];
        this.NumberOfSections = 1;
    }
}

Cache.prototype.SetScene = function(scene) {
    var image = {
        TileSize: scene.tileSize,
        levels:   scene.numLevels,
        dimensions: scene.dimensions,
        bounds: [0, scene.dimensions[0], 0, scene.dimensions[1]]};

    this.SetImageData(image);
    this.TileSource = scene;
}



Cache.prototype.GetLeafSpacing = function() {
  return this.RootSpacing[0] / (1 << (this.Image.levels-1));
}

Cache.prototype.GetBounds = function() {
  if (this.Image && this.Image.bounds) {
    return this.Image.bounds;
  }
  return [0,10000,0,10000]
}

// This method converts a point in image coordinates to a point in world coordinates.
Cache.prototype.ImageToWorld = function(imagePt) {
  if (this.Warp) {
    return this.Warp.ImageToWorld(imagePt);
  }
  // Just shift by the origin.
  // Assume spacing is 1.
  // This should be a simple matrix version of warp.
  return [imagePt[0]+this.Origin[0], imagePt[1]+this.Origin[1]];
}

// This method converts a point in world coordinates to a point in cache-image coordinates.
Cache.prototype.WorldToImage = function(worldPt) {
  if (this.Warp) {
    return this.Warp.WorldToImage(worldPt);
  }
  // Just shift by the origin.
  // Assume spacing is 1.
  // TODO:
  // This should be a simple matrix version of warp.
  return [worldPt[0]-this.Origin[0], worldPt[1]-this.Origin[1]];
}


Cache.prototype.GetSource=function()
{
    return this.Source;
}

Cache.prototype.LoadRoots = function () {
    var qTile;
    if ( this.Image.dimensions == undefined) {
        return;
    }
    for (var slice = 1; slice <= this.Image.dimensions[2]; ++slice) {
        qTile = this.GetTile(slice, 0, 0);
        qTile.LoadQueueAdd();
    }
    LoadQueueUpdate();
    return;
}


// ------ I think this method really belongs in the view! -----------
// This could get expensive because it is called so often.
// Eventually I want a quick coverage test to exit early.
// iPad flag includes low resolution ancestors to get rid of white lines between tiles.
// Tiles is actually the return value.  It is not used for anything else.
Cache.prototype.ChooseTiles = function(camera, slice, tiles) {
    // I am prioritizing tiles in the queue by time stamp.
    // Loader sets the the tiles time stamp.
    // Time stamp only progresses after a whole render.
    AdvanceTimeStamp();

    // I am putting this here to avoid deleting tiles
    // in the rendering list.
    Prune();


    // Pick a level to display.
    //var fast = document.getElementById("fast").checked;
    // level 0 is the root.  This chooses too high a level (resolution).
    // WHen I fixed it, the snap between levels was too noticable.
    // THis must be a problem with creation of the pyramid!!!!!
    var canvasHeight = camera.ViewportHeight;
    var tmp = this.TileDimensions[1]*this.RootSpacing[1] / camera.Height;
    //if (fast) {
    //  tmp = tmp * 0.5;
    //}
    tmp = tmp * canvasHeight / this.TileDimensions[1];
    var level = 0;
    while (tmp > 1.0) {
        ++level;
        tmp = tmp * 0.5;
    }
    if (level >= this.Image.levels) {
        level = this.Image.levels - 1;
    }
    // Alternative code
    //var level = this.Image.levels - 1; // The highest resolution / leaves
    //var canvasHeight = camera.ViewportHeight;
    //// At the current level(0), each screen pixel covers this many image
    //// pixels. If this is above 1, then we would render too many pixels.
    //var pixelRatio = camera.Height / camera.ViewportHeight;
    //while (pixelRatio > 1.1 && level > 0) { // a little slop.
    //    pixelRatio = pixelRatio * 0.5;
    //    level = level - 1;
    //}

    // Compute the world bounds of camera view.
    var xMax = 0.0;
    var yMax = 0.0;
    var hw = camera.GetWidth()*0.5;
    var hh = camera.GetHeight()*0.5;
    var roll = camera.Roll;
    var s = Math.sin(roll);
    var c = Math.cos(roll);
    var rx, ry;
    // Choose a camera corner and rotate. (Center of bounds in origin).
    rx = hw*c + hh*s;
    ry = hh*c - hw*s;
    // Expand bounds.
    if (xMax < rx)  { xMax = rx;}
    if (xMax < -rx) { xMax = -rx;}
    if (yMax < ry)  { yMax = ry;}
    if (yMax < -ry) { yMax = -ry;}
    // Now another corner (90 degrees away).
    rx = hw*c - hh*s;
    ry = -hh*c - hw*s;
    // Expand bounds.
    if (xMax < rx)  { xMax = rx;}
    if (xMax < -rx) { xMax = -rx;}
    if (yMax < ry)  { yMax = ry;}
    if (yMax < -ry) { yMax = -ry;}

    var bounds = [];
    bounds[0] = camera.FocalPoint[0]-xMax;
    bounds[1] = camera.FocalPoint[0]+xMax;
    bounds[2] = camera.FocalPoint[1]-yMax;
    bounds[3] = camera.FocalPoint[1]+yMax;

    // Adjust bounds to compensate for warping.
    if (this.Warp) {
        // If this is too slow (occurs every render) we can estimate.
        var iPt = this.WorldToImage([bounds[0], bounds[2]]);
        if ( ! iPt) { tiles.length = 0; return tiles;}
        var iBounds = [iPt[0], iPt[0], iPt[1], iPt[1]];
        iPt = this.WorldToImage([bounds[1], bounds[2]]);
        if ( ! iPt) { tiles.length = 0; return tiles;}
        if (iBounds[0] > iPt[0]) { iBounds[0] = iPt[0]; }
        if (iBounds[1] < iPt[0]) { iBounds[1] = iPt[0]; }
        if (iBounds[2] > iPt[1]) { iBounds[2] = iPt[1]; }
        if (iBounds[3] < iPt[1]) { iBounds[3] = iPt[1]; }
        iPt = this.WorldToImage([bounds[0], bounds[3]]);
        if ( ! iPt) { tiles.length = 0; return tiles;}
        if (iBounds[0] > iPt[0]) { iBounds[0] = iPt[0]; }
        if (iBounds[1] < iPt[0]) { iBounds[1] = iPt[0]; }
        if (iBounds[2] > iPt[1]) { iBounds[2] = iPt[1]; }
        if (iBounds[3] < iPt[1]) { iBounds[3] = iPt[1]; }
        iPt = this.WorldToImage([bounds[1], bounds[3]]);
        if ( ! iPt) { tiles.length = 0; return tiles;}
        if (iBounds[0] > iPt[0]) { iBounds[0] = iPt[0]; }
        if (iBounds[1] < iPt[0]) { iBounds[1] = iPt[0]; }
        if (iBounds[2] > iPt[1]) { iBounds[2] = iPt[1]; }
        if (iBounds[3] < iPt[1]) { iBounds[3] = iPt[1]; }
        bounds = iBounds;
    }

    // Some logic for progressive rendering is in the loader:
    // Do not load a tile if its parent is not loaded.

    var tile;
    var tileIds;
    var tiles = [];
    // TODO: Make a "GetVisibleTiles" method.
    // Render all tiles from low res to high.
    // Although this is extra work, it covers up cracks.
    // Rendering just level 0 (root) should be enough, but that
    // messed up progressive rendering logic in section.js.
    // Just do this until I unify the progressive rendering
    // Probably in this method. (check is loaded).
    for (var i = level; i >=0; --i) {
        tileIds = this.GetVisibleTileIds(i, bounds);
        for (var j = 0; j < tileIds.length; ++j) {
            tile = this.GetTile(slice, i, tileIds[j]);
            // If the tile is loaded or loading,
            // this does nothing.
            if (tile) {
                tile.LoadQueueAdd();
                tiles.push(tile);
            }
        }
    }

    LoadQueueUpdate();

    return tiles;
}

// Get ids of all visible tiles (including ones that have not been
// loaded yet.)
Cache.prototype.GetVisibleTileIds = function (level, bounds) {
    // Intersect the view bounds with the image bounds.
    // The ptif reader gives wrong times when out of bounds.
    if ( this.Image.bounds) {
        bounds[0] = Math.max(bounds[0], this.Image.bounds[0]);
        bounds[1] = Math.min(bounds[1], this.Image.bounds[1]);
        bounds[2] = Math.max(bounds[2], this.Image.bounds[2]);
        bounds[3] = Math.min(bounds[3], this.Image.bounds[3]);
    }

    var id;
    var idList = [];
    var dim = 1 << level;
    var bds = [];
    bds[0] = Math.floor(bounds[0] * dim / (this.TileDimensions[0]*this.RootSpacing[0]));
    bds[1] = Math.ceil(bounds[1] * dim / (this.TileDimensions[0]*this.RootSpacing[0])) - 1.0;
    bds[2] = Math.floor(bounds[2] * dim / (this.TileDimensions[1]*this.RootSpacing[1]));
    bds[3] = Math.ceil(bounds[3] * dim / (this.TileDimensions[1]*this.RootSpacing[1])) - 1.0;
    // I am allowing level 0 to have a grid of tiles (not just one root).
    // This will not work for the trsq tile names, but is used for grid
    // indexing of tiles that every other server uses.
    // This will only work NOW for the y axis (the case I am trying to
    // solve).  To work for the z axis, tile indexing has to change.
    // Javascript currently can handle 16 levels safely (32 bits) with the
    // current indexing scheme.

    /*
    for (var y = bds[2]; y <= bds[3]; ++y) {
      for (var x = bds[0]; x <= bds[1]; ++x) {
        id = x | (y << level);
        idList.push(id);
      }
    }
    */
    // Experiment: Lets try sorting from middle to outside to simulate
    // fovia sorted request priority.
    // Reverse order of priority.
    var cx = Math.floor((bds[0] + bds[1]) * 0.5);
    var cy = Math.floor((bds[2] + bds[3]) * 0.5);
    var radius = Math.max((cx-bds[0]),(bds[1]-cx),(cy-bds[2]),(bds[3]-cy));
    var x,y,i;
    while (radius > 0) {
        for (i = -radius; i < radius; ++i) {
            x = cx-radius;
            y = cy-i;
            if (x>=bds[0] && x<=bds[1] && y>=bds[2] && y<=bds[3]) {
                idList.push(x | (y << level));
            }
            x = cx+i;
            y = cy-radius;
            if (x>=bds[0] && x<=bds[1] && y>=bds[2] && y<=bds[3]) {
                idList.push(x | (y << level));
            }
            x = cx+radius;
            y = cy+i;
            if (x>=bds[0] && x<=bds[1] && y>=bds[2] && y<=bds[3]) {
                idList.push(x | (y << level));
            }
            x = cx-i;
            y = cy+radius;
            if (x>=bds[0] && x<=bds[1] && y>=bds[2] && y<=bds[3]) {
                idList.push(x | (y << level));
            }

        }
        radius -= 1;
    }
    // Add the special case center.
    idList.push(cx | (cy << level));
    return idList;
}

// I do not think this ever gets called.  No class calls this method.
Cache.prototype.GetTileIdContainingPoint = function (level, wPt) {
    var dim = 1 << level;
    var xIdx = Math.floor(wPt[0] * dim);
    var yIdx = Math.floor(wPt[1] * dim);
    if (xIdx < 0) {xIdx = 0;}
    if (xIdx >= dim) {xIdx = dim-1;}
    if (yIdx < 0) {yIdx = 0;}
    if (yIdx >= dim) {yIdx = dim-1;}
    var id = xIdx | (yIdx << level);
    return id;
}




// Set parent to be minimum of children.
Cache.prototype.UpdateBranchTimeStamp = function(tile) {
    var min = GetCurrentTime();
    if (tile.Children[0] != null) {
      if (tile.Children[0].BranchTimeStamp < min) {
        min = tile.Children[0].BranchTimeStamp;
      }
    }
    if (tile.Children[1] != null) {
      if (tile.Children[1].BranchTimeStamp < min) {
        min = tile.Children[1].BranchTimeStamp;
      }
    }
    if (tile.Children[2] != null) {
      if (tile.Children[2].BranchTimeStamp < min) {
        min = tile.Children[2].BranchTimeStamp;
      }
    }
    if (tile.Children[3] != null) {
      if (tile.Children[3].BranchTimeStamp < min) {
        min = tile.Children[3].BranchTimeStamp;
      }
    }
    if (min == GetCurrentTime()) { // no children
      min = tile.TimeStamp;
    }
    if (min != tile.BranchTimeStamp) {
      tile.BranchTimeStamp = min;
      if (tile.Parent != null) {
        this.UpdateBranchTimeStamp(tile.Parent);
      }
    }
}

Cache.prototype.GetTile = function(slice, level, id) {
    //Separate x and y.
    var dim = 1 << level;
    var x = id & (dim-1);
    var y = id >> level;
    
    return this.RecursiveGetTile(level, x, y, slice);
}

Cache.prototype.RecursiveGetTile = function(level, x, y, z) {
    if ( ! this.Levels[level]) { return null; }
    var tile = this.Levels[level].GetTile(x,y);
    if (tile) {
        return tile;
    }
    var tile = new Tile(x, y, z, level,
                        this.TileSource.getTileUrl(level, x, y, z),
                        this);
    this.Levels[level].SetTile(tile);
    if (level > 0) {
        var parent = this.RecursiveGetTile(level-1,x>>1, y>>1, z);
        // I do not know if this is still valid.
        // This is to fix a bug. Root.BranchTime larger
        // than all children BranchTimeStamps.  When
        // long branch is added, node never gets updated.
        if (parent.Children[0] == null && parent.Children[1] == null &&
            parent.Children[2] == null && parent.Children[3] == null) {
            parent.BranchTimeStamp = GetCurrentTime();
        }
        var cx = x&1;
        var cy = y&1;
        var childIdx = cx+(2*cy);
        parent.Children[childIdx] = tile;
        tile.Parent = parent;
    }
    return tile;
}


// Find the oldest tile, remove it from the tree and return it to be recycled.
// This also prunes texture maps.
// SA.PruneTimeTiles and SA.PruneTimeTextures are compared with used time of tile.
Cache.prototype.PruneTiles = function()
{
    for (var i = 0; i < this.Levels[0].Tiles.length; ++i) {
        var node = this.Levels[0].Tiles[i];
        if (node != null) {
            if (node.BranchTimeStamp < SA.PruneTimeTiles || node.BranchTimeStamp < SA.PruneTimeTextures) {
                this.RecursivePruneTiles(node);
            }
        }
    }
}

Cache.prototype.RecursivePruneTiles = function(node)
{
  var leaf = true;

  for (var i = 0; i < 4; ++i) {
    var child = node.Children[i];
    if (child != null) {
      leaf = false;
      if (child.BranchTimeStamp < SA.PruneTimeTiles ||
          child.BranchTimeStamp < SA.PruneTimeTextures) {
        this.RecursivePruneTiles(child);
      }
    }
  }
  if (leaf && node.Parent != null) { // Roots have null parents.  Do not prune roots.
    if (node.BranchTimeStamp < SA.PruneTimeTextures) {
      node.DeleteTexture();
    }
    if (node.BranchTimeStamp < SA.PruneTimeTiles) {
      if ( node.LoadState == 1) {
        LoadQueueRemove(node);
      }
      var parent = node.Parent;
      // nodes will always have parents because we do not steal roots.
      if (parent.Children[0] == node) {
          parent.Children[0] = null;
      } else if (parent.Children[1] == node) {
          parent.Children[1] = null;
      } else if (parent.Children[2] == node) {
          parent.Children[2] = null;
      } else if (parent.Children[3] == node) {
          parent.Children[3] = null;
      }
      node.Parent = null;
      this.UpdateBranchTimeStamp(parent)
      node.destructor();
    }
  }
}


    SA.Cache = Cache;

})();

//==============================================================================
// Section Object
// Leftover from Connectome.
var SLICE = 0;


function Section () {
  // Warping to align this section with previous / next.
  // This is only a matrix transformation.
  this.Matrix = mat4.create();
  mat4.identity(this.Matrix);
  // The list of caches is really just a list of images in the montage.
  this.Caches = [];
  // For debugging stitching.
  this.Markers = [];
}

// For limiting interaction.
Section.prototype.GetBounds = function () {
  var bounds = [0,10000,0,10000];

  for (var cIdx = 0; cIdx < this.Caches.length; ++cIdx) {
    var cache = this.Caches[cIdx];
    var bds = cache.GetBounds();
    if (cIdx == 0) {
      bounds = [bds[0], bds[1], bds[2], bds[3]];
    } else {
      if (bds[0] < bounds[0]) {
        bounds[0] = bds[0];
      }
      if (bds[1] > bounds[1]) {
        bounds[1] = bds[1];
      }
      if (bds[2] < bounds[2]) {
        bounds[2] = bds[2];
      }
      if (bds[3] < bounds[3]) {
        bounds[3] = bds[3];
      }
    }
  }

  return bounds;
}

// Size of a pixel at the highest resolution.
Section.prototype.GetLeafSpacing = function () {
  if ( ! this.LeafSpacing) {
    for (var cIdx = 0; cIdx < this.Caches.length; ++cIdx) {
      var cache = this.Caches[cIdx];
      var spacing = cache.GetLeafSpacing();
      if ( ! this.LeafSpacing || spacing < this.LeafSpacing) {
        this.LeafSpacing = spacing;
      }
    }
  }
  return this.LeafSpacing;
}


Section.prototype.LoadRoots = function () {
  for (var cIdx = 0; cIdx < this.Caches.length; ++cIdx) {
    var cache = this.Caches[cIdx];
    if (cache) {
      cache.LoadRoots();
    }
  }
}


Section.prototype.FindImage = function (imageCollectionName) {
  for (var i = 0; i < this.Caches.length; ++i) {
    var cache = this.Caches[i];
    if (cache.Image._id == imageCollectionName) {
      return cache;
    }
  }
  return null;
}


// I do not like passing in the whole view.
// Could we get away with just passing the camera?
// No, we need the viewport too.
// Could the viewport be part of the camera?
// Returns true if all the tiles to render were available.
// False implies that the user shoudl render again.
Section.prototype.Draw = function (view, context) {
    var finishedRendering = true;
    if (GL) {
        var program = imageProgram;
        context.useProgram(program);
        // Draw tiles.
        context.viewport(view.Viewport[0], view.Viewport[1],
                         view.Viewport[2], view.Viewport[3]);
        context.uniformMatrix4fv(program.pMatrixUniform, false, view.Camera.Matrix);
    } else {
        // The camera maps the world coordinate system to (-1->1, -1->1).
        var h = 1.0 / view.Camera.Matrix[15];
        context.transform(view.Camera.Matrix[0]*h, view.Camera.Matrix[1]*h,
                          view.Camera.Matrix[4]*h, view.Camera.Matrix[5]*h,
                          view.Camera.Matrix[12]*h, view.Camera.Matrix[13]*h);
    }
    
    for (var i = 0; i < this.Caches.length; ++i) {
        var cache = this.Caches[i];
        // Select the tiles to render first.
        this.Tiles = cache.ChooseTiles(view.Camera, SLICE, view.Tiles);
        // For the 2d viewer, the order the tiles are drawn is very important.
        // Low-resolution tiles have to be drawn first.  Make a new sorted array.
        // The problem is that unloaded tiles fall back to rendering parents.
        // Make  copy (although we could just destroy the "Tiles" array which is not really used again).
        var tiles = this.Tiles.slice(0);
        var loadedTiles = [];
        var j = 0;
        while (j < tiles.length) { // We add tiles in the loop so we need a while.
            var tile = tiles[j];
            if (tile.LoadState == 3) {
                loadedTiles.push(tile);
            } else {
                if (tiles[j].LoadState < 3) {
                    // Keep rendering until we have all the tiles.
                    finishedRendering = false;
                }
                if (tile.Parent) { // Queue up the parent.
                    // Note: Parents might be added multiple times by different siblings.
                    // Ok, lets render the whole tree (low res first) to
                    // cover cracks.  This is done in choose tiles.
                    // This is not needed for prgressive rendering then.
                    //tiles.push(tile.Parent);
                }
            }
            ++j;
        }

        // Reverse order to render low res tiles first.
        for (var j = loadedTiles.length-1; j >= 0; --j) {
            loadedTiles[j].Draw(program, context);
        }
    }
    return finishedRendering;
}

Section.prototype.LoadTilesInView = function (view) {
    for (var i = 0; i < this.Caches.length; ++i) {
        var cache = this.Caches[i];
        // Select the tiles to render first.
        // This also adds the tiles returned to the loading queue.
        this.Tiles = cache.ChooseTiles(view.Camera, SLICE, view.Tiles);
    }
}

// The above will load the first ancestor not loaded and will stop.
// I need to pre load the actual high res tiles for connectome.
Section.prototype.LoadTilesInView2 = function (view) {
  for (var cIdx = 0; cIdx < this.Caches.length; ++cIdx) {
    var cache = this.Caches[cIdx];
    // Select the tiles to load (loading is a byproduct).
    var tiles = cache.ChooseTiles(view.Camera, SLICE);
    for (var i = 0; i < tiles.length; ++i) {
      tiles[i].LoadState = 1;
      // Add the tile at the front of the queue.
      LOAD_QUEUE.push(tiles[i]);
    }
  }
  LoadQueueUpdate();
}

// This load tiles in the view like draw but does not render them.
// I want to preload tiles in the next section.
Section.prototype.LoadTilesInView = function (view) {
  for (var cIdx = 0; cIdx < this.Caches.length; ++cIdx) {
    var cache = this.Caches[cIdx];
    // Select the tiles to load (loading is a byproduct).
    var tiles = cache.ChooseTiles(view.Camera, SLICE);
  }
}





//==============================================================================
// View Object
// Viewport (x_lowerleft, y_lowerleft, width, height)
// A view has its own camera and list of tiles to display.
// Views can share a cache for tiles.

var TEXT_VIEW_HACK = null;

(function () {
    "use strict";

function View (parent) {
    // Text needs a context to compute its bounds.
    if ( ! TEXT_VIEW_HACK) {
        TEXT_VIEW_HACK = this;
    }
    // Should widgets use shapes?
    // Should views be used independently to viewers?
    this.ShapeList = [];

    // connectome : default section so we cen set cache
    this.Section = new Section;

    // connectome: remove Cache ivar.
    this.Camera = new Camera();
    this.Tiles = []; // Not really used
    this.OutlineColor = [0,0.5,0];
    this.OutlineMatrix = mat4.create();
    this.OutlineCamMatrix = mat4.create();

    this.CanvasDiv = parent;
    if ( parent) {
        this.CanvasDiv = parent;
    } else {
        this.CanvasDiv = $('<div>');
    }
    // 2d canvas
    // Add a new canvas.
    this.Canvas = $('<canvas>');
    if ( ! GL) {
        this.Context2d = this.Canvas[0].getContext("2d");
    }

    this.Canvas
        .appendTo(this.CanvasDiv)
        .css({'position':'absolute',
              'left'    : '0%',
              'top'     : '0%',
              'width'   :'100%',
              'height'  :'100%'});

    this.CanvasDiv
        .addClass("sa-view-canvas-div");
}

// Try to remove all global and circular references to this view.
View.prototype.Delete = function() {
    this.CanvasDiv.off('mousedown.viewer');
    this.CanvasDiv.off('mousemove.viewer');
    this.CanvasDiv.off('wheel.viewer');
    this.CanvasDiv.off('touchstart.viewer');
    this.CanvasDiv.off('touchmove.viewer');
    this.CanvasDiv.off('touchend.viewer');
    this.CanvasDiv.off('keydown.viewer');
    this.CanvasDiv.off('wheel.viewer');
    delete this.ShapeList;
    delete this.Section;
    delete this.Camera;
    delete this.Tiles;
    delete this.CanvasDiv;
    delete this.Canvas;
}

View.prototype.GetCamera = function() {
    return this.Camera;
}

// Only new thing here is appendTo
// TODO get rid of this eventually (SetViewport).
View.prototype.InitializeViewport = function(viewport) {
    for (var i = 0; i < 4; ++i) {
        viewport[i] = Math.round(viewport[i]);
    }
    // Allow for border.
    viewport[2] -=2;
    viewport[3] -=2;

    this.Viewport = viewport;
    this.Camera.SetViewport(viewport);

    // TODO: Get Rid of this.
    //this.CanvasDiv
    //    .addClass('view');

}


// Get the current scale factor between pixels and world units.
// Returns the size of a world pixel in screen pixels.
// factor: screen/world
// The default world pixel = 0.25e-6 meters
View.prototype.GetPixelsPerUnit = function() {
    // Determine the scale difference between the two coordinate systems.
    var m = this.Camera.Matrix;

    // Convert from world coordinate to view (-1->1);
    return 0.5*this.Viewport[2] / (m[3] + m[15]); // m[3] for x, m[7] for height
}


// TODO: Get rid of these since the user can manipulate the parent / canvas
// div which can be passed into the constructor.
View.prototype.appendTo = function(j) {
  return this.CanvasDiv.appendTo(j);
}

View.prototype.remove = function(j) {
  return this.CanvasDiv.remove(j);
}

View.prototype.css = function(j) {
  return this.CanvasDiv.css(j);
}

View.prototype.GetViewport = function() {
  return this.Viewport;
}

View.prototype.GetViewport = function() {
  return this.Viewport;
}

View.prototype.GetWidth = function() {
    return this.CanvasDiv.width();
}

View.prototype.GetHeight = function() {
    return this.CanvasDiv.height();
}

// The canvasDiv changes size, the width and height of the canvas and
// camera need to follow.  I am going to make this the resize callback.
View.prototype.UpdateCanvasSize = function() {
    if ( ! this.CanvasDiv.is(':visible') ) {
        return;
    }

    var pos = this.CanvasDiv.position();
    //var width = this.CanvasDiv.innerWidth();
    //var height = this.CanvasDiv.innerHeight();
    var width = this.CanvasDiv.width();
    var height = this.CanvasDiv.height();
    // resizable is making width 0 intermitently ????
    if (width <= 0 || height <= 0) { return false; }

    this.Canvas.attr("width", width.toString());
    this.Canvas.attr("height", height.toString());

    // TODO: Get rid of this.
    this.Viewport = [pos.left, pos.top, width, height];

    // TODO: Just set the width and height of the camera.
    // There is no reason, the camera needs to know the
    // the position of the cameraDiv.
    this.Camera.SetViewport(this.Viewport);

    return true;
}


// TODO: Now that the browser in managing the position and size of the
// canvasDiv, get rid of this function.  I still need to synchronize the
// canvas with the canvasDiv.  see  UpdateCanvas();
View.prototype.SetViewport = function(viewport, parent) {
    parent = parent || this.CanvasDiv;

    for (var i = 0; i < 4; ++i) {
        viewport[i] = Math.round(viewport[i]);
    }
    // Allow for border.
    viewport[2] -=2;
    viewport[3] -=2;
    if (parent) {
        parent.css({
            'left'  : viewport[0]+"px",
            'width' : viewport[2]+"px",
            'top'   : viewport[1]+"px",
            'height': viewport[3]+"px"
        });
        // Needed for canvas to have the correct drawing transformation.
        this.Canvas.attr("width", viewport[2].toString());
        this.Canvas.attr("height", viewport[3].toString());
    }

    this.Viewport = viewport;
    this.Camera.SetViewport(viewport);
}




View.prototype.CaptureImage = function() {
    var url = this.Canvas[0].toDataURL();
    var newImg = document.createElement("img"); //create
    newImg.src = url;
    return newImg;
}


View.prototype.GetBounds = function() {
    return this.Section.GetBounds();
}
View.prototype.GetLeafSpacing = function() {
    return this.Section.GetLeafSpacing();
}


// connectome
View.prototype.AddCache = function(cache) {
  if ( ! cache) { return; }
  this.Section.Caches.push(cache);
}


View.prototype.SetCache = function(cache) {
  // connectome
  if ( ! cache) {
    this.Section.Caches = [];
  } else {
    this.Section.Caches = [cache];
  }
}

View.prototype.GetCache = function() {
  // connectome: This makes less sense with a section with many caches.
  // TODO: try to get rid of this
  return this.Section.Caches[0];
}

// A list of shapes to render in the view
View.prototype.AddShape = function(shape) {
  this.ShapeList.push(shape);
}

View.prototype.DrawShapes = function () {
    if ( ! this.CanvasDiv.is(':visible') ) {
        return;
    }
    for(var i=0; i<this.ShapeList.length; i++){
        this.ShapeList[i].Draw(this);
    }
}

View.prototype.Clear = function () {
    this.Context2d.setTransform(1, 0, 0, 1, 0, 0);
    // TODO: get width and height from the canvas.
    this.Context2d.clearRect(0,0,this.Viewport[2],this.Viewport[3]);
}

// I want only the annotation to create a mask image.
var MASK_HACK = false;
// Note: Tile in the list may not be loaded yet.
// Returns true if all the tiles to render were available.
// False implies that the user shoudl render again.
View.prototype.DrawTiles = function () {
    // Download view is not visible, but still needs to render tiles.
    // This causes black/blank download images
    //if ( ! this.CanvasDiv.is(':visible') ) {
    //    return;
    //}
    //console.time("  ViewDraw");
    if ( GL) {
        if (MASK_HACK ) {
            return;
        }
        return this.Section.Draw(this, GL);
    } else {
        this.Clear();
        // Clear the canvas to start drawing.
        this.Context2d.fillStyle="#ffffff";
        //this.Context2d.fillRect(0,0,this.Viewport[2],this.Viewport[3]);

        // Start with a transform that flips the y axis.
        // This is an issue later because the images will be upside down.
        this.Context2d.setTransform(1, 0, 0, -1, 0, this.Viewport[3]);

        // Map (-1->1, -1->1) to the viewport.
        // Origin of the viewport does not matter because drawing is relative
        // to this view's canvas.
        this.Context2d.transform(0.5*this.Viewport[2], 0.0,
                                 0.0, 0.5*this.Viewport[3],
                                 0.5*this.Viewport[2],
                                 0.5*this.Viewport[3]);

        if (MASK_HACK ) {
            return;
        }
        return this.Section.Draw(this, this.Context2d);
    }
}

// Note: Tile in the list may not be loaded yet.
View.prototype.DrawHistory = function (windowHeight) {
    if ( GL) {
        alert("Drawing history does not work with webGl yet.");
    } else {
        var ctx = this.Context2d;
        ctx.save();
        ctx.setTransform(1, 0, 0, 1, 0, 0);

        // Start with a transform that flips the y axis.
        ctx.setTransform(1, 0, 0, -1, 0, this.Viewport[3]);

        // Map (-1->1, -1->1) to the viewport.
        // Origin of the viewport does not matter because drawing is relative
        // to this view's canvas.
        ctx.transform(0.5*this.Viewport[2], 0.0,
                      0.0, 0.5*this.Viewport[3],
                      0.5*this.Viewport[2],
                      0.5*this.Viewport[3]);

        //ctx.fillRect(0.0,0.1,0.5,0.5); // left, right, width, height

        // The camera maps the world coordinate system to (-1->1, -1->1).
        var cam = this.Camera;
        var aspectRatio = cam.ViewportWidth / cam.ViewportHeight;

        var h = 1.0 / cam.Matrix[15];
        ctx.transform(cam.Matrix[0]*h, cam.Matrix[1]*h,
                      cam.Matrix[4]*h, cam.Matrix[5]*h,
                      cam.Matrix[12]*h, cam.Matrix[13]*h);

        for (var i = 0; i < TIME_LINE.length; ++i) {
            var cam = TIME_LINE[i].ViewerRecords[0].Camera;
            var height = cam.GetHeight();
            var width = cam.GetWidth();
            // camer roll is already in radians.
            var c = Math.cos(cam.Roll);
            var s = Math.sin(cam.Roll);
            ctx.save();
            // transform to put focal point at 0,0
            ctx.transform(c, -s,
                          s, c,
                          cam.FocalPoint[0], cam.FocalPoint[1]);

            // Compute the zoom factor for opacity.
            var opacity = 2* windowHeight / height;
            if (opacity > 1.0) { opacity = 1.0; }

            ctx.fillStyle = "rgba(0,128,0," + opacity + ")";
            ctx.fillRect(-width/2, -height/2, width, height); // left, right, width, height
            ctx.stroke();
            ctx.restore();
        }
        ctx.restore();
    }
}

// Draw a cross hair in the center of the view.
View.prototype.DrawFocalPoint = function () {
    if ( GL) {
        alert("Drawing focal point does not work with webGl yet.");
    } else {
        var x = this.Viewport[2] * 0.5;
        var y = this.Viewport[3] * 0.5;
        var ctx = this.Context2d;
        ctx.save();
        ctx.setTransform(1, 0, 0, 1, 0, 0);
        ctx.strokeStyle = "rgba(255,255,200,100)"; 
        ctx.fillStyle = "rgba(0,0,50,100)"; 

        ctx.beginPath();
        ctx.fillRect(x-30,y-1,60,3);
        ctx.rect(x-30,y-1,60,3);
        ctx.fillRect(x-1,y-30,3,60);
        ctx.rect(x-1,y-30,3,60);

        var r = y / 2;
        ctx.beginPath();
        ctx.moveTo(x-r,y-r+30);
        ctx.lineTo(x-r,y-r);
        ctx.lineTo(x-r+30,y-r);
        ctx.moveTo(x+r,y-r+30);
        ctx.lineTo(x+r,y-r);
        ctx.lineTo(x+r-30,y-r);
        ctx.moveTo(x+r,y+r-30);
        ctx.lineTo(x+r,y+r);
        ctx.lineTo(x+r-30,y+r);
        ctx.moveTo(x-r,y+r-30);
        ctx.lineTo(x-r,y+r);
        ctx.lineTo(x-r+30,y+r);
        ctx.stroke();

        ++r;
        ctx.beginPath();
        ctx.strokeStyle = "rgba(0,0,50,100)"; 
        ctx.moveTo(x-r,y-r+30);
        ctx.lineTo(x-r,y-r);
        ctx.lineTo(x-r+30,y-r);
        ctx.moveTo(x+r,y-r+30);
        ctx.lineTo(x+r,y-r);
        ctx.lineTo(x+r-30,y-r);
        ctx.moveTo(x+r,y+r-30);
        ctx.lineTo(x+r,y+r);
        ctx.lineTo(x+r-30,y+r);
        ctx.moveTo(x-r,y+r-30);
        ctx.lineTo(x-r,y+r);
        ctx.lineTo(x-r+30,y+r);
        ctx.stroke();
        ctx.restore();
    }
}

// Draw a cross hair at each correlation point.
// pointIdx is 0 or 1.  It indicates which correlation point should be drawn.
View.prototype.DrawCorrelations = function (correlations, pointIdx) {
    if ( GL) {
        alert("Drawing correlations does not work with webGl yet.");
    } else {
        var ctx = this.Context2d;
        ctx.save();
        ctx.setTransform(1, 0, 0, 1, 0, 0);
        ctx.strokeStyle = "rgba(200,255,255,100)";
        ctx.fillStyle = "rgba(255,0,0,100)";
        for (var i = 0; i < correlations.length; ++i) {
            var wPt = correlations[i].GetPoint(pointIdx);
            var m = this.Camera.Matrix;
            // Change coordinate system from world to -1->1
            var x = (wPt[0]*m[0] + wPt[1]*m[4]
                     + m[12]) / m[15];
            var y = (wPt[0]*m[1] + wPt[1]*m[5]
                     + m[13]) / m[15];
            // Transform coordinate system from -1->1 to canvas
            x = (1.0 + x) * this.Viewport[2] * 0.5;
            y = (1.0 - y) * this.Viewport[3] * 0.5;

            ctx.beginPath();
            ctx.fillRect(x-20,y-1,40,3);
            ctx.rect(x-20,y-1,40,3);
            ctx.fillRect(x-1,y-20,3,40);
            ctx.rect(x-1,y-20,3,40);
        
            ctx.stroke();
        }
        ctx.restore();
    }
}

View.prototype.DrawCopyright = function (copyright) {
  if (copyright == undefined || MASK_HACK) {
    return;
  }
  if ( GL) {
    // not implemented yet.
  } else {
    this.Context2d.setTransform(1, 0, 0, 1, 0, 0);
    this.Context2d.font = "18px Arial";
    var x = this.Viewport[2]*0.5 - 50;
    var y = this.Viewport[3]-10;
    this.Context2d.fillStyle = "rgba(128,128,128,0.5)"; 
    this.Context2d.fillText(copyright,x,y);
    //this.Context2d.strokeStyle = "rgba(255,255,255,0.5)"; 
    //this.Context2d.strokeText(copyright,x,y);
  }
}


View.prototype.DrawOutline = function(backgroundFlag) {
    if (GL) {
        program = polyProgram;
        GL.useProgram(program);

        GL.viewport(this.Viewport[0], 
                    this.Viewport[3]-this.Viewport[1], 
                    this.Viewport[2], 
                    this.Viewport[3]);

        // Draw a line around the viewport, so move (0,0),(1,1) to (-1,-1),(1,1)
        mat4.identity(this.OutlineCamMatrix);
        this.OutlineCamMatrix[0] = 2.0; // width x
        this.OutlineCamMatrix[5] = 2.0; // width y
        this.OutlineCamMatrix[10] = 0;
        this.OutlineCamMatrix[12] = -1.0;
        this.OutlineCamMatrix[13] = -1.0;
        var viewFrontZ = this.Camera.ZRange[0]+0.001;
        var viewBackZ = this.Camera.ZRange[1]-0.001;
        this.OutlineCamMatrix[14] = viewFrontZ; // front plane

        mat4.identity(this.OutlineMatrix);

        GL.uniformMatrix4fv(program.mvMatrixUniform, false, this.OutlineMatrix);

        if (backgroundFlag) {
            // White background fill
            this.OutlineCamMatrix[14] = viewBackZ; // back plane
            GL.uniformMatrix4fv(program.pMatrixUniform, false, this.OutlineCamMatrix);
            GL.uniform3f(program.colorUniform, 1.0, 1.0, 1.0);
            GL.bindBuffer(GL.ARRAY_BUFFER, squarePositionBuffer);
            GL.vertexAttribPointer(program.vertexPositionAttribute,
                                   squarePositionBuffer.itemSize,
                                   GL.FLOAT, false, 0, 0);
            GL.drawArrays(GL.TRIANGLE_STRIP, 0, squarePositionBuffer.numItems);
        }

        // outline
        this.OutlineCamMatrix[14] = viewFrontZ; // force in front
        GL.uniformMatrix4fv(program.pMatrixUniform, false, this.OutlineCamMatrix);
        GL.uniform3f(program.colorUniform, this.OutlineColor[0], this.OutlineColor[1], this.OutlineColor[2]);
        GL.bindBuffer(GL.ARRAY_BUFFER, squareOutlinePositionBuffer);
        GL.vertexAttribPointer(program.vertexPositionAttribute,
                               squareOutlinePositionBuffer.itemSize,
                               GL.FLOAT, false, 0, 0);
        GL.drawArrays(GL.LINE_STRIP, 0, squareOutlinePositionBuffer.numItems);
    }
}


    SA.View = View;

})();
//==============================================================================

// TODO: Fix
// Add stack option to Save large image GUI.
// SaveStackImages.

// I think this can go away now that we have hover mode in text.
var ANNOTATION_OFF = 0;
var ANNOTATION_NO_TEXT = 1;
var ANNOTATION_ON = 2;

var INTERACTION_NONE = 0;
var INTERACTION_DRAG = 1;
var INTERACTION_ROTATE = 2;
var INTERACTION_ZOOM = 3;
var INTERACTION_OVERVIEW = 4;
var INTERACTION_OVERVIEW_DRAG = 5;
var INTERACTION_ICON_ROTATE = 6;


(function () {
    "use strict";


// TODO: Can we get rid of args parameter now that we have ProcessArguments method?
// See the top of the file for description of args.
function Viewer (parent) {
    var self = this;

    this.Parent = parent;
    parent.addClass('sa-viewer');

    this.Div = $('<div>')
        .appendTo(this.Parent)
        .css({'position':'relative',
              'border-width':'0px',
              'width':'100%',
              'height':'100%',
              'box-sizing':'border-box'})
        .addClass('sa-resize');
    this.Div.saOnResize(
        function() {
            self.UpdateSize();
        });

    this.LayerDiv = $('<div>')
        .appendTo(this.Div)
        .css({'position':'relative',
              'border-width':'0px',
              'width':'100%',
              'height':'100%',
              'box-sizing':'border-box'})
        .addClass('sa-resize');

    // I am moving the eventually render feature into viewers.
    this.Drawing = false;
    this.RenderPending = false;
    // TODO: Get rid of this viewport stuff
    var viewport = [0,0,100,100];

    this.HistoryFlag = false;

    // Interaction state:
    // What to do for mouse move or mouse up.
    this.InteractionState = INTERACTION_NONE;
    // External callbacks
    this.InteractionListeners = [];
    // TODO: Get rid of this.  Remove bindings instead.
    // This is a hack to turn off interaction.
    // Sometime I need to clean up the events for viewers.
    this.InteractionEnabled = true;

    this.AnimateLast;
    this.AnimateDuration = 0.0;
    this.TranslateTarget = [0.0,0.0];

    this.MainView = new SA.View(this.Div);
    this.MainView.InitializeViewport(viewport);
    this.MainView.OutlineColor = [0,0,0];
    this.MainView.Camera.ZRange = [0,1];
    this.MainView.Camera.ComputeMatrix();

    this.AnnotationLayer = new SAM.AnnotationLayer(this.LayerDiv, 
                                                   this.MainView.Camera);
    // Hack only used for girder testing.
    this.AnnotationLayer.Viewer = this;

    if (! MOBILE_DEVICE || MOBILE_DEVICE == "iPad") {
        this.OverViewVisibility = true;
        this.OverViewScale = 0.02; // Experimenting with scroll
	      this.OverViewport = [viewport[0]+viewport[2]*0.8, viewport[3]*0.02,
                             viewport[2]*0.18, viewport[3]*0.18];
        this.OverViewDiv = $('<div>')
            .appendTo(this.Div);

        this.OverView = new SA.View(this.OverViewDiv);
	      this.OverView.InitializeViewport(this.OverViewport);
	      this.OverView.Camera.ZRange = [-1,0];
	      this.OverView.Camera.SetFocalPoint( [13000.0, 11000.0]);
	      this.OverView.Camera.SetHeight(22000.0);
	      this.OverView.Camera.ComputeMatrix();

        // One must be true for the icon to be active (opaque).
        this.RotateIconHover = false;
        // I am not making this part of the InteractionState because
        // I want to make the overview its own widget.
        this.RotateIconDrag = false;

        this.RotateIcon =
            $('<img>')
            .appendTo(this.OverView.CanvasDiv)
            .attr("src", SA.ImagePathUrl+"rotate.png")
            .addClass("sa-view-rotate")
            .mouseenter(function (e) {return self.RollEnter(e);})
            .mouseleave(function (e) {return self.RollLeave(e);})
            .mousedown( function (e) {return self.RollDown(e);})
            .attr('draggable','false')
            .on("dragstart", function() {
                return false;
            });
        // Try to make the overview be on top of the rotate icon
        // It should receive events before the rotate icon.
        this.OverView.CanvasDiv.css({'z-index':'200'});
    }
    this.ZoomTarget = this.MainView.Camera.GetHeight();
    this.RollTarget = this.MainView.Camera.Roll;
    
    this.DoubleClickX = 0;
    this.DoubleClickY = 0;
    

    // For stack correlations.
    this.StackCorrelations = undefined;
    // This is only for drawing correlations.
    this.RecordIndex = 0; // Only used for drawing correlations.

    var self = this;
    var can = this.MainView.CanvasDiv;
    can.on(
        "mousedown.viewer",
			  function (event){
            return self.HandleMouseDown(event);
        });
    can.on(
        "mousemove.viewer",
			  function (event){
            // So key events go the the right viewer.
            this.focus();
            // Firefox does not set which for mouse move events.
            saFirefoxWhich(event);
            return self.HandleMouseMove(event);
        });
    // We need to detect the mouse up even if it happens outside the canvas,
    $(document.body).on(
        "mouseup.viewer",
			  function (event){
            self.HandleMouseUp(event);
            return true;
        });
    can.on(
        "wheel.viewer",
        function(event){
            return self.HandleMouseWheel(event.originalEvent);
        });

    // I am delaying getting event manager out of receiving touch events.
    // It has too many helper functions.
    can.on(
        "touchstart.viewer",
        function(event){
            return self.HandleTouchStart(event.originalEvent);
        });
    can.on(
        "touchmove.viewer",
        function(event){
            return self.HandleTouchMove(event.originalEvent);
        });
    can.on(
        "touchend.viewer",
        function(event){
            self.HandleTouchEnd(event.originalEvent);
            return true;
        });

    // necesary to respond to keyevents.
    this.MainView.CanvasDiv.attr("tabindex","1");
    can.on(
        "keydown.viewer",
			  function (event){
            //alert("keydown");
            return self.HandleKeyDown(event);
        });

    // This did not work for double left click
    // Go back to my original way of handling this.
    //can.addEventListener("dblclick",
		//	                   function (event){self.HandleDoubleClick(event);},
		//	                   false);

    if (this.OverView) {
        var can = this.OverView.CanvasDiv;
        can.on(
            "mousedown.viewer",
            function (e) {
                return self.HandleOverViewMouseDown(e);
            });

        can.on(
            "mouseup.viewer",
			      function (e){
                return self.HandleOverViewMouseUp(e);
            });
        can.on(
            "mousemove.viewer",
			      function (e){
                return self.HandleOverViewMouseMove(e);
            });
        // I cannot get this to capture events.  The feature of resizing
        //    the overview with the mouse wheel is not important anyway.
        //can[0].addEventListener(
        //    function (e){return self.HandleOverViewMouseWheel(e);},
        //    "wheel",
			  //    false);
    }

    this.CopyrightWrapper = $('<div>')
        .appendTo(this.MainView.CanvasDiv)
        .addClass("sa-view-copyright");
}

// Try to remove all global references to this viewer.
Viewer.prototype.Delete = function () {
    this.Div.remove();
    // Remove circular references too?
    // This will probably affect all viewers.
    $(document.body).off('mouseup.viewer');
    this.MainView.Delete();
    if (this.OverView) {
        this.OverView.Delete();
        delete this.OverView;
    }
    delete this.MainView;
    delete this.Parent;
    delete this.Div;
    delete this.InteractionListeners;
    delete this.RotateIcon;
    delete this.StackCorrelations;
    delete this.CopyrightWrapper;
}

Viewer.prototype.GetAnnotationLayer = function () {
    return this.AnnotationLayer;
}

// Abstracting saViewer  for viewer and dualViewWidget.
// Save viewer state in a note.
Viewer.prototype.Record = function (note, viewIdx) {
    viewIdx = viewIdx || 0;
    note.ViewerRecords[viewIdx].CopyViewer(this);
}

// TODO: MAke the annotation layer optional.
// I am moving some of the saViewer code into this viewer object because
// I am trying to abstract the single viewer used for the HTML presentation
// note and the full dual view / stack note.
// TODO: Make an alternative path that does not require a note.
Viewer.prototype.ProcessArguments = function (args) {
    if (args.overview !== undefined) {
        this.SetOverViewVisibility(args.overview);
    }
    if (args.zoomWidget !== undefined) {
        this.SetZoomWidgetVisibility(args.zoomWidget);
    }
    if (args.drawWidget !== undefined) {
        this.SetAnnotationWidgetVisibility(args.drawWidget);
    }
    // The way I handle the viewer edit menu is messy.
    // TODO: Find a more elegant way to add tabs.
    // Maybe the way we handle the anntation tab shouodl be our pattern.
    if (args.menu !== undefined) {
        if ( ! this.Menu) {
            this.Menu = new ViewEditMenu(this, null);
        }
        this.Menu.SetVisibility(args.menu);
    }

    if (args.tileSource) {
        var w = args.tileSource.width;
        var h = args.tileSource.height;
        var cache = new SA.Cache();
        cache.TileSource = args.tileSource;
        // Use the note tmp id as an image id so the viewer can index the
        // cache.
        var note = new SA.Note();
        var image = {levels:     args.tileSource.maxLevel + 1,
                     dimensions: [w,h],
                     bounds: [0,w-1, 0,h-1],
                     _id: note.TempId};
        var record = new SA.ViewerRecord();
        record.Image = image;
        record.OverviewBounds = [0,w-1,0,h-1];
        record.Camera = {FocalPoint: [w/2, h/2],
                         Roll: 0,
                         Height: h};
        note.ViewerRecords.push(record);
        cache.SetImageData(image);
        args.note = note;
    }

    if (args.note) {
        this.saNote = args.note;
        var index = this.saViewerIndex = args.viewerIndex || 0;
        args.note.ViewerRecords[index].Apply(this);
        this.Parent.attr('sa-note-id', args.note.Id || args.note.TempId);
        this.Parent.attr('sa-viewer-index', this.saViewerIndex);
    }
    if (args.hideCopyright != undefined) {
        this.SetCopyrightVisibility( ! args.hideCopyright);
    }
    if (args.interaction !== undefined) {
        this.SetInteractionEnabled(args.interaction);
    }
}

// Which is better calling Note.Apply, or viewer.SetNote?  I think this
// will  win.
Viewer.prototype.SetViewerRecord = function(viewerRecord) {
    viewerRecord.Apply(this);
}
Viewer.prototype.SetNote = function(note, viewIdx) {
    if (! note || viewIdx < 0 || viewIdx >= note.ViewerRecords.length) {
        console.log("Cannot set viewer record of note");
        return;
    }
    this.SetViewerRecord(note.ViewerRecords[viewIdx]);
    this.saNote = note;
    this.saViewerIndex = viewIdx;
}
Viewer.prototype.SetNoteFromId = function(noteId, viewIdx) {
    var self = this;
    var note = GetNoteFromId(noteId);
    if ( ! note) {
        note = new SA.Note();
        var self = this;
        note.LoadViewId(
            noteId,
            function () {
                self.SetNote(note, viewIdx);
            });
        return note;
    }
    this.SetNote(note,viewIdx);
    return note;
}


Viewer.prototype.SetOverViewVisibility = function(visible) {
    this.OverViewVisibility = visible;
    if ( ! this.OverViewDiv) { return;}
    if (visible) {
        this.OverViewDiv.show();
    } else {
        this.OverViewDiv.hide();
    }
}

Viewer.prototype.GetOverViewVisibility = function() {
    return this.OverViewVisibility;
}

Viewer.prototype.Hide = function() {
    this.MainView.CanvasDiv.hide();
    if (this.OverView) {
        this.OverView.CanvasDiv.hide();
    }
}

Viewer.prototype.Show = function() {
    this.MainView.CanvasDiv.show();
    if (this.OverView && this.OverViewVisibility) {
        this.OverView.CanvasDiv.show();
    }
}

// The interaction boolean argument will supress interaction events if false.
Viewer.prototype.EventuallyRender = function(interaction) {
    if (! this.RenderPending) {
        this.RenderPending = true;
        var self = this;
        requestAnimFrame(
            function() {
                self.RenderPending = false;
                self.Draw();
                if (interaction) {
                    // Easiest place to make sure interaction events are triggered.
                    self.TriggerInteraction();
                }
            });
    }
}

// These should be in an overview widget class.
Viewer.prototype.RollEnter = function (e) {
    this.RotateIconHover = true;
    this.RotateIcon.addClass("sa-active");
}
Viewer.prototype.RollLeave = function (e) {
    this.RotateIconHover = false;
    if ( ! this.RotateIconDrag) {
        this.RotateIcon.removeClass("sa-active");
    }
}
Viewer.prototype.RollDown = function (e) {
    if ( ! this.OverView) { return; }
    this.RotateIconDrag = true;
    // Find the center of the overview window.
    var w = this.OverView.CanvasDiv;
    var o = w.offset();
    var cx = o.left + (w.width()/2);
    var cy = o.top + (w.height()/2);
    this.RotateIconX = e.clientX - cx;
    this.RotateIconY = e.clientY - cy;

    return false;
}
Viewer.prototype.RollMove = function (e) {
    if ( ! this.OverView) { return; }
    if ( ! this.RotateIconDrag) { return; }
    if ( e.which != 1) {
        // We must have missed the mouse up event.
        this.RotateIconDrag = false;
        return;
    }
    // Find the center of the overview window.
    var origin = this.MainView.CanvasDiv.offset();
    // center of rotation
    var cx = this.OverViewport[0] + (this.OverViewport[2] / 2);
    var cy = this.OverViewport[1] + (this.OverViewport[3] / 2);

    var x = (e.clientX-origin.left) - cx;
    var y = (e.clientY-origin.top) - cy;
    var c = x*this.RotateIconY - y*this.RotateIconX;
    var r = c / (x*x + y*y);

    this.MainView.Camera.Roll -= r;
    this.UpdateCamera();
    this.EventuallyRender(true);

    this.RotateIconX = x;
    this.RotateIconY = y;

    return false;
}

// TODO: Get rid of viewer::SetViewport.
// onresize callback.  Canvas width and height and the camera need
// to be synchronized with the canvas div.
Viewer.prototype.UpdateSize = function () {
    if ( ! this.MainView) {
        return;
    }

    if (this.MainView.UpdateCanvasSize() ) {
        this.EventuallyRender();
    }

    if (this.AnnotationLayer) {
        this.AnnotationLayer.UpdateSize();
    }

    // I do not know the way the viewport is used to place
    // this overview.  It should be like other widgets
    // and be placed relative to the parent.
    if (this.OverView) {
        var width = this.MainView.GetWidth();
        var height = this.MainView.GetHeight();
        var area = width*height;
        var bounds = this.GetOverViewBounds();
        var aspect = (bounds[1]-bounds[0])/(bounds[3]-bounds[2]);
        // size of overview
        var h = Math.sqrt(area*this.OverViewScale/aspect);
        var w = h*aspect;
        // Limit size
        if (h > height/2) {
            h = height/2;
            var w = h*aspect;
            this.OverViewScale = w*h/area;
        }
        // center of overview
        var radius = Math.sqrt(h*h+w*w)/2;
        // Construct the viewport.  Hack: got rid of viewport[0]
        // TODO: I really need to get rid of the viewport stuff
        this.OverViewport = [width-radius-w/2,
                             radius-h/2,
                             w, h];

        this.OverView.SetViewport(this.OverViewport);
        this.OverView.Camera.ComputeMatrix();
    }
}


// TODO: Events are a pain because most are handled by parent.
// Time to make the overview a real widget?
Viewer.prototype.RollUp = function (e) {
    this.RotateIconDrag = false;
    if ( ! this.RotateIconHover) {
        this.RotateIcon.addClass("sa-active");
    }

    return false;
}


Viewer.prototype.GetMainCanvas = function() {
    return this.MainView.Canvas;
}

// A way to have a method called every time the camera changes.
// Will be used for synchronizing viewers for stacks.
Viewer.prototype.OnInteraction = function(callback) {
    // How should we remove listners?
    // Global clear for now.
    if ( ! callback) {
        this.InteractionListeners = [];
    } else {
        this.InteractionListeners.push(callback);
    }
}


Viewer.prototype.TriggerInteraction = function() {
    for (var i = 0; i < this.InteractionListeners.length; ++i) {
        var callback = this.InteractionListeners[i];
        callback();
    }
}

Viewer.prototype.GetDiv = function() {
    return this.MainView.CanvasDiv;
}

Viewer.prototype.InitializeZoomGui = function() {
    // Put the zoom bottons in a tab.
    this.ZoomTab = new Tab(this.GetDiv(),
                           SA.ImagePathUrl+"mag.png",
                           "zoomTab");
    this.ZoomTab.Div
        .css({'box-sizing': 'border-box',
              'position':'absolute',
              'bottom':'0px',
              'right':'7px',
              'z-index':'200'})
        .prop('title', "Zoom scroll");
    this.ZoomTab.Panel
        .addClass("sa-view-zoom-panel");

    // Put the magnification factor inside the magnify glass icon.
    this.ZoomDisplay = $('<div>')
        .appendTo(this.ZoomTab.Div)
        .addClass("sa-view-zoom-text")
        .html("");

    // Place the zoom in / out buttons.
    // Todo: Make the button become more opaque when pressed.
    // Associate with viewer (How???).
    // Place properly (div per viewer?) (viewer.SetViewport also places buttons).
    var self = this;

    this.ZoomDiv = $('<div>')
        .appendTo(this.ZoomTab.Panel)
        .addClass("sa-view-zoom-panel-div");
    this.ZoomInButton = $('<img>')
        .appendTo(this.ZoomDiv)
        .addClass("sa-view-zoom-button sa-zoom-in")
        .attr('type','image')
        .attr('src',SA.ImagePathUrl+"zoomin2.png")
        .click(function(){ self.AnimateZoom(0.5);})
        .attr('draggable','false')
        .on("dragstart", function() {
            return false;});

    this.ZoomOutButton = $('<img>').appendTo(this.ZoomDiv)
        .addClass("sa-view-zoom-button sa-zoom-out")
        .attr('type','image')
        .attr('src',SA.ImagePathUrl+"zoomout2.png")
        .click(function(){self.AnimateZoom(2.0);})
        .attr('draggable','false')
        .on("dragstart", function() {
            return false;});

    this.ZoomInButton.addClass('sa-active');
    this.ZoomOutButton.addClass('sa-active');

}

Viewer.prototype.UpdateZoomGui = function() {
    if ( ! this.ZoomDisplay) { return; }
    var camHeight = this.GetCamera().GetHeight();
    var windowHeight = this.GetViewport()[3];
    // Assume image scanned at 40x
    var zoomValue = 40.0 * windowHeight / camHeight;
    // 2.5 and 1.25 are standard in the geometric series.
    if ( zoomValue < 2) {
        zoomValue = zoomValue.toFixed(2);
    } else if (zoomValue < 4) {
        zoomValue = zoomValue.toFixed(1);
    } else {
        zoomValue = Math.round(zoomValue);
    }
    this.ZoomDisplay.html( 'x' + zoomValue);

    // I am looking for the best place to update this value.
    // Trying to fix a bug: Large scroll when wheel event occurs
    // first.
    this.ZoomTarget = camHeight;
}


Viewer.prototype.SaveImage = function(fileName) {
    this.MainView.Canvas[0].toBlob(function(blob) {saveAs(blob, fileName);}, "image/png");
}


// Cancel the large image request before it finishes.
Viewer.prototype.CancelLargeImage = function() {
    // This will abort the save blob that occurs after rendering.
    ClearFinishedLoadingCallbacks();
    // We also need to stop the request for pending tiles.
    ClearQueue();
     // Incase some of the queued tiles were for normal rendering.
    this.EventuallyRender(false);
}


// Create a virtual viewer to save a very large image.
Viewer.prototype.SaveLargeImage = function(fileName, width, height, stack,
                                           finishedCallback) {
    var self = this;
    var cache = this.GetCache();
    var viewport = [0,0, width, height];
    var cam = this.GetCamera();

    // Clone the main view.
    var view = new SA.View();
    view.InitializeViewport(viewport);
    view.SetCache(cache);
    view.Canvas.attr("width", width);
    view.Canvas.attr("height", height);
    var newCam = view.Camera;

    newCam.SetFocalPoint( cam.FocalPoint );
    newCam.Roll = cam.Roll;
    newCam.Height = cam.GetHeight();
    newCam.Width = cam.GetWidth();
    newCam.ComputeMatrix();

    // Load only the tiles we need.
    var tiles = cache.ChooseTiles(newCam, 0, []);
    for (var i = 0; i < tiles.length; ++i) {
        LoadQueueAddTile(tiles[i]);
    }
    LoadQueueUpdate();

    //this.CancelLargeImage = false;
    AddFinishedLoadingCallback(
        function () {self.SaveLargeImage2(view, fileName,
                                          width, height, stack,
                                          finishedCallback);}
    );
}


Viewer.prototype.SaveLargeImage2 = function(view, fileName,
                                            width, height, stack,
                                            finishedCallback) {
    var sectionFileName = fileName;
    if (stack) {
        var note = SA.DualDisplay.GetNote();
        var idx = fileName.indexOf('.');
        if (idx < 0) {
            sectionFileName = fileName + ZERO_PAD(note.StartIndex, 4) + ".png";
        } else {
            sectionFileName = fileName.substring(0, idx) +
                ZERO_PAD(note.StartIndex, 4) +
                fileName.substring(idx, fileName.length);
        }
    }
    console.log(sectionFileName + " " + SA.LoadQueue.length + " " + SA.LoadingCount);

    if ( ! view.DrawTiles() ) {
        console.log("Sanity check failed. Not all tiles were available.");
    }
    this.MainView.DrawShapes();
    this.AnnotationLayer.Draw(view);

    view.Canvas[0].toBlob(function(blob) {saveAs(blob, sectionFileName);}, "image/png");
    if (stack) {
        var note = SA.DualDisplay.GetNote();
        if (note.StartIndex < note.ViewerRecords.length-1) {
            SA.DualDisplay.NavigationWidget.NextNote();
            var self = this;
            setTimeout(function () {
                self.SaveLargeImage(fileName, width, height, stack,
                                    finishedCallback);}, 1000);
            return;
        }
    }

    finishedCallback();
}

// This method waits until all tiles are loaded before saving.
var SAVE_FINISH_CALLBACK;
Viewer.prototype.EventuallySaveImage = function(fileName, finishedCallback) {
    var self = this;
    AddFinishedLoadingCallback(
        function () {
            self.SaveImage(fileName);
            if (finishedCallback) {
                finishedCallback();
            }
        }
    );
    this.EventuallyRender(false);
}


// Not used anymore.  Incorpoarated in SaveLargeImage
// delete these.
// Save a bunch of stack images ----
Viewer.prototype.SaveStackImages = function(fileNameRoot) {
    var self = this;
    AddFinishedLoadingCallback(
        function () {
            self.SaveStackImage(fileNameRoot);
        }
    );
    this.EventuallyRender(false);
}

Viewer.prototype.SaveStackImage = function(fileNameRoot) {
    var self = this;
    var note = SA.DualDisplay.GetNote();
    var fileName = fileNameRoot + ZERO_PAD(note.StartIndex, 4);
    this.SaveImage(fileName);
    if (note.StartIndex < note.ViewerRecords.length-1) {
        SA.DualDisplay.NavigationWidget.NextNote();
        AddFinishedLoadingCallback(
            function () {
                self.SaveStackImage(fileNameRoot);
            }
        );
        this.EventuallyRender(false);
    }
}
//-----

Viewer.prototype.SetOverViewBounds = function(bounds) {
    this.OverViewBounds = bounds;
    if (this.OverView) {
        // With the rotating overview, the overview camera
        // never changes. Maybe this should be set in
        // "UpdateCamera".
        this.OverView.Camera.SetHeight(bounds[3]-bounds[2]);
        this.OverView.Camera.SetFocalPoint( [0.5*(bounds[0]+bounds[1]),
                                             0.5*(bounds[2]+bounds[3])]);
        this.OverView.Camera.ComputeMatrix();
    }
}

Viewer.prototype.GetOverViewBounds = function() {
    if (this.OverViewBounds) {
        return this.OverViewBounds;
    }
    var cache = this.GetCache();
    if (cache && cache.Image) {
        if (cache.Image.bounds) {
            return cache.Image.bounds;
        }
        if (cache.Image.dimensions) {
            var dims = cache.Image.dimensions;
            return [0, dims[0], 0, dims[1]];
        }
    }
    // Depreciated code.
    if (this.OverView) {
        var cam = this.OverView.Camera;
        var halfHeight = cam.GetHeight() / 2;
        var halfWidth = cam.GetWidth() / 2;
        this.OverViewBounds = [cam.FocalPoint[0] - halfWidth,
                               cam.FocalPoint[0] + halfWidth,
                               cam.FocalPoint[1] - halfHeight,
                               cam.FocalPoint[1] + halfHeight];
        return this.OverViewBounds;
    }
    // This method is called once too soon.  There is no image, and mobile devices have no overview.
    return [0,10000,0,10000];
}


Viewer.prototype.SetSection = function(section) {
    if (section == null) {
        return;
    }
    this.MainView.Section = section;
    if (this.OverView) {
        this.OverView.Section = section;
    }
    this.EventuallyRender(true);
}


// Change the source / cache after a viewer has been created.
Viewer.prototype.SetCache = function(cache) {
    if (cache && cache.Image) {
        if (cache.Image.bounds) {
            this.SetOverViewBounds(cache.Image.bounds);
        }

        if (cache.Image.copyright == undefined) {
            cache.Image.copyright = "Copyright 2016. All Rights Reserved.";
        }
        this.CopyrightWrapper
            .html(cache.Image.copyright);
    }

    this.MainView.SetCache(cache);
    if (this.OverView) {
        this.OverView.SetCache(cache);
        if (cache) {
            var bds = cache.GetBounds();
            if (bds) {
                this.OverView.Camera.SetFocalPoint( [(bds[0] + bds[1]) / 2,
                                                     (bds[2] + bds[3]) / 2]);
                var height = (bds[3]-bds[2]);
                // See if the view is constrained by the width.
                var height2 = (bds[1]-bds[0]) * this.OverView.Viewport[3] / this.OverView.Viewport[2];
                if (height2 > height) {
                    height = height2;
                }
                this.OverView.Camera.SetHeight(height);
                this.OverView.Camera.ComputeMatrix();
            }
        }
    }
    // Change the overview to fit the new image dimensions.
    // TODO: Get rid of this hack.
    $(window).trigger('resize');
}

Viewer.prototype.GetCache = function() {
    return this.MainView.GetCache();
}

// ORIGIN SEEMS TO BE BOTTOM LEFT !!!
// I intend this method to get called when the window resizes.
// TODO: Redo all this overview viewport junk.
// viewport: [left, top, width, height]
// When I remove this function, move the logic to UpdateSize().
Viewer.prototype.SetViewport = function(viewport) {

    // TODO: Get rid of this positioning hack.
    // Caller should be positioning the parent.
    // The whole "viewport" concept needs to be eliminated.
    this.MainView.SetViewport(viewport, this.Parent);
    this.MainView.Camera.ComputeMatrix();

    // I do not know the way the viewport is used to place
    // this overview.  It should be like other widgets
    // and be placed relative to the parent.
    if (this.OverView) {
        var area = viewport[2]*viewport[3];
        var bounds = this.GetOverViewBounds();
        var aspect = (bounds[1]-bounds[0])/(bounds[3]-bounds[2]);
        // size of overview
        var h = Math.sqrt(area*this.OverViewScale/aspect);
        var w = h*aspect;
        // Limit size
        if (h > viewport[3]/2) {
            h = viewport[3]/2;
            var w = h*aspect;
            this.OverViewScale = w*h/area;
        }
        // center of overview
        var radius = Math.sqrt(h*h+w*w)/2;
        // Construct the viewport.  Hack: got rid of viewport[0]
        // TODO: I really need to get rid of the viewport stuff
        this.OverViewport = [viewport[2]-radius-w/2,
                             viewport[1]+radius-h/2,
                             w, h];

        this.OverView.SetViewport(this.OverViewport);
        this.OverView.Camera.ComputeMatrix();
    }
}

Viewer.prototype.GetViewport = function() {
    return this.MainView.Viewport;
}

// To fix a bug in the perk and elmer uploader.
Viewer.prototype.ToggleMirror = function() {
    this.MainView.Camera.Mirror = ! this.MainView.Camera.Mirror;
    if (this.OverView) {
        this.OverView.Camera.Mirror = ! this.OverView.Camera.Mirror;
    }
}

// Same as set camera but use animation
Viewer.prototype.AnimateCamera = function(center, rotation, height) {

    this.ZoomTarget = height;
    // Compute traslate target to keep position in the same place.
    this.TranslateTarget[0] = center[0];
    this.TranslateTarget[1] = center[1];
    this.RollTarget = rotation;

    this.AnimateLast = new Date().getTime();
    this.AnimateDuration = 200.0; // hard code 200 milliseconds
    this.EventuallyRender(true);
}

// This sets the overview camera from the main view camera.
// The user can change the mainview camera and then call this method.
Viewer.prototype.UpdateCamera = function() {

    var cam = this.MainView.Camera;
    this.ZoomTarget = cam.Height;

    this.TranslateTarget[0] = cam.FocalPoint[0];
    this.TranslateTarget[1] = cam.FocalPoint[1];
    this.RollTarget = cam.Roll;
    if (this.OverView) {
        //this.OverView.Camera.Roll = cam.Roll;
        //this.OverView.Camera.ComputeMatrix();
        this.OverView.CanvasDiv.css({'transform':'rotate('+cam.Roll+'rad'});
        this.OverView.Camera.Roll = 0;
        this.OverView.Camera.ComputeMatrix();
    }

    this.MainView.Camera.ComputeMatrix();
    this.UpdateZoomGui();
}

// This is used to set the default camera so the complexities
// of the target and overview are hidden.
Viewer.prototype.SetCamera = function(center, rotation, height) {
    this.MainView.Camera.SetHeight(height);
    this.MainView.Camera.SetFocalPoint( [center[0], center[1]]);
    this.MainView.Camera.Roll = rotation * 3.14159265359 / 180.0;

    this.UpdateCamera();
    this.EventuallyRender(true);
}

Viewer.prototype.GetCamera = function() {
    return this.MainView.Camera;
}

// I could merge zoom methods if position defaulted to focal point.
Viewer.prototype.AnimateZoomTo = function(factor, position) {
    if (this.AnimateDuration > 0.0) {
        // Odd effect with multiple fast zoom clicks.  Center shifted.
        return;
    }

    SA.StackCursorFlag = false;

    this.ZoomTarget = this.MainView.Camera.GetHeight() * factor;
    if (this.ZoomTarget < 0.9 / (1 << 5)) {
        this.ZoomTarget = 0.9 / (1 << 5);
    }

    // Lets restrict discrete zoom values to be standard values.
    var windowHeight = this.GetViewport()[3];
    var tmp = Math.round(Math.log(32.0 * windowHeight / this.ZoomTarget) /
                         Math.log(2));
    this.ZoomTarget = 32.0 * windowHeight / Math.pow(2,tmp);

    factor = this.ZoomTarget / this.MainView.Camera.GetHeight(); // Actual factor after limit.

    // Compute translate target to keep position in the same place.
    this.TranslateTarget[0] = position[0]
        - factor * (position[0] - this.MainView.Camera.FocalPoint[0]);
    this.TranslateTarget[1] = position[1]
        - factor * (position[1] - this.MainView.Camera.FocalPoint[1]);

    this.RollTarget = this.MainView.Camera.Roll;

    this.AnimateLast = new Date().getTime();
    this.AnimateDuration = 200.0; // hard code 200 milliseconds
    this.EventuallyRender(true);
}

Viewer.prototype.AnimateZoom = function(factor) {
    // I cannot get the canvas from processing this event too.
    // Issue with double click. Hack to stop double click from firing.
    this.MouseUpTime -= 1000.0;

    if (this.AnimateDuration > 0.0) {
        return;
    }

    var focalPoint = this.GetCamera().GetFocalPoint();
    this.AnimateZoomTo(factor, focalPoint);
}

Viewer.prototype.AnimateTranslate = function(dx, dy) {
    this.TranslateTarget[0] = this.MainView.Camera.FocalPoint[0] + dx;
    this.TranslateTarget[1] = this.MainView.Camera.FocalPoint[1] + dy;

    this.ZoomTarget = this.MainView.Camera.GetHeight();
    this.RollTarget = this.MainView.Camera.Roll;

    this.AnimateLast = new Date().getTime();
    this.AnimateDuration = 200.0; // hard code 200 milliseconds
    this.EventuallyRender(true);
}

Viewer.prototype.AnimateRoll = function(dRoll) {
    dRoll *= Math.PI / 180.0;
    this.RollTarget = this.MainView.Camera.Roll + dRoll;

    this.ZoomTarget = this.MainView.Camera.GetHeight();
    this.TranslateTarget[0] = this.MainView.Camera.FocalPoint[0];
    this.TranslateTarget[1] = this.MainView.Camera.FocalPoint[1];

    this.AnimateLast = new Date().getTime();
    this.AnimateDuration = 200.0; // hard code 200 milliseconds
    this.EventuallyRender(true);
}

Viewer.prototype.AnimateTransform = function(dx, dy, dRoll) {
    this.TranslateTarget[0] = this.MainView.Camera.FocalPoint[0] + dx;
    this.TranslateTarget[1] = this.MainView.Camera.FocalPoint[1] + dy;

    this.RollTarget = this.MainView.Camera.Roll + dRoll;

    this.ZoomTarget = this.MainView.Camera.GetHeight();

    this.AnimateLast = new Date().getTime();
    this.AnimateDuration = 200.0; // hard code 200 milliseconds
    this.EventuallyRender(true);
}

Viewer.prototype.DegToRad = function(degrees) {
    return degrees * Math.PI / 180;
}

Viewer.prototype.Draw = function() {
    // I do not think this is actaully necessary.
    // I was worried about threads, but javascript does not work that way.
    if (this.Drawing) { return; }
    this.Drawing = true;

    if (GL) {
      GL.clear(GL.COLOR_BUFFER_BIT | GL.DEPTH_BUFFER_BIT);
    }

    // This just changes the camera based on the current time.
    this.Animate();

    //console.time("ViewerDraw");

    // connectome
    if ( ! this.MainView || ! this.MainView.Section) {
        return;
    }

    this.ConstrainCamera();
    // Should the camera have the viewport in them?
    // The do not currently hav a viewport.

    // Rendering text uses blending / transparency.
    if (GL) {
        GL.disable(GL.BLEND);
        GL.enable(GL.DEPTH_TEST);
    }

    if ( this.AnnotationLayer) {
        this.AnnotationLayer.Clear();
    }

    // If we are still waiting for tiles to load, schedule another render.
    // This works fine, but results in many renders while waiting.
    // TODO: Consider having the tile load callback scheduling the next render.
    if ( ! this.MainView.DrawTiles() ) {
        this.EventuallyRender();
    }

    // This is only necessary for webgl, Canvas2d just uses a border.
    this.MainView.DrawOutline(false);
    this.AnnotationLayer.Draw();
    // This is not used anymore
    this.MainView.DrawShapes();
    if (this.OverView) {
        this.OverView.DrawTiles();
        this.OverView.DrawOutline(true);
    }


    // Draw a rectangle in the overview representing the camera's view.
    if (this.OverView) {
        this.MainView.Camera.Draw(this.OverView);
        if (this.HistoryFlag) {
            this.OverView.DrawHistory(this.MainView.Viewport[3]);
        }
    }

    var cache = this.GetCache();
    if (cache != undefined) {
        var copyright = cache.Image.copyright;
        //this.MainView.DrawCopyright(copyright);
    }

    // TODO: Drawing correlations should not be embedded in a single
    // viewer. Maybe dualViewWidget or a new stack object should handle it.

    // I am using shift for stack interaction.
    // Turn on the focal point when shift is pressed.
    if (SA.StackCursorFlag && SA.Edit) {
        this.MainView.DrawFocalPoint();
        if (this.StackCorrelations) {
            this.MainView.DrawCorrelations(this.StackCorrelations, this.RecordIndex);
        }
    }

    // Here to trigger SA.FinishedLoadingCallbacks
    LoadQueueUpdate();
    //console.timeEnd("ViewerDraw");
    this.Drawing = false;
}

// Makes the viewer clean to setup a new slide...
Viewer.prototype.Reset = function() {
    this.SetCache(null);
    if (this.AnnotationLayer) {
        this.AnnotationLayer.Reset();
    }
    this.MainView.ShapeList = [];
}

// A list of shapes to render in the viewer
Viewer.prototype.AddShape = function(shape) {
    this.MainView.AddShape(shape);
}

Viewer.prototype.Animate = function() {
    if (this.AnimateDuration <= 0.0) {
        return;
    }
    var timeNow = new Date().getTime();
    if (timeNow >= (this.AnimateLast + this.AnimateDuration)) {
        this.AnimateDuration = 0;
        // We have past the target. Just set the target values.
        this.MainView.Camera.SetHeight(this.ZoomTarget);
        this.MainView.Camera.Roll = this.RollTarget;
        if (this.OverView) {
            //this.OverView.Camera.Roll = this.RollTarget;
            var roll = this.RollTarget;
            this.OverView.CanvasDiv.css({'transform':'rotate('+roll+'rad'});
            this.OverView.Camera.Roll = 0;
            this.OverView.Camera.ComputeMatrix();
        }
        this.MainView.Camera.SetFocalPoint( [this.TranslateTarget[0],
                                             this.TranslateTarget[1]]);
        this.UpdateZoomGui();
        // Save the state when the animation is finished.
        if (RECORDER_WIDGET) {
            RECORDER_WIDGET.RecordState();
        }
    } else {
        // Interpolate
        var currentHeight = this.MainView.Camera.GetHeight();
        var currentCenter = this.MainView.Camera.GetFocalPoint();
        var currentRoll   = this.MainView.Camera.Roll;
        this.MainView.Camera.SetHeight(
            currentHeight + (this.ZoomTarget-currentHeight)
                *(timeNow-this.AnimateLast)/this.AnimateDuration);
        this.MainView.Camera.Roll
            = currentRoll + (this.RollTarget-currentRoll)
            *(timeNow-this.AnimateLast)/this.AnimateDuration;
        if (this.OverView) {
            //this.OverView.Camera.Roll = this.MainView.Camera.Roll;
            var roll = this.MainView.Camera.Roll;
            this.OverView.CanvasDiv.css({'transform':'rotate('+roll+'rad'});
            this.OverView.Camera.Roll = 0;
            this.OverView.Camera.ComputeMatrix();
        }
        this.MainView.Camera.SetFocalPoint(
            [currentCenter[0] + (this.TranslateTarget[0]-currentCenter[0])
                *(timeNow-this.AnimateLast)/this.AnimateDuration,
             currentCenter[1] + (this.TranslateTarget[1]-currentCenter[1])
                *(timeNow-this.AnimateLast)/this.AnimateDuration]);
        this.AnimateDuration -= (timeNow-this.AnimateLast);
        // We are not finished yet.
        // Schedule another render
        this.EventuallyRender(true);
    }
    this.MainView.Camera.ComputeMatrix();
    if (this.OverView) {
        this.OverView.Camera.ComputeMatrix();
    }
    this.AnimateLast = timeNow;
    // Synchronize cameras is necessary
}

Viewer.prototype.OverViewPlaceCamera = function(x, y) {
    if ( ! this.OverView) {
        return;
    }
    // Compute focal point from inverse overview camera.
    x = x/this.OverView.Viewport[2];
    y = y/this.OverView.Viewport[3];
    x = (x*2.0 - 1.0)*this.OverView.Camera.Matrix[15];
    y = (1.0 - y*2.0)*this.OverView.Camera.Matrix[15];
    var m = this.OverView.Camera.Matrix;
    var det = m[0]*m[5] - m[1]*m[4];
    var xNew = (x*m[5]-y*m[4]+m[4]*m[13]-m[5]*m[12]) / det;
    var yNew = (y*m[0]-x*m[1]-m[0]*m[13]+m[1]*m[12]) / det;

    // Animate to get rid of jerky panning (overview to low resolution).
    this.TranslateTarget[0] = xNew;
    this.TranslateTarget[1] = yNew;
    this.AnimateLast = new Date().getTime();
    this.AnimateDuration = 100.0;
    this.EventuallyRender(true);
}

Viewer.prototype.SetInteractionEnabled = function(enabled) {
    this.InteractionEnabled = enabled;
}
Viewer.prototype.EnableInteraction = function() {
    this.InteractionEnabled = true;
}
Viewer.prototype.DisableInteraction = function() {
    this.InteractionEnabled = false;
}

// Used to be in EventManager. 
// TODO: Evaluate and cleanup.
Viewer.prototype.RecordMouseDown = function(event) {
    // Evaluate where LastMouseX / Y are used.
    this.LastMouseX = this.MouseX || 0;
    this.LastMouseY = this.MouseY || 0;
    this.LastMouseTime = this.MouseTime || 0;
    this.SetMousePositionFromEvent(event);

    // TODO:  Formalize a call back to make GUI disappear when
    // navigation starts.  I think I did this already but have not
    // converted this code yet.
    // Get rid of the favorites and the link divs if they are visible
    if ( SA.LinkDiv && SA.LinkDiv.is(':visible')) {
	      SA.LinkDiv.fadeOut();
    }
    if (typeof FAVORITES_WIDGET !== 'undefined' &&
	      FAVORITES_WIDGET.hidden == false) {
	      FAVORITES_WIDGET.ShowHideFavorites();
    }

    var date = new Date();
    var dTime = date.getTime() - this.MouseUpTime;
    if (dTime < 200.0) { // 200 milliseconds
        this.DoubleClick = true;
    }

    //this.TriggerStartInteraction();
}
// Used to be in EventManager. 
// TODO: Evaluate and cleanup.
Viewer.prototype.SetMousePositionFromEvent = function(event) {
    if (event.offsetX && event.offsetY) {
        this.MouseX = event.offsetX;
        this.MouseY = event.offsetY;
        this.MouseTime = (new Date()).getTime();
    } else if (event.layerX && event.layerY) {
        this.MouseX = event.layerX;
        this.MouseY = event.layerY;
        this.MouseTime = (new Date()).getTime();
        event.offsetX = event.layerX;
        event.offsetY = event.layerY;
    }
}
Viewer.prototype.RecordMouseMove = function(event) {
    this.LastMouseX = this.MouseX;
    this.LastMouseY = this.MouseY;
    this.LastMouseTime = this.MouseTime;
    this.SetMousePositionFromEvent(event);
    this.MouseDeltaX = this.MouseX - this.LastMouseX;
    this.MouseDeltaY = this.MouseY - this.LastMouseY;
    this.MouseDeltaTime = this.MouseTime - this.LastMouseTime;
    return this.MouseDeltaX != 0 || this.MouseDeltaY != 0;
}
Viewer.prototype.RecordMouseUp = function(event) {
    this.SetMousePositionFromEvent(event);
    this.MouseDown = false;

    // Record time so we can detect double click.
    var date = new Date();
    this.MouseUpTime = date.getTime();
    this.DoubleClick = false;
}



/**/
// Save the previous touches and record the new
// touch locations in viewport coordinates.
Viewer.prototype.HandleTouch = function(e, startFlag) {
    var date = new Date();
    var t = date.getTime();
    // I have had trouble on the iPad with 0 delta times.
    // Lets see how it behaves with fewer events.
    // It was a bug in iPad4 Javascript.
    // This throttle is not necessary.
    if (t-this.Time < 20 && ! startFlag) { return false; }

    this.LastTime = this.Time;
    this.Time = t;

    if (!e) {
        var e = event;
    }

    // Still used on mobile devices?
    var viewport = this.GetViewport();
    this.LastTouches = this.Touches;
    var can = this.Canvas;
    this.Touches = [];
    for (var i = 0; i < e.targetTouches.length; ++i) {
        var offset = this.MainView.Canvas.offset();
        var x = e.targetTouches[i].pageX - offset.left;
        var y = e.targetTouches[i].pageY - offset.top;
        this.Touches.push([x,y]);
    }

    this.LastMouseX = this.MouseX;
    this.LastMouseY = this.MouseY;

    // Compute the touch average.
    var numTouches = this.Touches.length;
    this.MouseX = this.MouseY = 0.0;
    for (var i = 0; i < numTouches; ++i) {
        this.MouseX += this.Touches[i][0];
        this.MouseY += this.Touches[i][1];
    }
    this.MouseX = this.MouseX / numTouches;
    this.MouseY = this.MouseY / numTouches;

    // Hack because we are moving away from using the event manager
    // Mouse interaction are already independant...
    this.offsetX = this.MouseX;
    this.offsetY = this.MouseY;

    return true;
}

Viewer.prototype.HandleTouchStart = function(event) {
    if ( ! this.InteractionEnabled) { return true; }

    // Stuff from event manager
    this.HandleTouch(event, true);
    if (this.StartTouchTime == 0) {
        this.StartTouchTime = this.Time;
    }

    SA.TriggerStartInteraction();

    this.MomentumX = 0.0;
    this.MomentumY = 0.0;
    this.MomentumRoll = 0.0;
    this.MomentumScale = 0.0;
    if (this.MomentumTimerId) {
        window.cancelAnimationFrame(this.MomentumTimerId)
        this.MomentumTimerId = 0;
    }

    // Four finger grab resets the view.
    if ( this.Touches.length >= 4) {
        var cam = this.GetCamera();
        var bds = this.MainView.Section.GetBounds();
        cam.SetFocalPoint( [(bds[0]+bds[1])*0.5, (bds[2]+bds[3])*0.5]);
        cam.Roll = 0.0;
        cam.SetHeight(bds[3]-bds[2]);
        cam.ComputeMatrix();
        this.EventuallyRender();
        // Return value hides navigation widget
        return true;
    }

    // See if any widget became active.
    /*
    if (this.AnnotationLayer && this.AnnotationLayer.GetVisibility()) {
        // TODO:
        // I do not like storing these ivars in this object.
        // I think the widgets rely on them being in the layer.
        this.MouseX = event.Touches[touchIdx][0];
        this.MouseY = event.Touches[touchIdx][1];
        this.MouseWorld = this.ComputeMouseWorld(event);
        return this.AnnotationLayer.HandleTouchStart(event,viewer);
    }
    */
    return false;
}


Viewer.prototype.HandleTouchMove = function(e) {
    // Put a throttle on events
    if ( ! this.HandleTouch(e, false)) { return; }

    if (SA.DualDisplay.NavigationWidget && 
        SA.DualDisplay.NavigationWidget.Visibility) {
        // No slide interaction with the interface up.
        // I had bad interaction with events going to browser.
        SA.DualDisplay.NavigationWidget.ToggleVisibility();
    }

    if (typeof(MOBILE_ANNOTATION_WIDGET) != "undefined" && 
               MOBILE_ANNOTATION_WIDGET.Visibility) {
        // No slide interaction with the interface up.
        // I had bad interaction with events going to browser.
        MOBILE_ANNOTATION_WIDGET.ToggleVisibility();
    }

    if (this.Touches.length == 1) {
        this.HandleTouchPan(this);
        return;
    }
    if (this.Touches.length == 2) {
        this.HandleTouchPinch(this);
        return
    }
    if (this.Touches.length == 3) {
        this.HandleTouchRotate(this);
        return
    }
}


// Only one touch
Viewer.prototype.HandleTouchPan = function(event) {
    if ( ! this.InteractionEnabled) { return true; }
    if (this.Touches.length != 1 || this.LastTouches.length != 1) {
        // Sanity check.
        return;
    }

    // Forward the events to the widget if one is active.
    /*
    if (this.AnnotationLayer && this.AnnotationLayer.GetVisibility() &&
        ! this.AnnotationLayer.HandleTouchPan(event, this)) {
        return false;
    }
    */

    // I see an odd intermittent camera matrix problem
    // on the iPad that looks like a thread safety issue.
    if (this.MomentumTimerId) {
        window.cancelAnimationFrame(this.MomentumTimerId)
        this.MomentumTimerId = 0;
    }

    // Convert to world by inverting the camera matrix.
    // I could simplify and just process the vector.
    w0 = this.ConvertPointViewerToWorld(this.LastMouseX, this.LastMouseY);
    w1 = this.ConvertPointViewerToWorld(    this.MouseX,     this.MouseY);

    // This is the new focal point.
    var dx = w1[0] - w0[0];
    var dy = w1[1] - w0[1];
    var dt = event.Time - this.LastTime;

    // Remember the last motion to implement momentum.
    var momentumX = dx/dt;
    var momentumY = dy/dt;

    // Integrate momentum over a time period to avoid a fast event
    // dominating behavior.
    var k = Math.min(this.Time - this.LastTime, 250) / 250;
    this.MomentumX += (momentumX-this.MomentumX)*k;
    this.MomentumY += (momentumY-this.MomentumY)*k;
    this.MomentumRoll = 0.0;
    this.MomentumScale = 0.0;

    var cam = this.GetCamera();
    cam.Translate( -dx, -dy, 0);
    cam.ComputeMatrix();
    this.EventuallyRender(true);
}

Viewer.prototype.HandleTouchRotate = function(event) {
    if ( ! this.InteractionEnabled) { return true; }
    var numTouches = this.Touches.length;
    if (this.LastTouches.length != numTouches || numTouches  != 3) {
        // Sanity check.
        return;
    }

    // I see an odd intermittent camera matrix problem
    // on the iPad that looks like a thread safety issue.
    if (this.MomentumTimerId) {
        window.cancelAnimationFrame(this.MomentumTimerId)
        this.MomentumTimerId = 0;
    }

    w0 = this.ConvertPointViewerToWorld(this.LastMouseX, this.LastMouseY);
    w1 = this.ConvertPointViewerToWorld(    this.MouseX,     this.MouseY);
    var dt = event.Time - this.LastTime;

    // Compute rotation.
    // Consider weighting rotation by vector length to avoid over contribution of short vectors.
    // We could also take the maximum.
    var x;
    var y;
    var a = 0;
    for (var i = 0; i < numTouches; ++i) {
        x = this.LastTouches[i][0] - this.LastMouseX;
        y = this.LastTouches[i][1] - this.LastMouseY;
        var a1  = Math.atan2(y,x);
        x = this.Touches[i][0] - this.MouseX;
        y = this.Touches[i][1] - this.MouseY;
        a1 = a1 - Math.atan2(y,x);
        if (a1 > Math.PI) { a1 = a1 - (2*Math.PI); }
        if (a1 < -Math.PI) { a1 = a1 + (2*Math.PI); }
        a += a1;
    }
    a = a / numTouches;

    // rotation and scale are around the mid point .....
    // we need to compute focal point height and roll (not just a matrix).
    // Focal point is the only difficult item.
    var cam = this.GetCamera();
    w0[0] = cam.FocalPoint[0] - w1[0];
    w0[1] = cam.FocalPoint[1] - w1[1];
    var c = Math.cos(a);
    var s = Math.sin(a);
    // This is the new focal point.
    x = w1[0] + (w0[0]*c - w0[1]*s);
    y = w1[1] + (w0[0]*s + w0[1]*c);

    // Remember the last motion to implement momentum.
    var momentumRoll = a/dt;

    this.MomentumX = 0.0;
    this.MomentumY = 0.0;
    this.MomentumRoll = (this.MomentumRoll + momentumRoll) * 0.5;
    this.MomentumScale = 0.0;

    cam.Roll = cam.Roll - a;
    cam.ComputeMatrix();
    if (this.OverView) {
        var cam2 = this.OverView.Camera;
        cam2.Roll = cam.Roll;
        cam2.ComputeMatrix();
    }
    this.EventuallyRender(true);
}

Viewer.prototype.HandleTouchPinch = function(event) {
    if ( ! this.InteractionEnabled) { return true; }
    var numTouches = this.Touches.length;
    if (this.LastTouches.length != numTouches || numTouches  != 2) {
        // Sanity check.
        return;
    }

    // I see an odd intermittent camera matrix problem
    // on the iPad that looks like a thread safety issue.
    if (this.MomentumTimerId) {
        window.cancelAnimationFrame(this.MomentumTimerId)
        this.MomentumTimerId = 0;
    }

    w0 = this.ConvertPointViewerToWorld(this.LastMouseX, this.LastMouseY);
    w1 = this.ConvertPointViewerToWorld(    this.MouseX,     this.MouseY);
    var dt = event.Time - this.LastTime;
    // iPad / iPhone must have low precision time
    if (dt == 0) {
        return;
    }

    // Compute scale.
    // Consider weighting rotation by vector length to avoid over contribution of short vectors.
    // We could also take max.
    // This should rarely be an issue and could only happen with 3 or more touches.
    var scale = 1;
    var s0 = 0;
    var s1 = 0;
    for (var i = 0; i < numTouches; ++i) {
        x = this.LastTouches[i][0] - this.LastMouseX;
        y = this.LastTouches[i][1] - this.LastMouseY;
        s0 += Math.sqrt(x*x + y*y);
        x = this.Touches[i][0] - this.MouseX;
        y = this.Touches[i][1] - this.MouseY;
        s1 += Math.sqrt(x*x + y*y);
    }
    // This should not happen, but I am having trouble with NaN camera parameters.
    if (s0 < 2 || s1 < 2) {
         return;
    }
    scale = s1/ s0;

    // Forward the events to the widget if one is active.
    //if (this.AnnotationLayer && this.AnnotationLayer.GetVisibility() &&
    //    ! this.AnnotationLayer.HandleTouchPinch(event, this)) {
    //    return false;
    //}

    // scale is around the mid point .....
    // we need to compute focal point height and roll (not just a matrix).
    // Focal point is the only difficult item.
    var cam = this.GetCamera();
    w0[0] = cam.FocalPoint[0] - w1[0];
    w0[1] = cam.FocalPoint[1] - w1[1];
    // This is the new focal point.
    var x = w1[0] + w0[0] / scale;
    var y = w1[1] + w0[1] / scale;

    // Remember the last motion to implement momentum.
    var momentumScale = (scale-1)/dt;

    this.MomentumX = 0.0;
    this.MomentumY = 0.0;
    this.MomentumRoll = 0.0;
    this.MomentumScale = (this.MomentumScale + momentumScale) * 0.5;

    cam.FocalPoint[0] = x;
    cam.FocalPoint[1] = y;
    cam.SetHeight(cam.GetHeight() / scale);
    cam.ComputeMatrix();
    this.EventuallyRender(true);
}

Viewer.prototype.HandleTouchEnd = function(event) {
    if ( ! this.InteractionEnabled) { return true; }

    // Code from a conflict
    var t = new Date().getTime();
    this.LastTime = this.Time;
    this.Time = t;

    var k = Math.min(this.Time - this.LastTime, 250) / 250;

    this.MomentumX = this.MomentumX*(1-k);
    this.MomentumY = this.MomentumY*(1-k);
    this.MomentumRoll = this.MomentumRoll*(1-k);
    this.MomentumScale = this.MomentumScale*(1-k);

    t = t - this.StartTouchTime;
    if (event.targetTouches.length == 0 && MOBILE_DEVICE) {
        this.StartTouchTime = 0;
        if (t < 90) {
            // We should not have a navigation widget on mobile
            // devices. (maybe iPad?).
            if (SA.DualDisplay && SA.DualDisplay.NavigationWidget) {
                SA.DualDisplay.NavigationWidget.ToggleVisibility();
            }
            if (typeof(MOBILE_ANNOTATION_WIDGET) != "undefined") {
                MOBILE_ANNOTATION_WIDGET.ToggleVisibility();
            }
            return;
        }
        if (this.ActiveWidget != null) {
            this.ActiveWidget.HandleTouchEnd(event);
            return;
        }
        //this.UpdateZoomGui();
        this.HandleMomentum();
    }
    // end conflict


    // Forward the events to the widget if one is active.
    //if (this.AnnotationLayer && 
    //    this.AnnotationLayer.GetVisibility() &&
    //    ! this.AnnotationLayer.HandleTouchEnd(event, this)) {
    //    return false;
    //}

    //this.UpdateZoomGui();
    this.HandleMomentum(event);
}

Viewer.prototype.HandleMomentum = function() {
    // I see an odd intermittent camera matrix problem
    // on the iPad that looks like a thread safety issue.
    if (this.MomentumTimerId) {
        window.cancelAnimationFrame(this.MomentumTimerId)
        this.MomentumTimerId = 0;
    }

    var t = new Date().getTime();
    if (t - this.LastTime < 50) {
        var self = this;
        this.MomentumTimerId = requestAnimFrame(function () { self.HandleMomentum();});
        return;
    }

    // Integrate the momentum.
    this.LastTime = this.Time;
    this.Time = t;
    var dt = this.Time - this.LastTime;

    var k = 200.0;
    var decay = Math.exp(-dt/k);
    var integ = (-k * decay + k);

    var cam = this.MainView.Camera;
    cam.Translate(-(this.MomentumX * integ), -(this.MomentumY * integ), 0);
    cam.SetHeight(cam.Height / ((this.MomentumScale * integ) + 1));
    cam.Roll = cam.Roll - (this.MomentumRoll* integ);
    cam.ComputeMatrix();
    if (this.OverView) {
        var cam2 = this.OverView.Camera;
        cam2.Roll = cam.Roll;
        cam2.ComputeMatrix();
    }
    // I think the problem with the ipad is thie asynchronous render.
    // Maybe two renders occur at the same time.
    //this.EventuallyRender();
    draw();

    // Decay the momentum.
    this.MomentumX *= decay;
    this.MomentumY *= decay;
    this.MomentumScale *= decay;
    this.MomentumRoll *= decay;

    if (Math.abs(this.MomentumX) < 0.01 && Math.abs(this.MomentumY) < 0.01 &&
        Math.abs(this.MomentumRoll) < 0.0002 && Math.abs(this.MomentumScale) < 0.00005) {
        // Change is small. Stop the motion.
        this.MomentumTimerId = 0;
        if (this.InteractionState != INTERACTION_NONE) {
            this.InteractionState = INTERACTION_NONE;
            if (RECORDER_WIDGET) {
                RECORDER_WIDGET.RecordState();
            }
        }
        this.UpdateZoomGui();
    } else {
        var self = this;
        this.MomentumTimerId = requestAnimFrame(function () { self.HandleMomentum();});
    }
}


Viewer.prototype.ConstrainCamera = function () {
    var bounds = this.GetOverViewBounds();
    if ( ! bounds) {
        // Cache has not been set.
        return;
    }
    var spacing = this.MainView.GetLeafSpacing();
    var viewport = this.MainView.GetViewport();
    var cam = this.MainView.Camera;

    var modified = false;
    if (cam.FocalPoint[0] < bounds[0]) {
        cam.SetFocalPoint( [bounds[0], cam.FocalPoint[1]]);
        modified = true;
    }
    if (cam.FocalPoint[0] > bounds[1]) {
        cam.SetFocalPoint( [bounds[1], cam.FocalPoint[1]]);
        modified = true;
    }
    if (cam.FocalPoint[1] < bounds[2]) {
        cam.SetFocalPoint( [cam.FocalPoint[0], bounds[2]]);
        modified = true;
    }
    if (cam.FocalPoint[1] > bounds[3]) {
        cam.SetFocalPoint( [cam.FocalPoint[0], bounds[3]]);
        modified = true;
    }
    var heightMax = 2*(bounds[3]-bounds[2]);
    if (cam.GetHeight() > heightMax) {
        cam.SetHeight(heightMax);
        this.ZoomTarget = heightMax;
        modified = true;
    }
    var heightMin = viewport[3] * spacing * 0.5;
    if (cam.GetHeight() < heightMin) {
        cam.SetHeight(heightMin);
        this.ZoomTarget = heightMin;
        modified = true;
    }
    if (modified) {
        cam.ComputeMatrix();
    }
}

Viewer.prototype.HandleMouseDown = function(event) {
    if ( ! this.InteractionEnabled) { return true; }

    this.FireFoxWhich = event.which;
    event.preventDefault(); // Keep browser from selecting images.
    this.RecordMouseDown(event);

    if (this.RotateIconDrag) {
        // Problem with leaving the browser with mouse down.
        // This is a mouse down outside the icon, so the mouse must
        // have been let up and we did not get the event.
        this.RotateIconDrag = false;
    }

    if (this.DoubleClick) {
        // Without this, double click selects sub elementes.
        event.preventDefault();
        return this.HandleDoubleClick(event);
    }

    // Forward the events to the widget if one is active.
    //if (this.AnnotationLayer && this.AnnotationLayer.GetVisibility() &&
    //    ! this.AnnotationLayer.HandleMouseDown(event, this)) {
    //    return false;
    //}

    // Choose what interaction will be performed.
    if (event.which == 1 ) {
        if (event.ctrlKey) {
            this.InteractionState = INTERACTION_ROTATE;
        } else if (event.altKey) {
            this.InteractionState = INTERACTION_ZOOM;
        } else {
            this.InteractionState = INTERACTION_DRAG;
        }
        return false;
    }
    if (event.which == 2 ) {
        this.InteractionState = INTERACTION_ROTATE;
        return false;
    }
    return true;
}

Viewer.prototype.HandleDoubleClick = function(event) {
    if ( ! this.InteractionEnabled) { return true; }

    // Forward the events to the widget if one is active.
    //if (this.AnnotationLayer && this.AnnotationLayer.GetVisibility() &&
    //    ! this.AnnotationLayer.HandleDoubleClick(event, this)) {
    //    return false;
    //}

    mWorld = this.ConvertPointViewerToWorld(event.offsetX, event.offsetY);
    if (event.which == 1) {
        this.AnimateZoomTo(0.5, mWorld);
    } else if (event.which == 3) {
        this.AnimateZoomTo(2.0, mWorld);
    }
    return true;
}

Viewer.prototype.HandleMouseUp = function(event) {
    if ( ! this.InteractionEnabled) { return true; }
    var date = new Date();
    this.MouseUpTime = date.getTime();
    this.FireFoxWhich = 0;
    this.RecordMouseUp(event);

    if (this.RotateIconDrag) {
        this.RollUp(event);
        return false;
    }

    if (this.InteractionState == INTERACTION_OVERVIEW ||
        this.InteractionState == INTERACTION_OVERVIEW_DRAG) {
        return this.HandleOverViewMouseUp(event);
    }

    // Forward the events to the widget if one is active.
    //if (this.AnnotationLayer && this.AnnotationLayer.GetVisibility() &&
    //    ! this.AnnotationLayer.HandleMouseUp(event, this)) {
    //    return false;
    //}

    if (this.InteractionState != INTERACTION_NONE) {
        this.InteractionState = INTERACTION_NONE;
        if (RECORDER_WIDGET) {
            RECORDER_WIDGET.RecordState();
        }
    }

    return false; // trying to keep the browser from selecting images
}

/*
Viewer.prototype.ComputeMouseWorld = function(event) {
    // We need to save these for pasting annotation.
    this.MouseWorld = this.ConvertPointViewerToWorld(event.offsetX, event.offsetY);
    // Put this extra ivar in the even object.
    // This could be obsolete because we never pass this event to another object.
    event.worldX = this.MouseWorld[0];
    event.worldY= this.MouseWorld[1];
    // NOTE: DANGER!  user could change this pointer.
    return this.MouseWorld;
}
*/

Viewer.prototype.HandleMouseMove = function(event) {
    if ( ! this.InteractionEnabled) { return true; }

    // The event position is relative to the target which can be a tab on
    // top of the canvas.  Just skip these events.
    if ($(event.target).width() != $(event.currentTarget).width()) {
        return true;
    }


    // TODO: Get rid of this. Should be done with image properties.
    //event.preventDefault(); // Keep browser from selecting images.
    if ( ! this.RecordMouseMove(event)) { return true; }
    //this.ComputeMouseWorld(event);

    // I think we need to deal with the move here because the mouse can
    // exit the icon and the events are lost.
    if (this.RotateIconDrag) {
        this.RollMove(event);
        return false;
    }

    if (this.InteractionState == INTERACTION_OVERVIEW ||
        this.InteractionState == INTERACTION_OVERVIEW_DRAG) {
        return this.HandleOverViewMouseMove(event);
    }

    // Forward the events to the widget if one is active.
    //if (this.AnnotationLayer && this.AnnotationLayer.GetVisibility() &&
    //    ! this.AnnotationLayer.HandleMouseMove(event, this)) {
    //    return false;
    //}

    if (this.InteractionState == INTERACTION_NONE) {
        // Allow the ResizePanel drag to process the events.
        return true;
    }

    var x = event.offsetX;
    var y = event.offsetY;

    // Drag camera in main view.
    // Dragging is too slow.  I want to accelerate dragging the further
    // this mouse moves.  This is a moderate change, so I am
    // going to try to accelerate with speed.
    if (this.InteractionState == INTERACTION_ROTATE) {
        // Rotate
        // Origin in the center.
        // GLOBAL GL will use view's viewport instead.
        var cx = x - (this.MainView.Viewport[2]*0.5);
        var cy = y - (this.MainView.Viewport[3]*0.5);
        // GLOBAL views will go away when views handle this.
        this.MainView.Camera.HandleRoll(cx, cy,
                                        this.MouseDeltaX,
                                        this.MouseDeltaY);
        this.RollTarget = this.MainView.Camera.Roll;
        this.UpdateCamera();
    } else if (this.InteractionState == INTERACTION_ZOOM) {
        var dy = this.MouseDeltaY / this.MainView.Viewport[2];
        this.MainView.Camera.SetHeight(this.MainView.Camera.GetHeight()
                                       / (1.0 + (dy* 5.0)));
        this.ZoomTarget = this.MainView.Camera.GetHeight();
        this.UpdateCamera();
    } else if (this.InteractionState == INTERACTION_DRAG) {

        // Translate
        // Convert to view [-0.5,0.5] coordinate system.
        // Note: the origin gets subtracted out in delta above.
        var dx = -this.MouseDeltaX / this.MainView.Viewport[2];
        var dy = -this.MouseDeltaY / this.MainView.Viewport[2];
        // compute the speed of the movement.
        var speed = Math.sqrt(dx*dx + dy*dy) / this.MouseDeltaTime;
        speed = 1.0 + speed*1000; // f(0) = 1 and increasing.
        // I am not sure I like the speed acceleration.
        // Lets try a limit.
        if (speed > 3.0) { speed = 3.0; }
        dx = dx * speed;
        dy = dy * speed;
        this.MainView.Camera.HandleTranslate(dx, dy, 0.0);
    }
    // The only interaction that does not go through animate camera.
    this.TriggerInteraction();
    this.EventuallyRender(true);

    var x = event.offsetX;
    var y = event.offsetY;

    return false; 
}

Viewer.prototype.HandleMouseWheel = function(event) {
    if ( ! this.InteractionEnabled) { return true; }

    // Forward the events to the widget if one is active.
    //if (this.AnnotationLayer && this.AnnotationLayer.GetVisibility() &&
    //    ! this.AnnotationLayer.HandleMouseWheel(event, this)) {
    //    return false;
    //}

    if ( ! event.offsetX) {
        // for firefox
        event.offsetX = event.layerX;
        event.offsetY = event.layerY;
    }

    // We want to accumulate the target, but not the duration.
    var tmp = 0;
    if (event.deltaY) {
        tmp = event.deltaY;
    } else if (event.wheelDelta) {
        tmp = event.wheelDelta;
    }
    // Wheel event seems to be in increments of 3.
    // depreciated mousewheel had increments of 120....
    // Initial delta cause another bug.
    // Lets restrict to one zoom step per event.
    if (tmp > 0) {
        this.ZoomTarget *= 1.1;
    } else if (tmp < 0) {
        this.ZoomTarget /= 1.1;
    }

    // Compute translate target to keep position in the same place.
    //this.TranslateTarget[0] = this.MainView.Camera.FocalPoint[0];
    //this.TranslateTarget[1] = this.MainView.Camera.FocalPoint[1];
    var position = this.ConvertPointViewerToWorld(event.offsetX, event.offsetY);
    var factor = this.ZoomTarget / this.MainView.Camera.GetHeight();
    this.TranslateTarget[0] = position[0]
        - factor * (position[0] - this.MainView.Camera.FocalPoint[0]);
    this.TranslateTarget[1] = position[1]
        - factor * (position[1] - this.MainView.Camera.FocalPoint[1]);

    this.RollTarget = this.MainView.Camera.Roll;

    this.AnimateLast = new Date().getTime();
    this.AnimateDuration = 200.0; // hard code 200 milliseconds
    this.EventuallyRender(true);
    return false;
}

// returns false if the event was "consumed" (browser convention).
// Returns true if nothing was done with the event.
Viewer.prototype.HandleKeyDown = function(event) {
    if ( ! this.InteractionEnabled) { return true; }
    if (event.keyCode == 83 && event.ctrlKey) { // control -s to save.
        if ( ! SAVING_IMAGE) {
            SAVING_IMAGE = new SAM.Dialog();
            SAVING_IMAGE.Title.text('Saving');
            SAVING_IMAGE.Body.css({'margin':'1em 2em'});
            SAVING_IMAGE.WaitingImage = $('<img>')
                .appendTo(SAVING_IMAGE.Body)
                .attr("src", SA.ImagePathUrl+"circular.gif")
                .attr("alt", "waiting...")
                .addClass("sa-view-save")
            SAVING_IMAGE.ApplyButton.hide();
            SAVING_IMAGE.SavingFlag = false;
            SAVING_IMAGE.Count = 0;
        }
        if ( ! SAVING_IMAGE.SavingFlag) {
            SAVING_IMAGE.SavingFlag = true;
            SAVING_IMAGE.Show(1);
            this.EventuallySaveImage("slideAtlas"+ZERO_PAD(SAVING_IMAGE.Count,3),
                                     function() {
                                         SAVING_IMAGE.SavingFlag = false;
                                         SAVING_IMAGE.Count += 1;
                                         SAVING_IMAGE.Hide();
                                     });
        }
        return false;
    }

    // Handle paste
    if (event.keyCode == 86 && event.ctrlKey) {
        // control-v for paste

        var clip = JSON.parse(localStorage.ClipBoard);
        var camera;
        if (clip.Camera) {
            camera = new Camera();
            camera.Load(clip.Camera);
        }
        if (clip.Type == "CircleWidget") {
            var widget = new CircleWidget(this, false);
            widget.PasteCallback(clip.Data, this.MouseWorld, camera);
        }
        if (clip.Type == "PolylineWidget") {
            var widget = new PolylineWidget(this, false);
            widget.PasteCallback(clip.Data, this.MouseWorld, camera);
        }
        if (clip.Type == "TextWidget") {
            var widget = new TextWidget(this, "");
            widget.PasteCallback(clip.Data, this.MouseWorld, camera);
        }
        if (clip.Type == "RectWidget") {
            var widget = new RectWidget(this, "");
            widget.PasteCallback(clip.Data, this.MouseWorld, camera);
        }
        if (clip.Type == "GridWidget") {
            var widget = new GridWidget(this, "");
            widget.PasteCallback(clip.Data, this.MouseWorld, camera);
        }

        return false;
    }

    //----------------------
    // Forward the events to the widget if one is active.
    //if (this.AnnotationLayer && this.AnnotationLayer.GetVisibility() &&
    //    ! this.AnnotationLayer.HandleKeyDown(event, this)) {
    //    return false;
    //}

    if (String.fromCharCode(event.keyCode) == 'R') {
        //this.MainView.Camera.Reset();
        this.MainView.Camera.ComputeMatrix();
        this.ZoomTarget = this.MainView.Camera.GetHeight();
        this.EventuallyRender(true);
        return false;
    }

    if (event.keyCode == 38) {
        // Up cursor key
        var cam = this.GetCamera();
        var c = Math.cos(cam.Roll);
        var s = -Math.sin(cam.Roll);
        var dx = 0.0;
        var dy = -0.9 * cam.GetHeight();
        var rx = dx*c - dy*s;
        var ry = dx*s + dy*c;
        this.TranslateTarget[0] = cam.FocalPoint[0] + rx;
        this.TranslateTarget[1] = cam.FocalPoint[1] + ry;
        this.AnimateLast = new Date().getTime();
        this.AnimateDuration = 200.0;
        this.EventuallyRender(true);
        return false;
    } else if (event.keyCode == 40) {
        // Down cursor key
        var cam = this.GetCamera();
        var c = Math.cos(cam.Roll);
        var s = -Math.sin(cam.Roll);
        var dx = 0.0;
        var dy = 0.9 * cam.GetHeight();
        var rx = dx*c - dy*s;
        var ry = dx*s + dy*c;
        this.TranslateTarget[0] = cam.FocalPoint[0] + rx;
        this.TranslateTarget[1] = cam.FocalPoint[1] + ry;
        this.AnimateLast = new Date().getTime();
        this.AnimateDuration = 200.0;
        this.EventuallyRender(true);
        return false;
    } else if (event.keyCode == 37) {
        // Left cursor key
        var cam = this.GetCamera();
        var c = Math.cos(cam.Roll);
        var s = -Math.sin(cam.Roll);
        var dx = -0.9 * cam.GetWidth();
        var dy = 0.0;
        var rx = dx*c - dy*s;
        var ry = dx*s + dy*c;
        this.TranslateTarget[0] = cam.FocalPoint[0] + rx;
        this.TranslateTarget[1] = cam.FocalPoint[1] + ry;
        this.AnimateLast = new Date().getTime();
        this.AnimateDuration = 200.0;
        this.EventuallyRender(true);
        return false;
    } else if (event.keyCode == 39) {
        // Right cursor key
        var cam = this.GetCamera();
        var c = Math.cos(cam.Roll);
        var s = -Math.sin(cam.Roll);
        var dx = 0.9 * cam.GetWidth();
        var dy = 0.0;
        var rx = dx*c - dy*s;
        var ry = dx*s + dy*c;
        this.TranslateTarget[0] = cam.FocalPoint[0] + rx;
        this.TranslateTarget[1] = cam.FocalPoint[1] + ry;
        this.AnimateLast = new Date().getTime();
        this.AnimateDuration = 200.0;
        this.EventuallyRender(true);
        return false;
    }
    return true;
}

// Get the current scale factor between pixels and world units.
Viewer.prototype.GetPixelsPerUnit = function() {
    return this.MainView.GetPixelsPerUnit();
}

// Convert a point from world coordiante system to viewer coordinate system (units pixels).
Viewer.prototype.ConvertPointWorldToViewer = function(x, y) {
    var cam = this.MainView.Camera;
    return cam.ConvertPointWorldToViewer(x, y);
}

Viewer.prototype.ConvertPointViewerToWorld = function(x, y) {
    var cam = this.MainView.Camera;
    return cam.ConvertPointViewerToWorld(x, y);
}


// Where else should I put this?
function colorNameToHex(color)
{
    var colors = {"aliceblue":"#f0f8ff","antiquewhite":"#faebd7","aqua":"#00ffff","aquamarine":"#7fffd4","azure":"#f0ffff",
                  "beige":"#f5f5dc","bisque":"#ffe4c4","black":"#000000","blanchedalmond":"#ffebcd","blue":"#0000ff","blueviolet":"#8a2be2","brown":"#a52a2a","burlywood":"#deb887",
                  "cadetblue":"#5f9ea0","chartreuse":"#7fff00","chocolate":"#d2691e","coral":"#ff7f50","cornflowerblue":"#6495ed","cornsilk":"#fff8dc","crimson":"#dc143c","cyan":"#00ffff",
                  "darkblue":"#00008b","darkcyan":"#008b8b","darkgoldenrod":"#b8860b","darkgray":"#a9a9a9","darkgreen":"#006400","darkkhaki":"#bdb76b","darkmagenta":"#8b008b","darkolivegreen":"#556b2f",
                  "darkorange":"#ff8c00","darkorchid":"#9932cc","darkred":"#8b0000","darksalmon":"#e9967a","darkseagreen":"#8fbc8f","darkslateblue":"#483d8b","darkslategray":"#2f4f4f","darkturquoise":"#00ced1",
                  "darkviolet":"#9400d3","deeppink":"#ff1493","deepskyblue":"#00bfff","dimgray":"#696969","dodgerblue":"#1e90ff",
                  "firebrick":"#b22222","floralwhite":"#fffaf0","forestgreen":"#228b22","fuchsia":"#ff00ff",
                  "gainsboro":"#dcdcdc","ghostwhite":"#f8f8ff","gold":"#ffd700","goldenrod":"#daa520","gray":"#808080","green":"#008000","greenyellow":"#adff2f",
                  "honeydew":"#f0fff0","hotpink":"#ff69b4",
                  "indianred ":"#cd5c5c","indigo ":"#4b0082","ivory":"#fffff0","khaki":"#f0e68c",
                  "lavender":"#e6e6fa","lavenderblush":"#fff0f5","lawngreen":"#7cfc00","lemonchiffon":"#fffacd","lightblue":"#add8e6","lightcoral":"#f08080","lightcyan":"#e0ffff","lightgoldenrodyellow":"#fafad2",
                  "lightgrey":"#d3d3d3","lightgreen":"#90ee90","lightpink":"#ffb6c1","lightsalmon":"#ffa07a","lightseagreen":"#20b2aa","lightskyblue":"#87cefa","lightslategray":"#778899","lightsteelblue":"#b0c4de",
                  "lightyellow":"#ffffe0","lime":"#00ff00","limegreen":"#32cd32","linen":"#faf0e6",
                  "magenta":"#ff00ff","maroon":"#800000","mediumaquamarine":"#66cdaa","mediumblue":"#0000cd","mediumorchid":"#ba55d3","mediumpurple":"#9370d8","mediumseagreen":"#3cb371","mediumslateblue":"#7b68ee",
                  "mediumspringgreen":"#00fa9a","mediumturquoise":"#48d1cc","mediumvioletred":"#c71585","midnightblue":"#191970","mintcream":"#f5fffa","mistyrose":"#ffe4e1","moccasin":"#ffe4b5",
                  "navajowhite":"#ffdead","navy":"#000080",
                  "oldlace":"#fdf5e6","olive":"#808000","olivedrab":"#6b8e23","orange":"#ffa500","orangered":"#ff4500","orchid":"#da70d6",
                  "palegoldenrod":"#eee8aa","palegreen":"#98fb98","paleturquoise":"#afeeee","palevioletred":"#d87093","papayawhip":"#ffefd5","peachpuff":"#ffdab9","peru":"#cd853f","pink":"#ffc0cb","plum":"#dda0dd","powderblue":"#b0e0e6","purple":"#800080",
                  "red":"#ff0000","rosybrown":"#bc8f8f","royalblue":"#4169e1",
                  "saddlebrown":"#8b4513","salmon":"#fa8072","sandybrown":"#f4a460","seagreen":"#2e8b57","seashell":"#fff5ee","sienna":"#a0522d","silver":"#c0c0c0","skyblue":"#87ceeb","slateblue":"#6a5acd","slategray":"#708090","snow":"#fffafa","springgreen":"#00ff7f","steelblue":"#4682b4",
                  "tan":"#d2b48c","teal":"#008080","thistle":"#d8bfd8","tomato":"#ff6347","turquoise":"#40e0d0",
                  "violet":"#ee82ee",
                  "wheat":"#f5deb3","white":"#ffffff","whitesmoke":"#f5f5f5",
                  "yellow":"#ffff00","yellowgreen":"#9acd32"};

    if (typeof colors[color.toLowerCase()] != 'undefined')
        return colors[color.toLowerCase()];

    return false;
}





//==============================================================================
// OverView slide widget stuff.

Viewer.prototype.OverViewCheckActive = function(event) {
    if ( ! this.OverView) {
        return false;
    }
    var x = event.offsetX;
    var y = event.offsetY;
    // Half height and width
    var hw = this.OverViewport[2]/2;
    var hh = this.OverViewport[3]/2;
    // Center of the overview.
    var cx = this.OverViewport[0]+hw;
    var cy = this.OverViewport[1]+hh;

    x = x-cx;
    y = y-cy;
    // Rotate into overview slide coordinates.
    var roll = this.MainView.Camera.Roll;
    var c = Math.cos(roll);
    var s = Math.sin(roll);
    var nx = Math.abs(c*x+s*y);
    var ny = Math.abs(c*y-s*x);
    if ((Math.abs(hw-nx) < 5 && ny < hh) ||
        (Math.abs(hh-ny) < 5 && nx < hw)) {
        this.OverViewActive = true;
        this.OverView.CanvasDiv.addClass("sa-view-overview-canvas sa-active");
    } else {
        this.OverViewActive = false;
        this.OverView.CanvasDiv.removeClass("sa-view-overview-canvas sa-active");
    }
    //return this.OverViewActive;
}





// Interaction events that change the main camera.


// Resize of overview window will be drag with left mouse.
// Reposition camera with left click (no drag).
// Removing drag camera in overview.

// TODO: Make the overview slide a widget.
Viewer.prototype.HandleOverViewMouseDown = function(event) {
    if ( ! this.InteractionEnabled) { return true; }
    if (this.RotateIconDrag) { return;}

    this.InteractionState = INTERACTION_OVERVIEW;

    // Delay actions until we see if it is a drag or click.
    this.OverviewEventX = event.pageX;
    this.OverviewEventY = event.pageY;

    return false;
}


Viewer.prototype.HandleOverViewMouseUp = function(event) {
    if ( ! this.InteractionEnabled) { return true; }
    if (this.RotateIconDrag) { return;}
    if (this.InteractionState == INTERACTION_OVERVIEW_DRAG)
    {
        this.InteractionState = INTERACTION_NONE;
        return;
    }

    // This target for animation is not implemented cleanly.
    // This fixes a bug: OverView translated rotates camamera back to zero.
    this.RollTarget = this.MainView.Camera.Roll;

    if (event.which == 1) {
        var x = event.offsetX;
        var y = event.offsetY;
        if (x == undefined) {x = event.layerX;}
        if (y == undefined) {y = event.layerY;}
        // Transform to view's coordinate system.
        this.OverViewPlaceCamera(x, y);
    }

    this.InteractionState = INTERACTION_NONE;

    return false;
}

Viewer.prototype.HandleOverViewMouseMove = function(event) {
    if ( ! this.InteractionEnabled) { return true; }
    if (this.RotateIconDrag) {
        this.RollMove(event);
        return false;
    }

    if (this.InteractionState == INTERACTION_OVERVIEW) {
        // Do not start dragging until the mouse has moved some distance.
        if (Math.abs(event.pageX - this.OverviewEventX) > 5 ||
            Math.abs(event.pageY - this.OverviewEventY) > 5) {
            // Start dragging the overview window.
            this.InteractionState = INTERACTION_OVERVIEW_DRAG;
            var w = this.GetViewport()[2];
            var p = Math.max(w-event.pageX,event.pageY);
            this.OverViewScaleLast = p;
        }
        return false;
    }

    // This consumes events even when I return true. Why?
    if (this.InteractionState !== INTERACTION_OVERVIEW_DRAG) {
        // Drag originated outside overview.
        // Could be panning.
        return true;
    }

    // Drag to change overview size
    var w = this.GetViewport()[2];
    var p = Math.max(w-event.pageX,event.pageY);
    var d = p/this.OverViewScaleLast;
    this.OverViewScale *= d*d;
    this.OverViewScaleLast = p;
    if (p < 60) {
        this.RotateIcon.hide();
    } else {
        this.RotateIcon.show();
    }

    // TODO: Get rid of this hack.
    $(window).trigger('resize');

    return false;
}

Viewer.prototype.HandleOverViewMouseWheel = function(event) {
    if ( ! this.InteractionEnabled) { return true; }
    var tmp = 0;
    if (event.deltaY) {
	      tmp = event.deltaY;
    } else if (event.wheelDelta) {
	      tmp = event.wheelDelta;
    }

    if (tmp > 0) {
        this.OverViewScale *= 1.2;
	  } else if (tmp < 0) {
        this.OverViewScale /= 1.2;
    }

    // TODO: Get rid of this hack.
    $(window).trigger('resize');

    return true;
}

Viewer.prototype.SetAnnotationWidgetVisibility = function(vis) {
    if (vis) {
        if ( ! this.AnnotationWidget) {
            this.AnnotationWidget = new AnnotationWidget(this.AnnotationLayer);
        }
        this.AnnotationWidget.show();
    } else {
        if ( this.AnnotationWidget) {
            this.AnnotationWidget.hide();
        }
    }
}

Viewer.prototype.SetZoomWidgetVisibility = function(vis) {
    if (vis) {
        if ( ! this.ZoomTab) {
            this.InitializeZoomGui();
        }
        this.ZoomTab.show();
    } else {
        if ( this.ZoomTab) {
            this.ZoomTab.hide();
        }
    }
}

Viewer.prototype.SetCopyrightVisibility = function(vis) {
    if (vis) {
        this.CopyrightWrapper.show();
    } else {
        this.CopyrightWrapper.hide();
    }
}



    SA.Viewer = Viewer;

})();








//==============================================================================
// A correlation is just a pair of matching points from two sections.
// Abstract the correlation so we have an api for getting points.
// Currently, stack has direct access to correlation ivars / points.
// The api will make forward and back transformations use the same code.


function PairCorrelation () {
    this.point0 = [0,0];
    this.point1 = [0,0];
    this.Roll = 0;
    this.Height = 0;
}



PairCorrelation.prototype.Serialize = function() {
    return {"point0": [this.point0[0],this.point0[1]],
            "point1": [this.point1[0],this.point1[1]],
            "roll":   this.Roll,
            "height": this.Height};
}


PairCorrelation.prototype.Load = function(obj) {
    this.point0[0] = obj.point0[0];
    this.point0[1] = obj.point0[1];
    this.point1[0] = obj.point1[0];
    this.point1[1] = obj.point1[1];
    if (obj.roll) {
        this.Roll = obj.roll;
    }
    if (obj.height) {
        this.Height = obj.height;
    }
}

// Idx changes the ordedr of the points and sign of delta roll.
PairCorrelation.prototype.GetRoll = function(idx) {
    if (idx !== undefined && idx == 0) {
        return -this.Roll;
    } else {
        return this.Roll;
    } 
}



PairCorrelation.prototype.GetPoint = function(idx) {
    if (idx == 0) {
        return this.GetPoint0();
    } else if (idx == 1) {
        return this.GetPoint1();
    } 
    alert("Bad correlation point index: " + idx);
    return [0,0];
}


PairCorrelation.prototype.GetPoint0 = function() {
    return [this.point0[0], this.point0[1]];
}

PairCorrelation.prototype.SetPoint0 = function(pt) {
    this.point0[0] = pt[0];
    this.point0[1] = pt[1];
}


PairCorrelation.prototype.GetPoint1 = function() {
    return [this.point1[0], this.point1[1]];
}

PairCorrelation.prototype.SetPoint1 = function(pt) {
    this.point1[0] = pt[0];
    this.point1[1] = pt[1];
}

PairCorrelation.prototype.SetRoll = function(roll) {
    this.Roll = roll;
}

PairCorrelation.prototype.SetHeight = function(height) {
    this.Height = height;
}



//==============================================================================
// This object abstract the warp transformation between a pair of sections.

function PairTransformation () {
    this.Correlations = [];
}


PairTransformation.prototype.Serialize = function() {
    return JSON.parse(JSON.stringify(this));
}


PairTransformation.prototype.Load = function(obj) {
    for (ivar in obj) {
        this[ivar] = obj[ivar];
    }
}


PairTransformation.prototype.AddCorrelation = function(pt0, pt1) {
    index = this.Correlations.length;
    var corr = new PairCorrelation();
    corr.SetPoint0(pt0);
    corr.SetPoint1(pt1);
    this.Correlations.push(corr);
    return index;
}


PairTransformation.prototype.Load = function(obj) {
    // Views are not used anymore for viewer record stacks.
    if (obj.View0) {
        this.View0 = obj.View0;
    }
    if (obj.View1) {
        this.View1 = obj.View1;
    }
    for (var i = 0; i < obj.Correlations.length; ++i) {
        var correlation = new PairCorrelation();
        correlation.Load(obj.Correlations[i]);
        this.Correlations.push(correlation);
    }
}


// Weighted neighbor.
// Until we implement a closed form solution:
// Compute the weighted average of points as center of rotation and translation.
PairTransformation.prototype.WeightedTransform = function(idx0, idx1, fpIn, sigma) {
    var fpOut = [fpIn[0], fpIn[1]];
    if (this.Correlations.length == 0) {
        return fpOut;
    }

    if (sigma === undefined) {
        sigma = 20000;
    }

    if (this.Correlations.length == 0) {
        fpOut[0] = fpIn[0]; 
        fpOut[1] = fpIn[1];
        this.DeltaRoll = 0;
        return fpOut;
    }

    if (this.Correlations.length <= 1) {
        var correlation = this.Correlations[0];
        this.DeltaRoll = correlation.GetRoll(idx1);
        pt0 = correlation.GetPoint(idx0);
        var dx = fpIn[0] - pt0[0];
        var dy = fpIn[1] - pt0[1];
        var c = Math.cos(this.DeltaRoll);
        var s = Math.sin(this.DeltaRoll);
        pt1 = correlation.GetPoint(idx1);
        fpOut[0] = c*dx + s*dy + pt1[0];
        fpOut[1] = c*dy - s*dx + pt1[1];
        return fpOut;
    }

    // Compute the average weighted correlation point for each image.
    var pt0,pt1;
    var x,y;
    var sigma2 = sigma*sigma;
    var sumGauss = 0.0;
    var sum0 = [0.0, 0.0];
    var sum1 = [0.0, 0.0];
    for ( var i = 0; i < this.Correlations.length; ++i) {
        var correlation = this.Correlations[i];
        pt0 = correlation.GetPoint(idx0);
        pt1 = correlation.GetPoint(idx1);
        // Distance from the focal point being transformed (for weight)
        x = pt0[0] - fpIn[0];
        y = pt0[1] - fpIn[1];
        var dist2 = x*x + y*y;
        // Compute the gaussian (minimum for numerical stability)
        var gauss = Math.max(Math.exp(-dist2/sigma2), 0.0000001);

        sumGauss += gauss;
        sum0[0] += gauss * pt0[0];
        sum0[1] += gauss * pt0[1];
        sum1[0] += gauss * pt1[0];
        sum1[1] += gauss * pt1[1];
    }
    sum0[0] = sum0[0] / sumGauss;
    sum0[1] = sum0[1] / sumGauss;
    sum1[0] = sum1[0] / sumGauss;
    sum1[1] = sum1[1] / sumGauss;

    // Now compute orientation.
    this.DeltaRoll = 0;

    // For now lets ignore the roll in the correlation
    // and compute roll from multiple points.

    // Compute rotation
    var roll = 0;
    var sumGauss = 0.0;
    var sumTheta = 0.0;
    for ( var i = 0; i < this.Correlations.length; ++i) {
        var correlation = this.Correlations[i];
        pt0 = correlation.GetPoint(idx0);
        pt1 = correlation.GetPoint(idx1);
        // Distance from the focal point (for weight).
        x = pt0[0] - fpIn[0];
        y = pt0[1] - fpIn[1];
        var dist = x*x + y*y;
        var gauss = Math.max(Math.exp(-dist/sigma2), 0.0000001);
        // Compute the two angles using the average centers.
        // angle 0:
        x = pt0[0] - sum0[0];
        y = pt0[1] - sum0[1];
        var angle0 = Math.atan2(x,y);
        // Compute distance for small angle consideration.
        var dist0 = x*x + y*y;
        // Angle 1:
        x = pt1[0] - sum1[0];
        y = pt1[1] - sum1[1];
        var angle1 = Math.atan2(x,y);
        // Compute distance for small angle consideration.
        var dist1 = x*x + y*y;

        // Now combine weights.
        gauss = gauss * Math.sqrt(Math.min(dist0, dist1));

        // Averaging angles is tricky because of cycles.
        // Assume all angles are small.
        var dAngle = (angle1 - angle0);
        var twoPi = Math.PI * 2;
        while (dAngle > Math.PI) { dAngle -= twoPi;}
        while (dAngle < -Math.PI) { dAngle += twoPi;}

        sumTheta += dAngle * gauss;
        sumGauss += gauss;
    }
    if (sumGauss > 0) {
        roll = (sumTheta / sumGauss);
    }
    // Silly converting this to degrees, but set camera takes degrees.
    // This is the second return value.
    this.DeltaRoll = (sumTheta / sumGauss);

    // Since focal points are not at center of rotation (sum0 and sum1).
    // We need to translate center to origin, rotate, then translate back.
    fpOut[0] -= sum0[0];
    fpOut[1] -= sum0[1];
    var c = Math.cos(roll);
    var s = Math.sin(roll);
    // Left handed pixel coordinate system messes the rotation.
    var x = c*fpOut[0] + s*fpOut[1];
    var y = c*fpOut[1] - s*fpOut[0];

    fpOut[0] = x + sum1[0];
    fpOut[1] = y + sum1[1];

    return fpOut;
}


// Nearest neighbor.
PairTransformation.prototype.ForwardTransform = function(pt0, sigma) {
    this.DeltaRoll = 0;
    if (this.Correlations.length == 0) {
        return pt0;
    }

    return this.WeightedTransform(0, 1, pt0, sigma);
}

// Nearest neighbor.
PairTransformation.prototype.ReverseTransform = function(pt1, sigma) {
    this.DeltaRoll = 0;
    if (this.Correlations.length == 0) {
        return pt1;
    }

    return this.WeightedTransform(1, 0, pt1, sigma);
}


PairTransformation.prototype.ForwardTransformCamera = function(camIn, camOut) {
    camOut.FocalPoint = this.ForwardTransform(camIn.FocalPoint, camIn.Height / 2);
    camOut.Roll = camIn.Roll + this.DeltaRoll;
    camOut.Height = camIn.Height;
    // This should be computed from the viewport
    //camOut.Width = camIn.Width;
    camOut.Width = camOut.Height * camOut.ViewportWidth / camOut.ViewportHeight;
}

PairTransformation.prototype.ReverseTransformCamera = function(camIn, camOut) {
    camOut.FocalPoint = this.ReverseTransform(camIn.FocalPoint, camIn.Height / 2);
    camOut.Roll = camIn.Roll + this.DeltaRoll;
    camOut.Height = camIn.Height;
    // This should be computed from the viewport
    //camOut.Width = camIn.Width;
    camOut.Width = camOut.Height * camOut.ViewportWidth / camOut.ViewportHeight;
}

window.requestAnimationFrame = 
    window.requestAnimationFrame ||
    window.mozRequestAnimationFrame ||
    window.webkitRequestAnimationFrame ||             
    window.msRequestAnimationFrame;

// Firefox does not set which for mouse move events.
function saFirefoxWhich(event) {
    event.which = event.buttons;
    if (event.which == 2) {
        event.which = 3;
    } else if (event.which == 3) {
        event.which = 2;
    }
}

function saDebug(msg) {
    console.log(msg);
}

// for debugging
function MOVE_TO(x,y) {
    SA.DualDisplay.Viewers[0].MainView.Camera.SetFocalPoint([x,y]);
    SA.DualDisplay.Viewers[0].MainView.Camera.ComputeMatrix();
    if (SA.DualDisplay) {
        SA.DualDisplay.Draw();
    }
}

function ZERO_PAD(i, n) {
    var s = "0000000000" + i.toFixed();
    return s.slice(-n);
}

// This file contains some global variables and misc procedures to
// initials shaders and some buffers we need and to render.
// Main function called by the default view.html template
// SA global will be set to this object.
function SlideAtlas() {
    // For managing progress with multiple ajax calls.
    this.ProgressCount = 0;

    this.TileLoader = "http";
    // How can we distribute the initialization of these?
    // TODO: Many of these are not used anymore. Clean them up.
    this.TimeStamp = 0;
    this.NumberOfTiles = 0;
    this.NumberOfTextures = 0;
    this.MaximumNumberOfTiles = 50000;
    this.MaximumNumberOfTextures = 5000;
    this.PruneTimeTiles = 0;
    this.PruneTimeTextures = 0;

    // Keep a queue of tiles to load so we can sort them as
    // new requests come in.
    this.LoadQueue = [];
    this.LoadingCount = 0;
    this.LoadingMaximum = 10;
    this.LoadTimeoutId = 0;

    this.LoadProgressMax = 0;
    this.ProgressBar = null;

    // Only used for saving images right now.
    this.FinishedLoadingCallbacks = [];

    this.Caches = [];

    this.StartInteractionListeners = [];
}

SlideAtlas.prototype.PushProgress = function() {
    $('body').css({'cursor':'progress'});
    this.ProgressCount += 1;
}

SlideAtlas.prototype.PopProgress = function() {
    this.ProgressCount -= 1;
    if (this.ProgressCount <= 0) {
        $('body').css({'cursor':'default'});
    }
}

// Main function called by the default view.html template
// SA global will be set to this object.
SlideAtlas.prototype.Run = function() {
    self = this;
    if (this.SessionId) {
        $.ajax({
            type: "get",
            url: this.SessionUrl+"?json=true&sessid="+this.SessionId,
            success: function(data,status) {
                self.Session = data;
                self.HideAnnotations = data.hide;
                // TODO: fix this serialization.
                self.Run2();
            },
            error: function() {
                saDebug("AJAX - error() : session" );
                self.Run2();
            },
        });
    } else {
        this.Run2();
    }
}


// Now we have the session (if the id was passed in).
SlideAtlas.prototype.Run2 = function() {
    self = this;
    // Get the root note.
    if (this.ViewId == "" || this.ViewId == "None") {
        delete this.ViewId;
    }
    if (this.SessionId == "" ||this.SessionId == "None") {
        delete this.SessionId;
    }

    // We need to get the view so we know how to initialize the app.
    var rootNote = new SA.Note();

    // Hack to create a new presenation.
    if ( this.ViewId == "presentation") {
        var title = window.prompt("Please enter the presentation title.",
                                  "SlideShow");
        if (title == null) {
            // Go back in browser?
            return;
        }
        rootNote.Title = title;
        rootNote.HiddenTitle = title;
        rootNote.Text = "";
        rootNote.Type = "HTML";

        Main(rootNote);
    } else {
        if (this.ViewId == "") {
            saDebug("Missing view id");
            return;
        }
        // Sort of a hack that we rely on main getting called after this
        // method returns and other variables of SA are initialize.
        rootNote.LoadViewId(this.ViewId,
                            function () {Main(rootNote);});
    }
}

// Stack editing stuff (should not be in the global class).
// It used to be in the event manager.  Skipping the focus stuff.
// TODO:
// Modifier could be handled better with keypress events.
SlideAtlas.prototype.HandleKeyDownStack = function(event) {
    if ( this.ContentEditableHasFocus) {return true;}
    
    if (event.keyCode == 16) {
        // Shift key modifier.
        this.ShiftKeyPressed = true;
        // Do not forward modifier keys events to objects that consume keypresses.
        return true;
    }
    if (event.keyCode == 17) {
        // Control key modifier.
        this.ControlKeyPressed = true;
        return true;
    }

    // Handle undo and redo (cntrl-z, cntrl-y)
    if (this.ControlKeyPressed && event.keyCode == 90) {
        // Function in recordWidget.
        UndoState();
        return false;
    } else if (this.ControlKeyPressed && event.keyCode == 89) {
        // Function in recordWidget.
        RedoState();
        return false;
    }

    if (SA.Presentation) {
        SA.Presentation.HandleKeyDown(event);
        return true;
    }

    return true;
}

SlideAtlas.prototype.HandleKeyUpStack = function(event) {
    if ( this.ContentEditableHasFocus) {return true;} 

    // For debugging deformable alignment in stacks.
    if (event.keyCode == 90) { // z = 90
        if (event.shiftKey) {
            DeformableAlignViewers();
            return true;
        }
    }

    // It is sort of a hack to check for the cursor mode here, but it
    // affects both viewers.
    if (event.keyCode == 88) { // x = 88
        // I am using the 'c' key to display to focal point cursor
        //this.StackCursorFlag = false;
        // what a pain.  Holding x down sometimes blocks mouse events.
        // Have to change to toggle.
        this.StackCursorFlag =  ! this.StackCursorFlag;
        if (event.shiftKey && this.StackCursorFlag) {
            testAlignTranslation();
            var self = this;
            window.setTimeout(function() {self.StackCursorFlag = false;}, 1000);
        }

        return false;
    }

    if (event.keyCode == 16) {
        // Shift key modifier.
        this.ShiftKeyPressed = false;
        //this.StackCursorFlag = false;
    } else if (event.keyCode == 17) {
        // Control key modifier.
        this.ControlKeyPressed = false;
    }

    // Is this really necessary?
    // TODO: Try to remove this and test presentation stuff.
    if (this.Presentation) {
        this.Presentation.HandleKeyUp(event);
        return true;
    }

    return true;
}

// TODO: THis should be in viewer.
SlideAtlas.prototype.OnStartInteraction = function(callback) {
  this.StartInteractionListeners.push(callback);
}

SlideAtlas.prototype.TriggerStartInteraction = function() {
    if ( ! this.StartInteractionListeners) { return; }
    for (var i = 0; i < this.StartInteractionListeners.length; ++i) {
        callback = this.StartInteractionListeners[i];
        callback();
    }
}

// TODO: These should be moved to viewer-utils so they can be used
// separately from SlideAtlas.
// Helper function: Looks for a key phase in the text.
// first == true: Look only at the start. Returns true if found. 
// first == false: return index of tag or -1;
SlideAtlas.prototype.TagCompare = function (tag,text,first) {
    if (first) {
        return (tag.toUpperCase() ==
                text.substring(0,tag.length).toUpperCase());
    }
    return text.toUpperCase().search(tag.toUpperCase());
}

// Process HTML to add standard tags.
// Returns the altered html.
// I am writting this to be safe to call multiple times.
// Depth first traversal of tree.
SlideAtlas.prototype.AddHtmlTags = function(item) {
    var container = undefined;
    var tags = [{string:"History:",               class:"sa-history"},
                {string:"Diagnosis:",             class:"sa-diagnosis"},
                {string:"Differential Diagnosis:",class:"sa-differential-diagnosis"},
                {string:"Teaching Points:",       class:"sa-teaching-points"},
                {string:"Compare with:",          class:"sa-compare"},
                {string:"Notes:",                 class:"sa-notes"}];

    // Since text concatinates children,
    // containers only have to consume siblings.
    var children = item.children();
    for (var i = 0; i < children.length; ++i) {
        var child = $(children[i]);

        // Look for an existing class from our set. 
        // If we find one, terminate processing for the item and ites children.
        // Terminate the container collecting items.
        var foundTag = undefined;
        for (var j = 0; j < tags.length; ++j) {
            if (child.hasClass(tags[j].class)) {
                foundTag = tags[j];
            }
        }
        if (foundTag) {
            container = undefined;
            continue;
        }

        // special  (one line tag)
        if (child.hasClass('sa-ssc-title')) {
            container = undefined;
            continue;
        }

        // Look for a tag string inthe text
        var text = child.text();
        // Special case: treat the title as a single line.
        if (this.TagCompare('SSC', text, true) && !child.hasClass('sa-ssc-title')) {
            child.addClass('sa-ssc-title');
        }

        // Make sure tags are not grouped.
        // This is a bit of a hack.  THere are too many ways html can be formatted.
        if (child.children().length > 1) {
            for (var j = 0; j < tags.length; ++j) {
                tag = tags[j];
                if (this.TagCompare(tag.string, text, false) > 0) {
                    var grandChildren = child.children();
                    grandChildren.remove();
                    grandChildren.insertAfter(child);
                    children = item.children();
                    text = child.text();
                    break;
                }
            }
        }

        // These tags consume children followint the tag.
        var foundTag = false;
        for (var j = 0; j < tags.length; ++j) {
            tag = tags[j];
            if (this.TagCompare(tag.string, text, true)) {
                foundTag = tag;
                break;
            }
        }

        if (foundTag) {
            // If the outer is a div,  reuse it for the container.
            // There was a bug with diagnosis in the history container.
            // This will ungroup multiple tags. However recursion may be
            // needed.
            if (child[0].tagName == 'DIV') {
                var grandChildren = child.children();
                child.empty();
                grandChildren.insertAfter(child);
                children = item.children();
                container = child;
                ++i;
                child = $(children[i]);
            } else {
                // Start a new container.
                container = $('<div>')
                    .insertBefore(child);
                children = item.children();
                // Manipulating a list we are traversing is a pain.
                ++i;
            }
            container.addClass(foundTag.class);
        }

        // If we have a container, it consumes all items after it.
        if (container) {
            // Remove the item and add it to the container.
            child.remove();
            child.appendTo(container);
            children = item.children();
            // Manipulating a list we are traversing is a pain.
            --i;
        }
    }
}


// Useful utility to get selected text / the position of the cursor.
// Get the selection in div.  Returns a range.
// If not, the range is collapsed at the 
// end of the text and a new line is added.
// div is a jquery parent.
SlideAtlas.prototype.GetSelectionRange = function(div) {
    var sel = window.getSelection();
    var range;
    var parent = null;

    // Two conditions when we have to create a selection:
    // nothing selected, and something selected in wrong parent.
    // use parent as a flag.
    if (sel.rangeCount > 0) {
        // Something is selected
        range = sel.getRangeAt(0);
        range.noCursor = false;
        // Make sure the selection / cursor is in this editor.
        parent = range.commonAncestorContainer;
        // I could use jquery .parents(), but I bet this is more efficient.
        while (parent && parent != div[0]) {
            //if ( ! parent) {
                // I believe this happens when outside text is selected.
                // We should we treat this case like nothing is selected.
                //console.log("Wrong parent");
                //return;
            //}
            if (parent) {
                parent = parent.parentNode;
            }
        }
    }
    if ( ! parent) {
        return null;
        //return this.MakeSelectionRange(div);
    }

    return range;
}

// When we are inserting at the end and nothing is selected, we need to
// add a div with a break at the end and select the break. This keeps the
// cursor after the inserted item. This returns the range.
SlideAtlas.prototype.MakeSelectionRange = function(div) {
    // When nothing is select, I am trying to make the cursor stay
    // after the question inserted with the range we return.
    // TODO: change this so that the div is added after the dialog
    // apply. Cancel should leave div unchanged.(AddQuestion)
    var sel = window.getSelection();

    div[0].focus();
    var br = $('<br>').appendTo(div);
    range = document.createRange();
    range.selectNode(br[0]);
    sel.removeAllRanges();
    sel.addRange(range);
    return range;
}




var SA = SA || new SlideAtlas();
var ROOT_DIV;
var imageProgram;
var textProgram;
var polyProgram;
var mvMatrix = mat4.create();
var pMatrix = mat4.create();
var squareOutlinePositionBuffer;
var squarePositionBuffer;
var tileVertexPositionBuffer;
var tileVertexTextureCoordBuffer;
var tileCellBuffer;

var MOBILE_DEVICE = false;
// Hack to get rid of white lines.
var I_PAD_FLAG = false;


function detectMobile() {
    MOBILE_DEVICE = false;

    if ( navigator.userAgent.match(/Android/i)) {
        MOBILE_DEVICE = "Andriod";
    }
    if ( navigator.userAgent.match(/webOS/i)) {
        MOBILE_DEVICE = "webOS";
    }
    if ( navigator.userAgent.match(/iPhone/i)) {
        MOBILE_DEVICE = "iPhone";
    }
    if ( navigator.userAgent.match(/iPad/i)) {
        MOBILE_DEVICE = "iPad";
        I_PAD_FLAG = true;
    }
    if ( navigator.userAgent.match(/iPod/i)) {
        MOBILE_DEVICE = "iPod";
    }
    if ( navigator.userAgent.match(/BlackBerry/i)) {
        MOBILE_DEVICE = "BlackBerry";
    }
    if ( navigator.userAgent.match(/Windows Phone/i)) {
        MOBILE_DEVICE = "Windows Phone";
    }
    if (MOBILE_DEVICE) {
        SA.MaximumNumberOfTiles = 5000;
    }

    return MOBILE_DEVICE;
}


// This global is used in every class that renders something.
// I can not test multiple canvases until I modularize the canvas
// and get rid of these globals.
// WebGL context
var GL;

function GetUser() {
    if (typeof(SA.User) != "undefined") {
        return SA.User;
    }
    saDebug("Could not find user");
    return "";
}


function GetViewId () {
    if (typeof(SA.ViewId) != "undefined") {
        return SA.ViewId;
    }
    if ( ! SA.notesWidget && ! SA.notesWidget.RootNote) {
        return SA.notesWidget.RootNote._id;
    }
    saDebug("Could not find view id");
    return "";
}

// WebGL Initializationf

function doesBrowserSupportWebGL(canvas) {
    try {
        //GL = canvas.getContext("webgl") || canvas.getContext("experimental-webgl");
        GL = canvas.getContext("webgl");
    } catch (e) {
    }
    if (!GL) {
        //saDebug("Could not initialise WebGL, sorry :-(");
        return false;
    }
   return true;
}


function initGL() {

    // Add a new canvas.
    CANVAS = $('<canvas>').appendTo('body').addClass("sa-view-canvas"); // class='fillin nodoubleclick'
    //this.canvas.onselectstart = function() {return false;};
    //this.canvas.onmousedown = function() {return false;};
    GL = CANVAS[0].getContext("webgl") || CANVAS[0].getContext("experimental-webgl");

    // Defined in HTML
    initShaderPrograms();
    initOutlineBuffers();
    initImageTileBuffers();
    GL.clearColor(1.0, 1.0, 1.0, 1.0);
    GL.enable(GL.DEPTH_TEST);
}



function getShader(gl, id) {
    var shaderScript = document.getElementById(id);
    if (!shaderScript) {
        return null;
    }

    var str = "";
    var k = shaderScript.firstChild;
    while (k) {
        if (k.nodeType == 3) {
            str += k.textContent;
        }
        k = k.nextSibling;
    }

    var shader;
    if (shaderScript.type == "x-shader/x-fragment") {
        shader = gl.createShader(gl.FRAGMENT_SHADER);
    } else if (shaderScript.type == "x-shader/x-vertex") {
        shader = gl.createShader(gl.VERTEX_SHADER);
    } else {
        return null;
    }

    gl.shaderSource(shader, str);
    gl.compileShader(shader);

    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        saDebug(gl.getShaderInfoLog(shader));
        return null;
    }

    return shader;
}



function initShaderPrograms() {
    polyProgram = createProgram("shader-poly-fs", "shader-poly-vs");
    polyProgram.colorUniform = GL.getUniformLocation(polyProgram, "uColor");

    imageProgram = createProgram("shader-tile-fs", "shader-tile-vs");
    // Texture coordinate attribute and texture image uniform
    imageProgram.textureCoordAttribute
        = GL.getAttribLocation(imageProgram,"aTextureCoord");
    GL.enableVertexAttribArray(imageProgram.textureCoordAttribute);
    imageProgram.samplerUniform = GL.getUniformLocation(imageProgram, "uSampler");



    textProgram = createProgram("shader-text-fs", "shader-text-vs");
    textProgram.textureCoordAttribute
        = GL.getAttribLocation(textProgram, "aTextureCoord");
    GL.enableVertexAttribArray(textProgram.textureCoordAttribute);
    textProgram.samplerUniform
        = GL.getUniformLocation(textProgram, "uSampler");
    textProgram.colorUniform = GL.getUniformLocation(textProgram, "uColor");
}


function createProgram(fragmentShaderID, vertexShaderID) {
    var fragmentShader = getShader(GL, fragmentShaderID);
    var vertexShader = getShader(GL, vertexShaderID);

    var program = GL.createProgram();
    GL.attachShader(program, vertexShader);
    GL.attachShader(program, fragmentShader);
    GL.linkProgram(program);

    if (!GL.getProgramParameter(program, GL.LINK_STATUS)) {
        saDebug("Could not initialise shaders");
    }

    program.vertexPositionAttribute = GL.getAttribLocation(program, "aVertexPosition");
    GL.enableVertexAttribArray(program.vertexPositionAttribute);

    // Camera matrix
    program.pMatrixUniform = GL.getUniformLocation(program, "uPMatrix");
    // Model matrix
    program.mvMatrixUniform = GL.getUniformLocation(program, "uMVMatrix");

    return program;
}

function initOutlineBuffers() {
    // Outline Square
    vertices = [
        0.0,  0.0,  0.0,
        0.0,  1.0,  0.0,
        1.0, 1.0,  0.0,
        1.0, 0.0,  0.0,
        0.0, 0.0,  0.0];
    squareOutlinePositionBuffer = GL.createBuffer();
    GL.bindBuffer(GL.ARRAY_BUFFER, squareOutlinePositionBuffer);
    GL.bufferData(GL.ARRAY_BUFFER, new Float32Array(vertices), GL.STATIC_DRAW);
    squareOutlinePositionBuffer.itemSize = 3;
    squareOutlinePositionBuffer.numItems = 5;

    // Filled square
    squarePositionBuffer = GL.createBuffer();
    GL.bindBuffer(GL.ARRAY_BUFFER, squarePositionBuffer);
    vertices = [
        1.0,  1.0,  0.0,
        0.0,  1.0,  0.0,
        1.0,  0.0,  0.0,
        0.0,  0.0,  0.0
    ];
    GL.bufferData(GL.ARRAY_BUFFER, new Float32Array(vertices), GL.STATIC_DRAW);
    squarePositionBuffer.itemSize = 3;
    squarePositionBuffer.numItems = 4;
}




//==============================================================================



function initImageTileBuffers() {
    var vertexPositionData = [];
    var textureCoordData = [];

    // Make 4 points
    textureCoordData.push(0.0);
    textureCoordData.push(0.0);
    vertexPositionData.push(0.0);
    vertexPositionData.push(0.0);
    vertexPositionData.push(0.0);

    textureCoordData.push(1.0);
    textureCoordData.push(0.0);
    vertexPositionData.push(1.0);
    vertexPositionData.push(0.0);
    vertexPositionData.push(0.0);

    textureCoordData.push(0.0);
    textureCoordData.push(1.0);
    vertexPositionData.push(0.0);
    vertexPositionData.push(1.0);
    vertexPositionData.push(0.0);

    textureCoordData.push(1.0);
    textureCoordData.push(1.0);
    vertexPositionData.push(1.0);
    vertexPositionData.push(1.0);
    vertexPositionData.push(0.0);

    // Now create the cell.
    var cellData = [];
    cellData.push(0);
    cellData.push(1);
    cellData.push(2);

    cellData.push(2);
    cellData.push(1);
    cellData.push(3);

    tileVertexTextureCoordBuffer = GL.createBuffer();
    GL.bindBuffer(GL.ARRAY_BUFFER, tileVertexTextureCoordBuffer);
    GL.bufferData(GL.ARRAY_BUFFER, new Float32Array(textureCoordData), GL.STATIC_DRAW);
    tileVertexTextureCoordBuffer.itemSize = 2;
    tileVertexTextureCoordBuffer.numItems = textureCoordData.length / 2;

    tileVertexPositionBuffer = GL.createBuffer();
    GL.bindBuffer(GL.ARRAY_BUFFER, tileVertexPositionBuffer);
    GL.bufferData(GL.ARRAY_BUFFER, new Float32Array(vertexPositionData), GL.STATIC_DRAW);
    tileVertexPositionBuffer.itemSize = 3;
    tileVertexPositionBuffer.numItems = vertexPositionData.length / 3;

    tileCellBuffer = GL.createBuffer();
    GL.bindBuffer(GL.ELEMENT_ARRAY_BUFFER, tileCellBuffer);
    GL.bufferData(GL.ELEMENT_ARRAY_BUFFER, new Uint16Array(cellData), GL.STATIC_DRAW);
    tileCellBuffer.itemSize = 1;
    tileCellBuffer.numItems = cellData.length;
}



// TODO: Get rid of this as legacy.
// I put an eveutallyRender method in the viewer, but have not completely
// converted code yet.
// Stuff for drawing
//var RENDER_PENDING = false;
//function eventuallyRender() {
//    if (! RENDER_PENDING) {
//      RENDER_PENDING = true;
//      requestAnimFrame(tick);
//    }
//}

//function tick() {
//    //console.timeEnd("system");
//    RENDER_PENDING = false;
//    draw();
//    //console.time("system");
//}




//==============================================================================
// Alternative to webgl, HTML5 2d canvas


function initGC() {

    detectMobile();
}


var GC_STACK = [];
var GCT = [1,0,0,1,0,0];
function GC_save() {
  var tmp = [GCT[0], GCT[1], GCT[2], GCT[3], GCT[4], GCT[5]];
  GC_STACK.push(tmp);
}
function GC_restore() {
  var tmp = GC_STACK.pop();
  GCT = tmp;
  GC.setTransform(tmp[0],tmp[1],tmp[2],tmp[3],tmp[4],tmp[5]);
}
function GC_setTransform(m00,m10,m01,m11,m02,m12) {
  GCT = [m00,m10,m01,m11,m02,m12];
  GC.setTransform(m00,m10,m01,m11,m02,m12);
}
function GC_transform(m00,m10,m01,m11,m02,m12) {
  var n00 = m00*GCT[0] + m10*GCT[2];
  var n10 = m00*GCT[1] + m10*GCT[3];
  var n01 = m01*GCT[0] + m11*GCT[2];
  var n11 = m01*GCT[1] + m11*GCT[3];
  var n02 = m02*GCT[0] + m12*GCT[2] + GCT[4];
  var n12 = m02*GCT[1] + m12*GCT[3] + GCT[5];

  GCT = [n00,n10,n01,n11,n02,n12];
  GC.setTransform(n00,n10,n01,n11,n02,n12);
}



//----------------------------------------------------------
// Log to trackdown iPad bug.  Console does not log until
// debugger is running.  Bug does not occur when debugger
// is running.

LOGGING = false;
DEBUG_LOG = [];

function StartLogging (message) {
  if (LOGGING) return;
  LOGGING = true;
  //alert("Error: Check log");
}

function LogMessage (message) {
  if (LOGGING) {
    DEBUG_LOG.push(message);
  }
}

//----------------------------------------------------------
// In an attempt to simplify the view.html template file, I am putting
// as much of the javascript from that file into this file as I can.
// As I abstract viewer features, these variables and functions
// should migrate into objects and other files.

var CANVAS;

var CONFERENCE_WIDGET;
var FAVORITES_WIDGET;
var MOBILE_ANNOTATION_WIDGET;

//==============================================================================


// hack to avoid an undefined error (until we unify annotation stuff).
function ShowAnnotationEditMenu(x, y) {
}


// TODO:  Get rid of this function.
function handleResize() {
    $('window').trigger('resize');
}

// The event manager detects single right click and double right click.
// This gets galled on the single.
function ShowPropertiesMenu(x, y) {} // This used to show the view edit.
// I am getting rid of the right click feature now.

// TODO: Move these out of the global SLideAtlas object.
function handleKeyDown(event) {
    return SA.HandleKeyDownStack(event);
}
function handleKeyUp(event) {
    return SA.HandleKeyUpStack(event);
}

function cancelContextMenu(e) {
    //alert("Try to cancel context menu");
    if (e && e.stopPropagation) {
        e.stopPropagation();
    }
    return false;
}



// Call back from NotesWidget.
function NotesModified() {
    if (SA.Edit && SA.SaveButton) {
        SA.SaveButton.attr('src',SA.ImagePathUrl+"save.png");
    }
}

function NotesNotModified() {
    if (SA.Edit && SA.SaveButton) {
        SA.SaveButton.attr('src',SA.ImagePathUrl+"save22.png");
    }
}

// This function gets called when the save button is pressed.
function SaveCallback() {
    // TODO: This is no longer called by a button, so change its name.
    SA.notesWidget.SaveCallback(
        function () {
            // finished
            SA.SaveButton.attr('src',SA.ImagePathUrl+"save22.png");
        });
}


// This serializes loading a bit, but we need to know what type the note is
// so we can coustomize the webApp.  The server could pass the type to us.
// It might speed up loading.
// Note is the same as a view.
function Main(rootNote) {
    SA.RootNote = rootNote;

    if (rootNote.Type == "Presentation" ||
        rootNote.Type == "HTML") {
        SA.Presentation = new SA.Presentation(rootNote, SA.Edit);
        return;
    }

    detectMobile();
    $(body).addClass("sa-view-body");
    // Just to see if webgl is supported:
    //var testCanvas = document.getElementById("gltest");

    // I think the webgl viewer crashes.
    // Maybe it is the texture leak I have seen in connectome.
    // Just use the canvas for now.
    // I have been getting crashes I attribute to not freeing texture
    // memory properly.
    // NOTE: I am getting similar crashe with the canvas too.
    // Stack is running out of some resource.
    if ( ! MOBILE_DEVICE && false) { // && doesBrowserSupportWebGL(testCanvas)) {
        initGL(); // Sets CANVAS and GL global variables
    } else {
        initGC();
    }

    // TODO: Get rid of this global variable.
    if (MOBILE_DEVICE && MOBILE_ANNOTATION_WIDGET) {
        MOBILE_ANNOTATION_WIDGET = new MobileAnnotationWidget();
    }


    SA.MainDiv = $('<div>')
        .appendTo('body')
        .css({
            'position':'fixed',
            'left':'0px',
            'width': '100%'})
        .saFullHeight();
        //.addClass("sa-view-canvas-panel")

    // Left panel for notes.
    SA.ResizePanel = new ResizePanel(SA.MainDiv);
    SA.DualDisplay = new SA.DualViewWidget(SA.ResizePanel.MainDiv);
    SA.notesWidget = new SA.NotesWidget(SA.ResizePanel.PanelDiv,
                                        SA.DualDisplay);

    if (rootNote.Type == "Stack") {
        SA.DualDisplay.SetNumberOfViewers(2);
    }

    SA.notesWidget.SetModifiedCallback(NotesModified);
    SA.notesWidget.SetModifiedClearCallback(NotesNotModified);
    // Navigation widget keeps track of which note is current.
    // Notes widget needs to access and change this.
    SA.notesWidget.SetNavigationWidget(SA.DualDisplay.NavigationWidget);
    if (SA.DualDisplay.NavigationWidget) {
      SA.DualDisplay.NavigationWidget.SetInteractionEnabled(true);
    }

    new SA.RecorderWidget(SA.DualDisplay);

    SA.DualDisplay.SetNote(rootNote);

    // Do not let guests create favorites.
    // TODO: Rework how favorites behave on mobile devices.
    if (SA.User != "" && ! MOBILE_DEVICE) {
        if ( SA.Edit) {
            // Put a save button here when editing.
            SA.SaveButton = $('<img>')
                .appendTo(SA.ResizePanel.MainDiv)
                .css({'position':'absolute',
                      'bottom':'4px',
                      'left':'10px',
                      'height': '28px',
                      'z-index': '5'})
                .prop('title', "save to databse")
                .addClass('editButton')
                .attr('src',SA.ImagePathUrl+"save22.png")
                .click(SaveCallback);
            for (var i = 0; i < SA.DualDisplay.Viewers.length; ++i) {
                SA.DualDisplay.Viewers[i].OnInteraction(
                    function () {SA.notesWidget.RecordView();});
            }
        } else {
            // Favorites when not editing.
            FAVORITES_WIDGET = new FavoritesWidget(SA.MainDiv, SA.DualDisplay);
            //FAVORITES_WIDGET.HandleResize(CANVAS.innerWidth());
        }
    }

    if (MOBILE_DEVICE && SA.DualDisplay && 
        SA.DualDisplay.NavigationWidget) {
        SA.DualDisplay.NavigationWidget.SetVisibility(false);
    }
    if (MOBILE_DEVICE && MOBILE_ANNOTATION_WIDGET) {
        MOBILE_ANNOTATION_WIDGET.SetVisibility(false);
    }

    //CONFERENCE_WIDGET = new ConferenceWidget();

    // The event manager still handles stack alignment.
    // This should be moved to a stack helper class.
    // Undo and redo too.
    document.onkeydown = handleKeyDown;
    document.onkeyup = handleKeyUp;

    // Keep the browser from showing the left click menu.
    document.oncontextmenu = cancelContextMenu;

    if ( ! MOBILE_DEVICE) {
        // Hack for all viewer edit menus to share browser.
        VIEW_BROWSER = new ViewBrowser($('body'));

        // TODO: See if we can get rid of this, or combine it with
        // the view browser.
        InitSlideSelector(SA.MainDiv); // What is this?
        var viewMenu1 = new ViewEditMenu(SA.DualDisplay.Viewers[0],
                                         SA.DualDisplay.Viewers[1]);
        var viewMenu2 = new ViewEditMenu(SA.DualDisplay.Viewers[1],
                                         SA.DualDisplay.Viewers[0]);
        var viewer = SA.DualDisplay.Viewers[0];
        var annotationWidget1 =
            new AnnotationWidget(viewer.GetAnnotationLayer(), viewer);
        annotationWidget1.SetVisibility(2);
        var viewer = SA.DualDisplay.Viewers[1];
        var annotationWidget2 =
            new AnnotationWidget(viewer.GetAnnotationLayer(), viewer);
        annotationWidget2.SetVisibility(2);
        SA.DualDisplay.UpdateGui();
    }

    $(window).bind('orientationchange', function(event) {
        handleResize();
    });

    $(window).resize(function() {
        handleResize();
    }).trigger('resize');

    if (SA.DualDisplay) {
        SA.DualDisplay.Draw();
    }
}


// I had to prune all the annotations (lassos) that were not visible.
function keepVisible(){
  var n = SA.DualDisplay.GetNote();
  var r = n.ViewerRecords[n.StartIndex];
  var w = VIEWER1.WidgetList;
  var c = VIEWER1.GetCamera();
  var b =c.GetBounds();
  for(var i= 0; i<r.Annotations.length; ++i) {
    if (r.Annotations[i].type != 'lasso') {
      r.Annotations.splice(i,1);
      --i;
    } else {
      var pt = r.Annotations[i].points[0];
      if ( ! pt || pt[0] < b[0] || pt[0] > b[1] || pt[1] < b[2] || pt[1] >
  b[3]) {
        r.Annotations.splice(i,1);
        --i;
      }
    }
  }
  for(var i= 0; i<w.length; ++i) {
    if ( ! w[i] instanceof LassoWidget || ! w[i].Loop) {
      w.splice(i,1);
      --i;
    } else {
      var pt = w[i].Loop.Points[0];
      if ( ! pt || pt[0] < b[0] || pt[0] > b[1] || pt[1] < b[2] || pt[1] >
  b[3]) {
        w.splice(i,1);
        --i;
      }
    }
  }
}
