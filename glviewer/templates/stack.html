<!doctype html>

<title>Stack Viewer</title>

<!-- TODO: Stop using webgl rendering -->


<script src="http://code.jquery.com/jquery-1.8.3.js"></script>
<script src="http://code.jquery.com/ui/1.10.0/jquery-ui.js"></script>



<meta http-equiv="content-type" content="text/html; charset=ISO-8859-1">

<!-- TODO: use common jquery for entire project avoiding duplication-->

<link type="text/css" href="{{ url_for('glviewer.static', filename='jquery/jquery-ui-1.8.22.custom.css') }}" rel="stylesheet" />
<script type="text/javascript" src="{{ url_for('glviewer.static', filename='jquery/jquery-1.7.2.min.js') }}"></script>
<script type="text/javascript" src="{{ url_for('glviewer.static', filename='jquery/jquery-ui-1.8.22.custom.min.js') }}"></script>

<!-- used some objects, matrix as an array  -->
<script type="text/javascript" src="{{ url_for('glviewer.static', filename='glMatrix-0.9.5.min.js') }}"></script>

<!-- Perspective camera etc. May be ready to remove -->
<script type="text/javascript" src="{{ url_for('glviewer.static', filename='webgl-utils.js') }}"></script>

<script type="text/javascript" src="{{ url_for('glviewer.static', filename='viewer-utils.js') }}"></script>
<script type="text/javascript" src="{{ url_for('glviewer.static', filename='init.js') }}"></script>
<script type="text/javascript" src="{{ url_for('glviewer.static', filename='loader.js') }}"></script>
<script type="text/javascript" src="{{ url_for('glviewer.static', filename='camera.js') }}"></script>
<script type="text/javascript" src="{{ url_for('glviewer.static', filename='shape.js') }}"></script>
<script type="text/javascript" src="{{ url_for('glviewer.static', filename='crossHairs.js') }}"></script>

<!-- For websockets -->
<script type="text/javascript" src="{{ url_for('static', filename='js/bson.js') }}"></script>
<script type="text/javascript" src="{{ url_for('glviewer.static', filename='websocket.js') }}"></script>


<!-- Actor for tile -->
<script type="text/javascript" src="{{ url_for('glviewer.static', filename='tile.js') }}"></script>

<!-- Source and cache for the viewer
Manages the list, and gives to camera, either lowres, or appropriate tiles
 -->
<script type="text/javascript" src="{{ url_for('glviewer.static', filename='cache.js') }}"></script>
<script type="text/javascript" src="{{ url_for('glviewer.static', filename='section.js') }}"></script>

<!-- Single view, view interacts with the cache -->
<script type="text/javascript" src="{{ url_for('glviewer.static', filename='view.js') }}"></script>

<!-- Has two views -->
<script type="text/javascript" src="{{ url_for('glviewer.static', filename='viewer.js') }}"></script>

<!-- For 3d pathology -->
<script type="text/javascript" src="{{ url_for('glviewer.static', filename='pairTransformation.js') }}"></script>

<!-- For 3d annotations -->
<script type="text/javascript" src="{{ url_for('glviewer.static', filename='annotationEditMenu.js') }}"></script>
<script type="text/javascript" src="{{ url_for('glviewer.static', filename='notesWidget.js') }}"></script>


<!-- Widgets

Different widgets haev show dialog method,
hardcoded to the divs

Widgets have serialize method which creates an object

-->

<script type="text/javascript" src="{{ url_for('glviewer.static', filename='circleWidget.js') }}"></script>
<script type="text/javascript" src="{{ url_for('glviewer.static', filename='textWidget.js') }}"></script>
<script type="text/javascript" src="{{ url_for('glviewer.static', filename='polylineWidget.js') }}"></script>
<script type="text/javascript" src="{{ url_for('glviewer.static', filename='pencilWidget.js') }}"></script>
<script type="text/javascript" src="{{ url_for('glviewer.static', filename='lassoWidget.js') }}"></script>
<script type="text/javascript" src="{{ url_for('glviewer.static', filename='arrowStampWidget.js') }}"></script>
<script type="text/javascript" src="{{ url_for('glviewer.static', filename='widgetPopup.js') }}"></script>
<script type="text/javascript" src="{{ url_for('glviewer.static', filename='annotationWidget.js') }}"></script>
<script type="text/javascript" src="{{ url_for('glviewer.static', filename='mobileAnnotationWidget.js') }}"></script>

<!-- Shapes starting with superclass

Viewer contains shape list
shape has visibility and

-->

<script type="text/javascript" src="{{ url_for('glviewer.static', filename='shape.js') }}"></script>

<script type="text/javascript" src="{{ url_for('glviewer.static', filename='arrow.js') }}"></script>
<script type="text/javascript" src="{{ url_for('glviewer.static', filename='circle.js') }}"></script>
<script type="text/javascript" src="{{ url_for('glviewer.static', filename='polyline.js') }}"></script>

<!-- Text uses texture map and not superclass shape, shares same API -->
<script type="text/javascript" src="{{ url_for('glviewer.static', filename='text.js') }}"></script>

<!-- 1 Global, decides which viewer gets the event, viewer decides which is active widget to forward to, or else handle itself, sometimes forwards to change camera -->
<script type="text/javascript" src="{{ url_for('glviewer.static', filename='eventManager.js') }}"></script>

<!-- Body tag with ID, dialog code -->
<body id="body">
</body>

<script type="text/javascript" src="{{ url_for('glviewer.static', filename='dialog.js') }}"></script>

<!-- Stuff for downloading the image -->
<script type="text/javascript" src="{{ url_for('glviewer.static', filename='Blob.js') }}"></script>
<script type="text/javascript" src="{{ url_for('glviewer.static', filename='canvas-toBlob.js') }}"></script>
<script type="text/javascript" src="{{ url_for('glviewer.static', filename='FileSaver.js') }}"></script>


<!-- GUI widgets -->
<script type="text/javascript" src="{{ url_for('glviewer.static', filename='recorderWidget.js') }}"></script>




<script id="shader-poly-fs" type="x-shader/x-fragment">
  precision mediump float;
  uniform vec3 uColor;
  void main(void) {
   gl_FragColor = vec4(uColor, 1.0);
   //gl_FragColor = vec4(0.5, 0.0, 0.0, 1.0);
  }
</script>
<script id="shader-poly-vs" type="x-shader/x-vertex">
  attribute vec3 aVertexPosition;
  uniform mat4 uMVMatrix;
  uniform mat4 uPMatrix;
  void main(void) {
    gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);
  }
</script>
<script id="shader-tile-fs" type="x-shader/x-fragment">
  #ifdef GL_ES
  precision highp float;
  #endif

  uniform sampler2D uSampler;
  varying vec2 vTextureCoord;

  void main(void) {
    gl_FragColor = texture2D(uSampler, vec2(vTextureCoord.s, vTextureCoord.t));
  }
</script>
<script id="shader-tile-vs" type="x-shader/x-vertex">
  attribute vec3 aVertexPosition;
  attribute vec2 aTextureCoord;

  uniform mat4 uMVMatrix;
  uniform mat4 uPMatrix;
  uniform mat3 uNMatrix;
  varying vec2 vTextureCoord;

  void main(void) {
    gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);
    vTextureCoord = aTextureCoord;
  }
</script>
<script id="shader-text-fs" type="x-shader/x-fragment">
  precision mediump float;

  varying vec2 vTextureCoord;
  uniform sampler2D uSampler;
  uniform vec3 uColor;

  void main(void) {
    vec4 textureColor = texture2D(uSampler, vec2(vTextureCoord.s, vTextureCoord.t));
    // Use the image pixel value as transparency.
    gl_FragColor = vec4(uColor, textureColor.rgb[0]);
  }
</script>
<script id="shader-text-vs" type="x-shader/x-vertex">
  attribute vec3 aVertexPosition;
  attribute vec2 aTextureCoord;

  uniform mat4 uMVMatrix;
  uniform mat4 uPMatrix;

  varying vec2 vTextureCoord;
  void main(void) {
    gl_Position = uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);
    vTextureCoord = aTextureCoord;
  }
</script>
<script type="text/javascript">
  var TEMPLATE = "stack.html";
  var SESSION_DATABASE;
  var USER;

  // Arguments
  var DBID;
  var SESSID;
  var VIEWS;
  var TRANSFORMATIONS;

  var SECTIONS;
  var SECTION_INDEX;
  var CANVAS;
  var EVENT_MANAGER;
  var VIEWER1;
  var EDIT = true;
  var EDIT_R = false;

  var IMAGE_PATH_URL = "{{ url_for('glviewer.static', filename='') }}";

  // I cannot check if DUAL_VIEW is defined so just include it.
  var DUAL_VIEW = false;

  var CONTROL_PRESSED = false;
  var DRAGGING_CROSS = null;


  //----------------------------------------------------------------------------
  // sets the global variable ARGS
  function InitStack() {

    SESSION_DATABASE = "{{ db }}";
    USER = "";
    SESSID = "{{ sess }}";
    DBID  = "{{ db }}";
    $.ajax({
        type: "get",
        url: "/webgl-viewer/stack-session",
        data: {"db" :  DBID,
               "sess" : SESSID},
        success: function(data,status)
                   { 
                   LoadStack(data);
                   },
        error: function() { alert( "AJAX ARGS - error()" ); },
    });
  }


// Eventually I want stacks to look just like notes.
function LoadStack(data) {
  VIEWS = data["views"];

  // To bad json does not save the object type.  Need to cast.
  var transformations = data["transformations"];
  TRANSFORMATIONS = [];
  for (var i=0; i < transformations.length; ++i) {
    var trans = new PairTransformation();
    if (transformations[i].View0) {
      trans.View0 = transformations[i].View0;
    } else {   // one time change database.
      trans.View0 = VIEWS[i]._id;
    }
    if (transformations[i].View1) {
      trans.View1 = transformations[i].View1;
    } else {    // one time change database.
      trans.View1 = VIEWS[i+1]._id;
    }
    trans.Correlations = transformations[i].Correlations;
    TRANSFORMATIONS.push(trans);
  }



  ANNOTATIONS = [];
  for (var i=0; i < VIEWS.length; ++i) {
    ANNOTATIONS.push([]);
  }
  for (var i=0; i < data["annotations"].length; ++i) {
    var sectionAnnotations = data["annotations"][i];
    // I have to use the viewer because it has the method for
    // loading annotations.
    VIEWER1.WidgetList = [];
    for (var j = 0; j < sectionAnnotations.length; ++j) {
      VIEWER1.LoadWidget(sectionAnnotations[j]);
    }
    ANNOTATIONS[i] = VIEWER1.WidgetList;
    VIEWER1.WidgetList = [];
  }


  // Preload all the sources.
  SECTIONS = [];
  for (var i=0; i < VIEWS.length; ++i) {
      view = VIEWS[i];
      var source = null;
      // Since multiple section are in one slide. Reuse sources when possible.
      for (j = 0; j < i; ++j) {
          if (VIEWS[j].img._id == view.img._id) {
              source = SECTIONS[j].Source;
          }
      }
      if ( ! source) {
          source = new Cache({'database':view.db,
                              '_id':view.img._id,
                              'levels':view.img.levels,
                              'bounds':view.img.bounds});
      }
      var section = {"Source": source, "View": view._id, "Annotations": ANNOTATIONS[i]};
      SECTIONS.push(section);
  }

  // Setup the points.
  SECTION_INDEX = 0;
  VIEWER1.SetCache(SECTIONS[SECTION_INDEX].Source);
  VIEWER1.WidgetList = SECTIONS[SECTION_INDEX].Annotations;
  VIEWER1.SetCamera(VIEWS[SECTION_INDEX].center, 0, VIEWS[SECTION_INDEX].height);

  setupCrossHairs();

}





// url: "http://localhost:8080/webgl-viewer/stack-save",
function saveStack() {
  $.ajax({
    type: "post",
    url: "/webgl-viewer/stack-save",
    data: {"db": DBID,
           "sess": SESSID,
           "data" :  JSON.stringify( {"views": VIEWS,
                                      "transformations": TRANSFORMATIONS })
          },
                                      
    success: function(data,status){
       //alert(data + "\nStatus: " + status);
       },
    error: function() { alert( "AJAX - error()" ); },
    });
}


function swapSections() {
    if (SECTION_INDEX <= 0) { return; }
    if (SECTION_INDEX > 1)
      { // transform correlations to point to new image.
      var t0 = TRANSFORMATIONS[SECTION_INDEX-2];          
      var t1 = TRANSFORMATIONS[SECTION_INDEX-1];          
      // convert the correlations
      var correlations = t0.Correlations;
      for (var i = 0; i < correlations.length; ++i)
        {
        var cor = correlations[i];
        cor.point1 = t1.ForwardTransform(cor.point1);
        }
      }
    if (SECTION_INDEX < TRANSFORMATIONS.length)
      { // transform correlations to point to new image.
      var t1 = TRANSFORMATIONS[SECTION_INDEX-1];          
      var t2 = TRANSFORMATIONS[SECTION_INDEX];          
      // convert the correlation
      var correlations = t2.Correlations;
      for (var i = 0; i < correlations.length; ++i)
        {
        var cor = correlations[i];
        cor.point0 = t1.ReverseTransform(cor.point0);
        }
      }
    
    var t1 = TRANSFORMATIONS[SECTION_INDEX-1];          
    // convert the correlation (swap points)
    var correlations = t1.Correlations;
    for (var i = 0; i < correlations.length; ++i)
      {
      var cor = correlations[i];
      var tmp = cor.point0;
      cor.point0 = cor.point1;
      cor.point1 = tmp;
      }

    // Now swap the section
    var tmp = VIEWS[SECTION_INDEX];
    VIEWS[SECTION_INDEX] = VIEWS[SECTION_INDEX-1];
    VIEWS[SECTION_INDEX-1] = tmp;

    tmp = SECTIONS[SECTION_INDEX];
    SECTIONS[SECTION_INDEX] = SECTIONS[SECTION_INDEX-1];
    SECTIONS[SECTION_INDEX-1] = tmp;
    --SECTION_INDEX;
    setupCrossHairs();
}


function findCorrelation(pIdx, x, y) {
    var cam = VIEWER1.GetCamera();
    var threshold = cam.Height / 50;
    threshold = threshold*threshold;
    var transformation = TRANSFORMATIONS[SECTION_INDEX];          
    var correlations = transformation.Correlations;
    var bestIdx = -1;
    var bestDists;
    for (var i = 0; i < correlations.length; ++i)
      {
      var cor = correlations[i];
      var pt = cor.point0;
      if (pIdx) { pt = cor.point1; }
      var dx = x-pt[0];
      var dy = y-pt[1];
      var dist2 = dx*dx + dy*dy;
      if (bestIdx < 0 || dist2 < bestDist2) 
        {
        bestIdx = i;
        bestDist2 = dist2;
        }
      }
   return bestIdx;
}


function deleteCorrelation(x, y) {
    var transformation = TRANSFORMATIONS[SECTION_INDEX];          
    var index = findCorrelation(0,x,y);
    if (index > -1) {
      transformation.Correlations.splice(index, 1);
      console.log("Delete: Success");
      eventuallyRender();
    }
}




function handleResize() {
    if (GL) {
      var width = CANVAS.innerWidth();
      var height = CANVAS.innerHeight();
      CANVAS.attr("width",width.toString());
      CANVAS.attr("height",height.toString());
      GL.viewport(0, 0, width, height);
      if (VIEWER1) {
        VIEWER1.SetViewport([0, 0, width, height]);
        eventuallyRender();
      }
    }
};


function InitViews() {
    var width = CANVAS.innerWidth();
    var height = CANVAS.innerHeight();
    VIEWER1 = initView([0,0, width, height]);

    handleResize();
}


function saveAnnotation() {
  // make sure the Anntoatoions are synced up.
  SECTIONS[SECTION_INDEX].Annotations = VIEWER1.WidgetList;

  if ( ! EDIT) {
    alert("No edit privaleges");
    return;
  }
  var d = new Date();

  for (var i = 0; i < SECTIONS.length; ++i) {
    var section = SECTIONS[i];
    // create a note from a section
    var note = new Note();
    // What if no parent?
    note.ParentId = "";
    note.Id = section.View;
    note.Title = "";
    note.HiddenTitle = "";
    note.Text = "";
    note.RecordView();
    // Put in the correct annotations.
    var viewerRecord = note.ViewerRecords[0];
    viewerRecord.Image = section.Source.Image;
    viewerRecord.Database = section.Source.Image.database;
    viewerRecord.Annotations = [];
    for (var j = 0; j < section.Annotations.length; ++j) {
      viewerRecord.Annotations.push(section.Annotations[j].Serialize());
    }

    var noteObj = JSON.stringify(note.Serialize(false));
    $("#saveButton").hide();
    $.ajax({
      type: "post",
      url: "/webgl-viewer/saveviewnotes",
      data: {"note" : noteObj,
             "db"   : GetSessionDatabase(),
             "date" : d.getTime()},
      success: function(data,status) { $("#saveButton").show(); },
      error: function() { alert( "AJAX - error() : saveviewnotes (stack)" ); },
    });
  }
}
 


function updateSection(inc) {
    var newIdx = SECTION_INDEX + inc;
    if (newIdx < 0 || newIdx >= SECTIONS.length) {
        return;
    }

    // Save the widgets from the section we are leaving.
    SECTIONS[SECTION_INDEX].Annotations = VIEWER1.WidgetList;

    var cam = VIEWER1.GetCamera();
    var rotation = cam.GetRotation();
    var height = cam.Height;
    var center = [cam.FocalPoint[0], cam.FocalPoint[1], cam.FocalPoint[2]];

    // Set the source.
    VIEWER1.SetCache(SECTIONS[newIdx].Source);

    // Set the widgets of the section we are going to.
    VIEWER1.WidgetList = SECTIONS[newIdx].Annotations;

    // Compute the new camera.
    if (inc < 0) {
        center = TRANSFORMATIONS[newIdx].ReverseTransform(center);
        rotation += TRANSFORMATIONS[newIdx].DeltaRotation;
    } else {
        center = TRANSFORMATIONS[SECTION_INDEX].ForwardTransform(center);
        rotation += TRANSFORMATIONS[SECTION_INDEX].DeltaRotation;
        // We need to transform the event world point to avoid bug with chain when
        // Mouse is not moved.
        var tmp = TRANSFORMATIONS[SECTION_INDEX].ForwardTransform([EVENT_MANAGER.MouseWorldX, EVENT_MANAGER.MouseWorldY]);
        EVENT_MANAGER.MouseWorldX = tmp[0];
        EVENT_MANAGER.MouseWorldY = tmp[1];
    }

    VIEWER1.SetCamera(center, rotation, height);
    SECTION_INDEX = newIdx;

    setupCrossHairs();
  }


  // Markers to see stack correlations.
  function setupCrossHairs() {
    if ( ! EDIT_R) { return; }
    VIEWER1.ShapeList = [];
    VIEWER1.AnnotationVisibility = 1;

    if ( SECTION_INDEX < TRANSFORMATIONS.length) {
        var trans = TRANSFORMATIONS[SECTION_INDEX];
        for (i in trans.Correlations) {
            var c = trans.Correlations[i];
            var cross = new CrossHairs();
            cross.FillColor    = [1,0,0];
            cross.OutlineColor = [0,1,1];
            cross.Origin       = c.point0; // I expect reference will update transform automatically.
            VIEWER1.AddShape(cross);
            cross.Correlation = c;
            cross.CorrelationPoint = 0;
        }
    }
    if (SECTION_INDEX > 0) {
        var trans = TRANSFORMATIONS[SECTION_INDEX-1];
        for (i in trans.Correlations) {
            var c = trans.Correlations[i];
            var cross = new CrossHairs();
            cross.FillColor    = [0,1,1];
            cross.OutlineColor = [1,0,0];
            cross.Origin       = c.point1; // I expect reference will update transform automatically.
            VIEWER1.AddShape(cross);
            cross.Correlation = c;
            cross.CorrelationPoint = 1;
        }
    }
    eventuallyRender();
}

var FeatureChainEndCross;
var FeatureChainEndIndex;
// x, y are in world coordinates
function FeatureChainStart(x,y) {
    // Create a widget just for show.
    var cross = new CrossHairs();
    cross.FillColor    = [1,0,0];
    cross.OutlineColor = [0,1,1];
    cross.Origin       = [x, y];
    // Save for the position for the next link.
    VIEWER1.AddShape(cross);
    VIEWER1.SetAnnotationVisibility(ANNOTATION_ON);
    FeatureChainEndCross = cross;
    FeatureChainEndIndex = SECTION_INDEX;
    eventuallyRender();
}
// x, y are in world coordinates
function FeatureChainAdd(x,y) {
    if ( ! FeatureChainEndCross ) {
        FeatureChainStart(x,y);
        return;
    }
    if (SECTION_INDEX <= 0) {
        alert("First section cannot end a feature link.");
        return;
    }
    if (SECTION_INDEX != FeatureChainEndIndex + 1) {
        alert("Link cannot span more than one section.");
        return;
    }

    // Create the correlation.
    var trans = TRANSFORMATIONS[SECTION_INDEX-1];
    trans.Correlations.push({"point0": [FeatureChainEndCross.Origin[0],FeatureChainEndCross.Origin[1]],
                             "point1": [x,y]});
    // Create a widget just for show.
    var cross = new CrossHairs();
    cross.FillColor    = [0,1,1];
    cross.OutlineColor = [1,0,0];
    // A dance to set cross origin as pointer to correlation array.
    var correlation = trans.Correlations[trans.Correlations.length-1];
    cross.Origin       = correlation.point1;
    VIEWER1.AddShape(cross);
    cross.Correlation = correlation;
    cross.CorrelationPoint = 1;
    VIEWER1.SetAnnotationVisibility(ANNOTATION_ON);

    // Save for the position for the next link.
    FeatureChainEndCross = cross;
    FeatureChainEndIndex = SECTION_INDEX;
    eventuallyRender();
}


  function draw() {
    if (GL) {
      GL.clear(GL.COLOR_BUFFER_BIT | GL.DEPTH_BUFFER_BIT);
    }
    // This just changes the camera based on the current time.
    VIEWER1.Animate();
    VIEWER1.Draw();
  }

  // Hack to be replaced soon
  var E_DOWN = false;
  var D_DOWN = false;
  var R_DOWN = false;

  // The event manager detects single right click and double right click.
  // This gets galled on the single.
  function ShowPropertiesMenu(x, y) {
    if (EDIT) {
      ShowAnnotationEditMenu(x, y);
    }
  }

  function handleMouseDown(event) { 
    // hack drag
    if (CONTROL_PRESSED && EDIT_R) {
      var cam = VIEWER1.GetCamera();
      var threshold = cam.Height / 50;
      threshold = threshold*threshold;
      // Find the best cross.
      var bestDist = 0;
      var bestCross = null;
      for (var i = 0; i < VIEWER1.ShapeList.length; ++i) {
        var cross = VIEWER1.ShapeList[i];
        var dx = EVENT_MANAGER.MouseWorldX - cross.Origin[0];
        var dy = EVENT_MANAGER.MouseWorldY - cross.Origin[1];
        var dist = (dx*dx) + (dy*dy);
        if (dist < threshold) {
          if (bestCross == null || dist <= bestDist) {
            bestCross = cross;
            bestDist = dist;
          }
        }
      }
      DRAGGING_CROSS = bestCross;
    }
    if (DRAGGING_CROSS == null) {
      EVENT_MANAGER.HandleMouseDown(event); 
    }
  }

  function handleMouseUp(event) { 
    DRAGGING_CROSS = null;
    EVENT_MANAGER.HandleMouseUp(event); 
  }

  function handleMouseMove(event) {
    if (DRAGGING_CROSS) {
      EVENT_MANAGER.MouseX = event.x;
      EVENT_MANAGER.MouseY = event.y;
      VIEWER1.ComputeMouseWorld(EVENT_MANAGER);
      // This only handles dragging the second half of the transformation.
      DRAGGING_CROSS.Origin = [EVENT_MANAGER.MouseWorldX, EVENT_MANAGER.MouseWorldY];
      if (DRAGGING_CROSS.CorrelationPoint == 0) {
        DRAGGING_CROSS.Correlation.point0 = DRAGGING_CROSS.Origin;
      } else {
        DRAGGING_CROSS.Correlation.point1 = DRAGGING_CROSS.Origin;
      }
      eventuallyRender();
    } else {
      EVENT_MANAGER.HandleMouseMove(event);
    }
  }


  function handleMouseWheel(event) {EVENT_MANAGER.HandleMouseWheel(event);}
  function handleKeyDown(event) {
    if (DIALOG_OPEN) { return; } // Hack to keep stack from processing space events when a dialog is open.
    if (event.keyCode == 68) { D_DOWN = true;}
    if (event.keyCode == 17) { 
      CONTROL_PRESSED = true;
    }
    if (event.keyCode == 69) { E_DOWN = true;}
    if (event.keyCode == 82) { R_DOWN = true;}
    if (D_DOWN && E_DOWN) {
      EDIT = ! EDIT;
      alert("Edit: " + EDIT);
      E_DOWN = false;
      D_DOWN = false;
    }
    if (D_DOWN && R_DOWN) {
      EDIT_R = ! EDIT_R;
      alert("Edit 'R': " + EDIT_R);
      E_DOWN = false;
      R_DOWN = false;
    }
    if (event.keyCode == 33 || event.keyCode == 37 ) { // page up
      updateSection(-1);
    }
    if (event.keyCode == 34 || event.keyCode == 32
                            || event.keyCode == 39) { // page down or space
      updateSection(1);
    }
    if (event.keyCode == 90) { // z, (backspace is handled by browser) (swap sections)
      // move the current section back one
      if (EDIT_R) { swapSections();}
    }
    if (event.keyCode == 46) { // delete
      if (EDIT_R) { deleteCorrelation(EVENT_MANAGER.MouseWorldX, EVENT_MANAGER.MouseWorldY);}
    }
    if (event.keyCode == 83) { // 's'
      if (EDIT_R) { saveStack();}
    }
    if (event.keyCode == 49) { // '1' : start a new feature chain
      if (EDIT_R) { FeatureChainStart(EVENT_MANAGER.MouseWorldX, EVENT_MANAGER.MouseWorldY); }
    }
    if (event.keyCode == 50) { // '2' : start a new feature chain
      if (EDIT_R) { FeatureChainAdd(EVENT_MANAGER.MouseWorldX, EVENT_MANAGER.MouseWorldY); }
    }
    EVENT_MANAGER.HandleKeyDown(event);
  }

  function handleKeyUp(event) {
        if (event.keyCode == 17) { 
          CONTROL_PRESSED = false;
        }
        if (event.keyCode == 68) { D_DOWN = false;}
        if (event.keyCode == 69) { E_DOWN = false;}
        if (event.keyCode == 82) { R_DOWN = false;}
        EVENT_MANAGER.HandleKeyUp(event);}
  function cancelContextMenu(e) {
    //alert("Try to cancel context menu");
    if (e && e.stopPropagation)
      e.stopPropagation();
    return false;
  }



// Not used at the moment.
function InitAnnotations(viewer, annotations)
{
    if (annotations.length == 0) {
        return;
    }

    for (i in annotations) {
        var annotation = annotations[i];
        widget = new TextWidget(viewer, annotation.string);
        var p1 = annotation.position;
        var offset = annotation.offset;
        widget.SetPosition(p1[0], p1[1]);
        widget.SetTextOffset(offset[0], offset[1]);
        widget.SetAnchorShapeVisibility(true);
    }
}

function ToggleAnnotationVisibility() {
    SetAnnotationVisibility( ! VIEWER1.ShapeVisibility);
}


  function Start() {
    detectMobile();
    // Just to see if webgl is supported:
    var testCanvas = document.getElementById("gltest");
    // I think the webgl viewer crashes.
    // Maybe it is the texture leak I have seen in connectome.
    // Just use the canvas for now.
    if ( ! MOBILE_DEVICE && doesBrowserSupportWebGL(testCanvas)) {
      initGL(); // Sets CANVAS and GL global variables
    } else {
      initGC();
    }
    EVENT_MANAGER = new EventManager(CANVAS);
    if (MOBILE_DEVICE) {
      MOBILE_ANNOTATION_WIDGET = new MobileAnnotationWidget();
    }
    InitViews();
    InitStack();

    var annotationWidget = new AnnotationWidget(VIEWER1);
    annotationWidget.SetVisibility( ANNOTATION_ON);

    $(window).resize(function() {
        handleResize();
    }).trigger('resize');


    CANVAS[0].onmousedown = handleMouseDown;
    // CANVAS[0].ondblclick = handleDoubleClick; // does not detect right button double clicks.
    // event manager will use up down events to detect double clicks.
    CANVAS[0].onmousewheel = handleMouseWheel;
    document.onmouseup = handleMouseUp;
    document.onmousemove = handleMouseMove;

    document.onkeydown = handleKeyDown;
    document.onkeyup = handleKeyUp;
    document.oncontextmenu = cancelContextMenu;





    // Place the previous next buttons.
    $('<img>').appendTo('body')
      .css({
        'opacity': '0.4',
        'position': 'absolute',
        'height': '50px',
        'width': '50px',
        'bottom' : '5px',
        'left' : '5px',
        'z-index': '2'})
      .attr('class', 'viewer1')
      .attr('type','image')
      .attr('src',"{{ url_for('glviewer.static', filename='leftArrow2.png')}}")
      .click(function(){ updateSection(-1); });
    $('<img>').appendTo('body')
      .css({
        'opacity': '0.4',
        'position': 'absolute',
        'height': '50px',
        'width': '50px',
        'bottom' : '5px',
        'left' : '55px',
        'z-index': '2'})
      .attr('class', 'viewer1')
      .attr('type','image')
      .attr('src',"{{ url_for('glviewer.static', filename='rightArrow2.png')}}")
      .click(function(){ updateSection(1); });


    // Button to save annotation
    $('<img>').appendTo('body').css({
        'opacity': '0.4',
        'position': 'absolute',
        'height': '30px',
        'width': '30px',
        'bottom' : '12px',
        'right' : '326px',
        'z-index': '2'})
      .attr('id', 'saveButton')
      .attr('class', 'viewer1')
      .attr('type','image')
      .attr('src',"{{ url_for('glviewer.static', filename='save.png')}}")
      .click(function(){ saveAnnotation(); });


    eventuallyRender();
  }

  function NewArrow() {
    // When the arrow button is pressed, create the widget.
    var widget = new ArrowWidget(VIEWER1, true);
    VIEWER1.ActiveWidget = widget;
    eventuallyRender();
  }



  function zoomIn() {
    VIEWER1.AnimateZoom(0.5);
  }

  function zoomOut() {
    VIEWER1.AnimateZoom(2.0);
  }

  function rotateRight() {
    VIEWER1.AnimateRoll(-12.0); // degrees
  }

  function rotateLeft() {
    VIEWER1.AnimateRoll(12.0); // degrees
  }



  //********************************************************

  $(document).ready(function() {
    Start();
  });

</script>


<style>
#feedback { font-size: 1.4em; }
#optionMenu .ui-selecting { background: #FECA40; }
#optionMenu .ui-selected { background: #F39814; color: white; }
#optionMenu { list-style-type: none; margin: 0; padding: 0; width: 60%; }
#optionMenu li { padding: 3px; height: 18px; width: 100%}
</style>


<canvas id="gltest" style="display:none" ></canvas>




